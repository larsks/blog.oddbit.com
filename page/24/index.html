<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.110.0"><title>blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="blog.oddbit.com"><meta property="og:description" content><meta property="og:url" content="https://blog.oddbit.com/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/rss.xml rel=alternate type=application/rss+xml title=blog.oddbit.com></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><div class="index-content framed"><img src="https://s.gravatar.com/avatar/1c09a8d9e719f9d13b6c99f6bb2637d8?s=80" alt="Uncle Deadly Image" class=center style=border-radius:8px><p>Hi there. Welcome to <a href=https://blog.oddbit.com><code>blog.oddbit.com</code></a>! I post articles here on a variety of technical topics. Mostly I&rsquo;m posting for myself (writing things up helps me remember them in the future), but I always hope the content I put here is helpful to someone else. If you find something here useful and want to say thanks, feel free to <a href=https://www.buymeacoffee.com/oddbit>buy me a coffee</a>!</p></div><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-01-04-building-a-minimal-web-server-/>Building a minimal web server for testing Kubernetes</a></h1><div class=post-meta><time class=post-date>2015-01-04 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;</span><div class=post-content>I have recently been doing some work with Kubernetes, and wanted to put together a minimal image with which I could test service and pod deployment. Size in this case was critical: I wanted something that would download quickly when initially deployed, because I am often setting up and tearing down Kubernetes as part of my testing (and some of my test environments have poor external bandwidth).
Building thttpd My go-to minimal webserver is thttpd.</div><div><a class="read-more button" href=/post/2015-01-04-building-a-minimal-web-server-/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2014-12-22-accessing-the-serial-console-o/>Accessing the serial console of your Nova servers</a></h1><div class=post-meta><time class=post-date>2014-12-22 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/nova/>nova</a>&nbsp;</span><div class=post-content>One of the new features available in the Juno release of OpenStack is support for serial console access to your Nova servers. This post looks into how to configure the serial console feature and then how to access the serial consoles of your Nova servers.
Configuring serial console support In previous release of OpenStack, read-only access to the serial console of your servers was available through the os-getConsoleOutput server action (exposed via nova console-log on the command line).</div><div><a class="read-more button" href=/post/2014-12-22-accessing-the-serial-console-o/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2014-12-10-cloudinit-and-the-case-of-the-/>Cloud-init and the case of the changing hostname</a></h1><div class=post-meta><time class=post-date>2014-12-10 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/rdo/>rdo</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/neutron/>neutron</a>&nbsp;</span><div class=post-content>Setting the stage I ran into a problem earlier this week deploying RDO Icehouse under RHEL 6. My target systems were a set of libvirt guests deployed from the RHEL 6 KVM guest image, which includes cloud-init in order to support automatic configuration in cloud environments. I take advantage of this when using libvirt by attaching a configuration drive so that I can pass in ssh keys and a user-data script.</div><div><a class="read-more button" href=/post/2014-12-10-cloudinit-and-the-case-of-the-/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2014-12-02-starting-systemd-services-with/>Starting systemd services without blocking</a></h1><div class=post-meta><time class=post-date>2014-12-02 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/systemd/>systemd</a>&nbsp;</span><div class=post-content>Recently, I’ve been playing around with Fedora Atomic and Kubernetes. I ran into a frustrating problem in which I would attempt to start a service from within a script launched by cloud-init, only to have have systemctl block indefinitely because the service I was attempting to start was dependent on cloud-init finishing first.
It turns out that systemctl has a flag meant exactly for this situation:
&ndash;no-block Do not synchronously wait for the requested operation to finish.</div><div><a class="read-more button" href=/post/2014-12-02-starting-systemd-services-with/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2014-11-24-fedora-atomic-openstack-and-ku/>Fedora Atomic, OpenStack, and Kubernetes (oh my)</a></h1><div class=post-meta><time class=post-date>2014-11-24 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/fedora/>fedora</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/atomic/>atomic</a>&nbsp;</span><div class=post-content>While experimenting with Fedora Atomic, I was looking for an elegant way to automatically deploy Atomic into an OpenStack environment and then automatically schedule some Docker containers on the Atomic host. This post describes my solution.
Like many other cloud-targeted distributions, Fedora Atomic runs cloud-init when the system boots. We can take advantage of this to configure the system at first boot by providing a user-data blob to Nova when we boot the instance.</div><div><a class="read-more button" href=/post/2014-11-24-fedora-atomic-openstack-and-ku/>read more →</a></div></article><div class=pagination><div class=pagination__buttons><a href=/page/23/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>Newer posts</span></a>
<a href=/page/25/ class="button next"><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script>
<script src=/js/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>