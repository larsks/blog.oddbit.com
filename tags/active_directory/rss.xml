<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>active_directory on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/active_directory/</link><description>Recent content in active_directory on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Tue, 29 Jun 2010 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/active_directory/rss.xml" rel="self" type="application/rss+xml"/><item><title>Kerberos authenticated queries to Active Directory</title><link>https://blog.oddbit.com/post/2010-06-29-linux-kerberos-ad/</link><pubDate>Tue, 29 Jun 2010 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2010-06-29-linux-kerberos-ad/</guid><description>There are many guides out there to help you configure your Linux system as an LDAP and Kerberos client to an Active Directory server. Most of these guides solve the problem of authentication by embedding a username and password into a configuration file somewhere on your system. While this works, it presents some problems:
If you use a common account for authentication from all of your Linux systems, a compromise on one system means updating the configuration of all of your systems.</description><content>&lt;p>There are many guides out there to help you configure your Linux system as an LDAP and Kerberos client to an Active Directory server. Most of these guides solve the problem of authentication by embedding a username and password into a configuration file somewhere on your system. While this works, it presents some problems:&lt;/p>
&lt;ul>
&lt;li>If you use a common account for authentication from all of your Linux systems, a compromise on one system means updating the configuration of all of your systems.&lt;/li>
&lt;li>If you don&amp;rsquo;t want to use a common account, you need to provision a new account for each computer&amp;hellip;&lt;/li>
&lt;li>&amp;hellip;which is silly, because if you join the system to Active Directory there is already a computer object associated with the system that can be used for authentication.&lt;/li>
&lt;/ul>
&lt;p>This document describes how to configure a Linux system such that queries
generated by &lt;a href="http://www.padl.com/OSS/nss_ldap.html">nss_ldap&lt;/a> will use either the current user&amp;rsquo;s Kerberos
credentials, or, for the root user, credentials stored in a Kerberos
credentials cache.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Your Linux system must have a valid &lt;code>keytab&lt;/code> file.&lt;/p>
&lt;p>A &lt;code>keytab&lt;/code> is a file containing pairs of Kerberos principals and encrypted keys.&lt;/p>
&lt;p>Joining Active Directory using Samba&amp;rsquo;s &lt;code>net ads join&lt;/code> will create the
necessary keytab. It is also possible to create the keytab on your Windows
domain controller and install it on your Linux systems. Instructions for
doing this are beyond the scope of this document.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Host objects in Active Directory must have a &lt;code>userPrincipalName&lt;/code> attribute.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code>$ ldapsearch cn=dottiness userPrincipalName
dn: CN=DOTTINESS,CN=Computers,dc=example,dc=com
userPrincipalName: host/dottiness.example.com@EXAMPLE.COM
&lt;/code>&lt;/pre>
&lt;p>Active Directory &lt;em>does not&lt;/em> automatically create a &lt;code>userPrincipalName&lt;/code> when a new host object is provisioned. You will either need to provide this value manually or develop an automated process that will populate this field when provisioning new host objects.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Kerberos credentials have a maximum usable lifetime. The cached credentials
used for root queries by &lt;code>nss_ldap&lt;/code> must be refreshed periodically in order to
function.&lt;/p>
&lt;p>You will need to install a crontab (e.g., in &lt;code>/etc/cron.d&lt;/code>) that looks something
like this:&lt;/p>
&lt;pre>&lt;code>PATH=/bin:/usr/bin:/usr/kerberos/bin
@reboot root kinit -k -c /var/run/ldap_cc &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
@hourly root kinit -k -c /var/run/ldap_cc &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code>&lt;/pre>
&lt;p>This periodically reauthenticates to your domain controller used the cached
principal in the system keytab (&lt;code>/etc/krb5.keytab&lt;/code>) and caches the credentials in
&lt;code>/var/run/ldap_cc&lt;/code>.&lt;/p>
&lt;p>You will need something similar to the following in &lt;code>/etc/ldap.conf&lt;/code>:&lt;/p>
&lt;pre>&lt;code># This is your domain controller.
uri ldap://dc1.example.com
base dc=example,dc=com
scope one
referrals no
timelimit 120
bind_timelimit 120
idle_timelimit 3600
ldap_version 3
# Authenticate using SASL for user and root queries.
use_sasl on
rootuse_sasl on
# Use SASL's gssapi (Kerberos) mechanism.
sasl_mech gssapi
# Use these cached credentials for root.
krb5_ccname /var/run/ldap_cc
nss_base_group ou=groups,dc=example,dc=com
nss_base_passwd ou=people,dc=example,dc=com
nss_initgroups_ignoreusers root,ldap,named,avahi,haldaemon,dbus,radvd,tomcat,radiusd,news,mailman,nscd,gdm,polkituser
# These are common mappings for working with Active Directory.
nss_map_attribute uid sAMAccountName
nss_map_attribute uniqueMember member
nss_map_objectclass posixAccount user
nss_map_objectclass posixGroup group
nss_map_objectclass shadowAccount user
pam_login_attribute sAMAccountName
pam_member_attribute member
pam_password ad
pam_password_prohibit_message Please visit http://password.example.com to change your password.
pam_filter objectclass=User
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>use_sasl on&lt;/code> directive configures &lt;code>nss_ldap&lt;/code> to use the Kerberos credentials
for the current user when looking up user/group/etc information. The
&lt;code>rootuse_sasl on&lt;/code> attribute does the same thing for processes running as &lt;code>root&lt;/code>.&lt;/p>
&lt;p>Note that this configuration sets scope &lt;code>one&lt;/code>, which means that &lt;code>nss_ldap&lt;/code> &lt;em>will
not&lt;/em> recurse down a directory tree. This is a performance optimization, not a
requirement.&lt;/p>
&lt;h2 id="as-an-unprivileged-user">As an unprivileged user&lt;/h2>
&lt;p>Before acquiring Kerberos credentials:&lt;/p>
&lt;pre>&lt;code>$ getent passwd lars
(times out)
&lt;/code>&lt;/pre>
&lt;p>Authenticate to Kerberos:&lt;/p>
&lt;pre>&lt;code>$ kinit
Password for lars@EXAMPLE.COM:
&lt;/code>&lt;/pre>
&lt;p>With valid credentials:&lt;/p>
&lt;pre>&lt;code>$ getent passwd lars
lars:*:500:500:lars:\\emc00.example.com\staff\l\lars\windows:
&lt;/code>&lt;/pre>
&lt;h2 id="as-root">As root&lt;/h2>
&lt;p>Before acquiring Kerberos credentials:&lt;/p>
&lt;pre>&lt;code># getent passwd lars
(times out)
&lt;/code>&lt;/pre>
&lt;p>Update credentials cache from system keytab:&lt;/p>
&lt;pre>&lt;code># kinit -k
&lt;/code>&lt;/pre>
&lt;p>With valid credentials:&lt;/p>
&lt;pre>&lt;code># getent passwd lars
lars:*:500:500:lars:\\emc00.example.com\staff\l\lars\windows:
&lt;/code>&lt;/pre>
&lt;p>This configuration makes the operation of &lt;code>nss_ldap&lt;/code> dependent on valid Kerberos
credentials. If a user remains logged in after her Kerberos credentials have
expired, she will experience degraded behavior, since many name lookup
operations will timeout. Similarly, local system accounts that do not have
valid Kerberos credentials will experience similar behavior (and will thus only
be able to see local users and groups).&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></content></item><item><title>Merging directories with OpenLDAP's Meta backend</title><link>https://blog.oddbit.com/post/2010-02-16-merging-directories-with-openl/</link><pubDate>Tue, 16 Feb 2010 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2010-02-16-merging-directories-with-openl/</guid><description>This document provides an example of using OpenLDAP&amp;rsquo;s meta backend to provide a unified view of two distinct LDAP directory trees. I was frustrated by the lack of simple examples available when I went looking for information on this topic, so this is my attempt to make life easier for the next person looking to do the same thing.
The particular use case that motiviated my interest in this topic was the need to configure web applications to (a) authenticate against an existing Active Directory server while (b) also allowing new accounts to be provisioned quickly and without granting any access in the AD environment.</description><content>&lt;p>This document provides an example of using OpenLDAP&amp;rsquo;s meta backend to provide a unified view of two distinct LDAP directory trees. I was frustrated by the lack of simple examples available when I went looking for information on this topic, so this is my attempt to make life easier for the next person looking to do the same thing.&lt;/p>
&lt;p>The particular use case that motiviated my interest in this topic was the need to configure web applications to (a) authenticate against an existing Active Directory server while (b) also allowing new accounts to be provisioned quickly and without granting any access in the AD environment. A complicating factor is that the group managing the AD server(s) was not the group implementing the web applications.&lt;/p>
&lt;h1 id="assumptions">Assumptions&lt;/h1>
&lt;p>I&amp;rsquo;m making several assumptions while writing this document:&lt;/p>
&lt;ul>
&lt;li>You have root access on your system and are able to modify files in /etc/openldap and elsewhere on the filesystem.&lt;/li>
&lt;li>You are somewhat familiar with LDAP.&lt;/li>
&lt;li>You are somewhat familiar with OpenLDAP.&lt;/li>
&lt;/ul>
&lt;h1 id="set-up-backend-directories">Set up backend directories&lt;/h1>
&lt;h2 id="configure-slapd">Configure slapd&lt;/h2>
&lt;p>We&amp;rsquo;ll first create two &amp;ldquo;backend&amp;rdquo; LDAP directories. These will represent the directories you&amp;rsquo;re trying to merge. For the purposes of this example we&amp;rsquo;ll use the ldif backend, which stores data in LDIF format on the filesystem. This is great for testing (it&amp;rsquo;s simple and easy to understand), but not so great for performance.&lt;/p>
&lt;p>We define one backend like this in /etc/openldap/slapd-be-1.conf:&lt;/p>
&lt;pre>&lt;code>database ldif
suffix &amp;quot;ou=backend1&amp;quot;
directory &amp;quot;/var/lib/ldap/backend1&amp;quot;
rootdn &amp;quot;cn=ldif-admin,ou=backend1&amp;quot;
rootpw &amp;quot;LDIF&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>And a second backend like this in /etc/openldap/slapd-be-2.conf:&lt;/p>
&lt;pre>&lt;code>database ldif
suffix &amp;quot;ou=backend2&amp;quot;
directory &amp;quot;/var/lib/ldap/backend2&amp;quot;
rootdn &amp;quot;cn=ldif-admin,ou=backend2&amp;quot;
rootpw &amp;quot;LDIF&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Now, we need to load these configs into the main slapd configuration file. Open slapd.conf, and look for the following comment:&lt;/p>
&lt;pre>&lt;code>#######################################################################
# ldbm and/or bdb database definitions
#######################################################################
&lt;/code>&lt;/pre>
&lt;p>Remove anything below this comment and then add the following lines:&lt;/p>
&lt;pre>&lt;code>include /etc/openldap/slapd-be-1.conf
include /etc/openldap/slapd-be-2.conf
&lt;/code>&lt;/pre>
&lt;h2 id="start-up-slapd">Start up slapd&lt;/h2>
&lt;p>Start up your LDAP service:&lt;/p>
&lt;pre>&lt;code># slapd -f slapd.conf -h ldap://localhost/
&lt;/code>&lt;/pre>
&lt;p>And check to make sure it&amp;rsquo;s running:&lt;/p>
&lt;pre>&lt;code># ps -fe | grep slapd
root 15087 1 0 22:48 ? 00:00:00 slapd -f slapd.conf -h ldap://localhost/
&lt;/code>&lt;/pre>
&lt;h2 id="populate-backends-with-sample-data">Populate backends with sample data&lt;/h2>
&lt;p>We need to populate the directories with something to query.&lt;/p>
&lt;p>Put this in backend1.ldif:&lt;/p>
&lt;pre>&lt;code>dn: ou=backend1
objectClass: top
objectClass: organizationalUnit
ou: backend1
dn: ou=people,ou=backend1
objectClass: top
objectClass: organizationalUnit
ou: people
dn: cn=user1,ou=people,ou=backend1
objectClass: inetOrgPerson
cn: user1
givenName: user1
sn: Somebodyson
mail: user1@example.com
&lt;/code>&lt;/pre>
&lt;p>And this in backend2.ldif:&lt;/p>
&lt;pre>&lt;code>dn: ou=backend2
objectClass: top
objectClass: organizationalUnit
ou: backend2
dn: ou=people,ou=backend2
objectClass: top
objectClass: organizationalUnit
ou: people
dn: cn=user2,ou=people,ou=backend2
objectClass: inetOrgPerson
cn: user2
givenName: user2
sn: Somebodyson
mail: user2@example.com
&lt;/code>&lt;/pre>
&lt;p>And then load the data into the backends:&lt;/p>
&lt;pre>&lt;code>ldapadd -x -H ldap://localhost -D cn=ldif-admin,ou=backend1 \
-w LDIF -f backend1.ldif
&lt;/code>&lt;/pre>
&lt;p>And:&lt;/p>
&lt;pre>&lt;code>ldapadd -x -H ldap://localhost -D cn=ldif-admin,ou=backend2 \
-w LDIF -f backend2.ldif
&lt;/code>&lt;/pre>
&lt;p>You can verify that the data loaded correctly by issuing a query to the backends. E.g.:&lt;/p>
&lt;pre>&lt;code>ldapsearch -x -H ldap://localhost -b ou=backend1 -LLL
&lt;/code>&lt;/pre>
&lt;p>This should give you something that looks very much like the contents of backend1.ldif. You can do the same thing for backend2.&lt;/p>
&lt;h1 id="set-up-meta-database">Set up meta database&lt;/h1>
&lt;p>We&amp;rsquo;re now going to configure OpenLDAP&amp;rsquo;s meta backend to merge the two directory trees. Complete documentation for the meta backend can be found in the &lt;a href="http://www.openldap.org/software/man.cgi?query=slapd-meta&amp;amp;apropos=0&amp;amp;sektion=0&amp;amp;manpath=OpenLDAP+2.4-Release&amp;amp;format=html">slapd-meta man page&lt;/a>.&lt;/p>
&lt;p>Put the following into a file called slapd-frontend.conf (we&amp;rsquo;ll discuss the details in moment):&lt;/p>
&lt;pre>&lt;code>database meta
suffix &amp;quot;dc=example,dc=com&amp;quot;
uri &amp;quot;ldap://localhost/ou=backend1,dc=example,dc=com&amp;quot;
suffixmassage &amp;quot;ou=backend1,dc=example,dc=com&amp;quot; &amp;quot;ou=backend1&amp;quot;
uri &amp;quot;ldap://localhost/ou=backend2,dc=example,dc=com&amp;quot;
suffixmassage &amp;quot;ou=backend2,dc=example,dc=com&amp;quot; &amp;quot;ou=backend2&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>And then add to slapd.conf:&lt;/p>
&lt;pre>&lt;code>include /etc/openldap/slapd-frontend.conf
&lt;/code>&lt;/pre>
&lt;p>Restart slapd. Let&amp;rsquo;s do a quick search to see exactly what we&amp;rsquo;ve accomplished:&lt;/p>
&lt;pre>&lt;code>$ ldapsearch -x -H 'ldap://localhost/' \
-b dc=example,dc=com objectclass=inetOrgPerson -LLL
dn: cn=user1,ou=people,ou=backend1,dc=example,dc=com
objectClass: inetOrgPerson
cn: user1
givenName: user1
sn: Somebodyson
mail: user1@example.com
dn: cn=user2,ou=people,ou=backend2,dc=example,dc=com
objectClass: inetOrgPerson
cn: user2
givenName: user2
sn: Somebodyson
mail: user2@example.com
&lt;/code>&lt;/pre>
&lt;p>As you can see from the output above, a single query is now returning results from both backends, merged into the dc=example,dc=com hierarchy.&lt;/p>
&lt;h2 id="a-closer-look">A closer look&lt;/h2>
&lt;p>Let&amp;rsquo;s take a closer look at the meta backend configuration.&lt;/p>
&lt;pre>&lt;code>database meta
suffix &amp;quot;dc=example,dc=com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>The database statement begins a new database definition. The suffix statement identifies the namespace that will be served by this particular database.&lt;/p>
&lt;p>Here is the proxy for backend1 (the entry for backend2 is virtually identical):&lt;/p>
&lt;pre>&lt;code>uri &amp;quot;ldap://localhost/ou=backend1,dc=example,dc=com&amp;quot;
suffixmassage &amp;quot;ou=backend1,dc=example,dc=com&amp;quot; &amp;quot;ou=backend1&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>The uri statement defines the host (and port) serving the target directory tree. The full syntax of the uri statement is described in the &lt;a href="http://www.openldap.org/software/man.cgi?query=slapd-meta&amp;amp;apropos=0&amp;amp;sektion=0&amp;amp;manpath=OpenLDAP+2.4-Release&amp;amp;format=html">slapd-meta man page&lt;/a>; what we have here is a very simple example. The &lt;em>naming context&lt;/em> of the URI must fall within the namespace defined in the suffix statement at the beginning of the database definition.&lt;/p>
&lt;p>The suffixmassage statement performs simple rewriting on distinguished names. It directs &lt;em>slapd&lt;/em> to replace ou=backend1,dc=example,dc=com with ou=backend1 when communicating with the backend directory (and vice-versa).&lt;/p>
&lt;p>You can perform simple rewriting of attribute and object classes with the map statement. For example, if backend1 used a sAMAccountName attribute and our application was expecting a uid attribute, we could add this after the suffixmassage statement:&lt;/p>
&lt;pre>&lt;code>map attribute uid sAMAccountName
&lt;/code>&lt;/pre>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>The sample configuration files, data, and code referenced in this post are available online in &lt;a href="http://github.com/larsks/OpenLDAP-Metadirectory-Example">a github repository&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="http://github.com/larsks/OpenLDAP-Metadirectory-Example">http://github.com/larsks/OpenLDAP-Metadirectory-Example&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>I hope you&amp;rsquo;ve found this post useful, or at least informative. If you have any comments or questions regarding this post, please log them as issues on GitHub. This will make them easier for me to track.&lt;/p></content></item></channel></rss>