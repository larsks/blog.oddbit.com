<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gdb on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/gdb/</link><description>Recent content in gdb on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Tue, 22 Jan 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/gdb/rss.xml" rel="self" type="application/rss+xml"/><item><title>Debugging attiny85 code, part 1: simavr and gdb</title><link>https://blog.oddbit.com/posts/debugging-attiny-code-pt-1/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/posts/debugging-attiny-code-pt-1/</guid><description>In a case of awful timing, after my recent project involving some attiny85 programming I finally got around to learning how to use simavr and gdb to help debug my AVR code. It was too late for me (and I will never get the time back that I spent debugging things with an LED and lots of re-flashing), but maybe this will help someone else!
I&amp;rsquo;ve split this into three posts:</description><content>&lt;p>In a case of awful timing, after my &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/">recent project involving some attiny85 programming&lt;/a> I finally got around to learning how to use &lt;a href="https://github.com/buserror/simavr">simavr&lt;/a> and &lt;code>gdb&lt;/code> to help debug my AVR code. It was too late for me (and I will never get the time back that I spent debugging things with an LED and lots of re-flashing), but maybe this will help someone else!&lt;/p>
&lt;p>I&amp;rsquo;ve split this into three posts:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>This is part 1.&lt;/p>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/">an earlier post&lt;/a>. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In this walkthrough I won&amp;rsquo;t be attempting to fix a bug, so perhaps the term &amp;ldquo;debugging&amp;rdquo; is, if not a misnomer, than at least only broadly applied. Rather, I am attempting to verify that my code behaves as expected in response to various inputs to the microcontroller pins.&lt;/p>
&lt;p>&lt;a href="https://github.com/larsks/pipower">Pipower&lt;/a> is implemented as a simple state machine. In each operational state, changes to input pins or timer expirations can cause it to transition into another state. The complete set of states look like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="pipower_states.png" />
&lt;/figure>
&lt;p>We&amp;rsquo;re going to walk through a particular set of state transitions.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>Before we start debugging, we should make sure that the code is built with debugging symbols and without optimizations. If you &lt;code>cd&lt;/code> into the &lt;code>sim&lt;/code> directory of the &lt;code>pipower&lt;/code> project and run &lt;code>make&lt;/code>, that&amp;rsquo;s exactly what you&amp;rsquo;ll get.&lt;/p>
&lt;pre>&lt;code>$ cd sim
$ make
[...]
avr-gcc -I.. -DTIMER_BOOTWAIT=1000 -DTIMER_SHUTDOWN=1000 -DTIMER_POWEROFF=1000 -Wall -g -Og -DF_CPU=1000000 -mmcu=attiny85 -c ../pipower.c -o pipower.o
[...]
&lt;/code>&lt;/pre>
&lt;p>There are several things happening here:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The &lt;code>Makefile&lt;/code> in this directory sets &lt;code>VPATH=..&lt;/code>, which means &lt;code>make&lt;/code> will look in the parent directory to find our sources. We need to tell the compiler to also look for include files in that directory; we do that with &lt;code>-I..&lt;/code>.&lt;/p>
&lt;p>A caveat to the above is that &lt;code>make&lt;/code> will also look in &lt;code>..&lt;/code> for object files to determine whether or not they need to be rebuilt. If you have previously built &lt;code>pipower&lt;/code> from the project root directory, you&amp;rsquo;ll want to run a &lt;code>make clean&lt;/code> in that directory first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We&amp;rsquo;re enabling debug symbols (with &lt;code>-g&lt;/code>) and disabling most optimizations with &lt;code>-Og&lt;/code>. From the &lt;code>gcc&lt;/code> &lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">manual&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>-Og&lt;/code> should be the optimization level of choice for the standard edit-compile-debug cycle, offering a reasonable level of optimization while maintaining fast compilation and a good debugging experience. It is a better choice than &lt;code>-O0&lt;/code> for producing debuggable code because some compiler passes that collect debug information are disabled at &lt;code>-O0&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>We are redefining several timers to be much shorter so that we don&amp;rsquo;t have to wait around when debugging (&lt;code>-DTIMER_BOOTWAIT=1000&lt;/code>, etc).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="start-simavr">Start simavr&lt;/h2>
&lt;p>We need to start &lt;code>simavr&lt;/code> before we can attach to it with &lt;code>gdb&lt;/code>. We&amp;rsquo;ll need to provide it with a path to our compiled &lt;code>pipower.elf&lt;/code> file, and we also want to make sure that we provide a clock frequency that matches the value of &lt;code>F_CPU&lt;/code> we used when building our code (&lt;code>1000000&lt;/code>):&lt;/p>
&lt;pre>&lt;code>$ simavr -m attiny85 -f 1000000 pipower.elf -g
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>-g&lt;/code> flag instructs &lt;code>simavr&lt;/code> to wait for a debugger connection before it starts to execute the code.&lt;/p>
&lt;h2 id="connect-with-gdb">Connect with gdb&lt;/h2>
&lt;p>Now that &lt;code>simavr&lt;/code> is running, we start up &lt;code>avr-gdb&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb
GNU gdb (GDB) 8.1
[...]
&lt;/code>&lt;/pre>
&lt;p>Load our binary:&lt;/p>
&lt;pre>&lt;code>(gdb) file pipower.elf
Reading symbols from pipower.elf...done.
&lt;/code>&lt;/pre>
&lt;p>Attach to the simulator (by default, &lt;code>simavr&lt;/code> listens on port &lt;code>1234&lt;/code>):&lt;/p>
&lt;pre>&lt;code>(gdb) target remote :1234
Remote debugging using :1234
0x00000000 in __vectors ()
&lt;/code>&lt;/pre>
&lt;p>And load the code into the simulator:&lt;/p>
&lt;pre>&lt;code>(gdb) load
Loading section .text, size 0xa42 lma 0x0
Loading section .data, size 0x6 lma 0xa42
Start address 0x0, load size 2632
Transfer rate: 2570 KB/sec, 175 bytes/write.
&lt;/code>&lt;/pre>
&lt;h2 id="run-the-code">Run the code&lt;/h2>
&lt;p>At this point, our &lt;code>main()&lt;/code> function has not started executing. Before we start the code, let&amp;rsquo;s set a breakpoint in the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L94">loop()&lt;/a> function:&lt;/p>
&lt;pre>&lt;code>(gdb) b loop
Breakpoint 1 at 0xaa: file pipower.c, line 98.
&lt;/code>&lt;/pre>
&lt;p>With this in place, when we start executing our code via the &lt;code>continue&lt;/code> command&amp;hellip;&lt;/p>
&lt;pre>&lt;code>(gdb) c
Continuing.
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;execution will stop as soon as it reaches the top of the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>Breakpoint 1, loop () at pipower.c:98
98 now = millis();
&lt;/code>&lt;/pre>
&lt;p>While debugging this code, I find it helpful to have the current state of the attiny85 pins displayed whenever we hit a breakpoint, as well as the current value of the &lt;code>state&lt;/code> variable. The following commands will display the current state and the binary contents of the &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> registers:&lt;/p>
&lt;pre>&lt;code>(gdb) display state
(gdb) display /t PORTB
(gdb) display /t PINB
&lt;/code>&lt;/pre>
&lt;p>Pin assignments used in this project as as follows:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Pin&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>I/O&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>&lt;code>POWER&lt;/code>&lt;/td>
&lt;td>I&lt;/td>
&lt;td>Connected to active-low power button&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>&lt;code>USB&lt;/code>&lt;/td>
&lt;td>I&lt;/td>
&lt;td>USB signal from powerboost&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>&lt;code>EN&lt;/code>&lt;/td>
&lt;td>O&lt;/td>
&lt;td>EN signal to powerboost (turns on power)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>&lt;code>SHUTDOWN&lt;/code>&lt;/td>
&lt;td>O&lt;/td>
&lt;td>Signal to Pi requesting shutdown&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>&lt;code>BOOT&lt;/code>&lt;/td>
&lt;td>I&lt;/td>
&lt;td>Signal from Pi that it has booted&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>We can see the initial value of everything by running the &lt;code>display&lt;/code> command without any arguments:&lt;/p>
&lt;pre>&lt;code>(gdb) display
1: state = STATE_START
2: /t PORTB = 10001
3: /t PINB = 10001
&lt;/code>&lt;/pre>
&lt;p>Since this is the first iteration of the loop, we&amp;rsquo;re in state &lt;code>STATE_START&lt;/code>. Looking at &lt;code>PINB&lt;/code>, we can see that the &lt;code>USB&lt;/code> signal (pin 1) is low, indicating that external power is not connected.&lt;/p>
&lt;p>Let&amp;rsquo;s run the loop for a few iterations:&lt;/p>
&lt;pre>&lt;code>(gdb) c 10
Will ignore next 9 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10001
(gdb)
&lt;/code>&lt;/pre>
&lt;p>Since there was no external power available (&lt;code>PIN_USB&lt;/code> is low), the code has entered the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L232">STATE_IDLE2&lt;/a> state, as expected. Let&amp;rsquo;s see what happens when power becomes available. We start by setting &lt;code>PIN_USB&lt;/code> high:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_USB
&lt;/code>&lt;/pre>
&lt;p>And then run the loop a few times:&lt;/p>
&lt;pre>&lt;code>(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
&lt;/code>&lt;/pre>
&lt;p>The code has entered &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L163">STATE_BOOTWAIT1&lt;/a>, which means it is waiting for an attached Raspberry Pi to set &lt;code>PIN_BOOT&lt;/code> low. You can also see the &lt;code>PIN_EN&lt;/code> has been set high, which instructs the &lt;a href="https://www.adafruit.com/product/2465">power supply&lt;/a> to provide power to the Pi.&lt;/p>
&lt;p>In practice, an attached Raspberry Pi would set &lt;code>PIN_BOOT&lt;/code> high to signal that it had successfully booted. Let&amp;rsquo;s simulate that here and run the loop for a few more iterations:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_BOOT)
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
&lt;/code>&lt;/pre>
&lt;p>This brings us to the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L172">STATE_BOOT&lt;/a> state, which means that our Pi has successfully booted. At this point, a button press should trigger the shutdown sequence. Let&amp;rsquo;s see if that actually works! We will simulate a button press by first setting &lt;code>PIN_POWER&lt;/code> low, running the loop a few times, and then setting it high:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
(gdb) c 100
[...]
(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_POWER
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
&lt;/code>&lt;/pre>
&lt;p>The code recognized and responded to the button press, and is now in state &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L188">STATE_SHUTDOWN1&lt;/a>, waiting for the Pi to set &lt;code>PIN_BOOT&lt;/code> high. We can raise &lt;code>PIN_BOOT&lt;/code>:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_BOOT
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_POWEROFF1
2: /t PORTB = 10101
3: /t PINB = 10111
&lt;/code>&lt;/pre>
&lt;p>This brings us to &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L203">STATE_POWEROFF1&lt;/a>, during which the controller will wait some amount of time before cutting power to the Pi. Our debug build has reduced this timer to 1 second, but if you don&amp;rsquo;t have time for that we can simply run until the next state transition like this:&lt;/p>
&lt;pre>&lt;code>(gdb) disable 1
(gdb) tb loop if state != STATE_POWEROFF1
Note: breakpoint 1 (disabled) also set at pc 0xaa.
Temporary breakpoint 2 at 0xaa: file ../pipower.c, line 98.
(gdb) c
Continuing.
Temporary breakpoint 2, loop () at ../pipower.c:98
115 now = millis();
1: state = STATE_POWEROFF2
(gdb) enable1
(gdb)
&lt;/code>&lt;/pre>
&lt;p>This works by disabling the unqualified breakpoint at the top of &lt;code>loop()&lt;/code> and creating a new temporary breakpoint (meaning it will be removed once it triggers) that will only trigger when the global &lt;code>state&lt;/code> value has changed.&lt;/p>
&lt;p>From &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L213">STATE_POWEROFF2&lt;/a>, Pipower will enter the various &lt;code>IDLE*&lt;/code> stages, during which it enters a very low power sleep mode.&lt;/p>
&lt;hr>
&lt;p>That&amp;rsquo;s it for the walk-through! Hopefully that has given you some idea of how you can use &lt;code>simavr&lt;/code> and a debugger to test your AVR code without having to flash it to a device first.&lt;/p></content></item><item><title>Debugging attiny85 code, part 2: Automating GDB with scripts</title><link>https://blog.oddbit.com/posts/debugging-attiny-code-pt-2/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/posts/debugging-attiny-code-pt-2/</guid><description>This is the second of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running.</description><content>&lt;p>This is the second of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In &lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-1/">the first post&lt;/a> on this topic, we looked at how one can use &lt;code>gdb&lt;/code> and &lt;a href="https://github.com/buserror/simavr">simavr&lt;/a> to debug your attiny85 (or other AVR code) without flashing it to a device. In this post, I would like to extend that by looking at how we can automate some aspects of the debugging process.&lt;/p>
&lt;h2 id="sending-commands-to-gdb">Sending commands to gdb&lt;/h2>
&lt;p>In the previous post, we were entering commands into &lt;code>gdb&lt;/code> manually. It is also possible to provide &lt;code>gdb&lt;/code> with a script of commands to execute. Let&amp;rsquo;s assume we have a file that contains the following commands:&lt;/p>
&lt;pre>&lt;code>file pipower.elf
target remote :1234
load
&lt;/code>&lt;/pre>
&lt;p>There are a few different mechanisms available for passing these commands to &lt;code>gdb&lt;/code>. Naively we can simply redirect &lt;code>stdin&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb &amp;lt; commands.gdb
GNU gdb (GDB) 8.1
[...]
(gdb) Reading symbols from pipower.elf...done.
(gdb) Remote debugging using :1234
0x00000000 in __vectors ()
(gdb) Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb) quit
A debugging session is active.
Inferior 1 [Remote target] will be detached.
Quit anyway? (y or n) [answered Y; input not from terminal]
Detaching from program: /home/lars/projects/pipower/sim/pipower.elf, Remote target
&lt;/code>&lt;/pre>
&lt;p>This will work fine in situations in which you expect &lt;code>gdb&lt;/code> to run with no user interaction, but in this particular example, that makes our command file useless: while &lt;code>gdb&lt;/code> does connect to &lt;code>simavr&lt;/code>, it then exits immediately. This is where the &lt;code>--command&lt;/code> (or &lt;code>-x&lt;/code>) options comes in handy: that will read commands from a file and then return to the &lt;code>(gdb)&lt;/code> prompt:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb -x commands.gdb
GNU gdb (GDB) 8.1
[...]
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb)
&lt;/code>&lt;/pre>
&lt;p>This allows us to preload our debugging session with commands and then continue with an interactive session. You can achieve something similar using the &lt;code>source&lt;/code> command in &lt;code>gdb&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb
GNU gdb (GDB) 8.1
[...]
(gdb) source commands.gdb
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 431 KB/sec, 31 bytes/write.
(gdb)
&lt;/code>&lt;/pre>
&lt;h2 id="conditional-and-temporary-breakpoints">Conditional and temporary breakpoints&lt;/h2>
&lt;p>There are several different ways to set breakpoints in &lt;code>gdb&lt;/code>. The simplest is the &lt;code>b&lt;/code> command, which sets a breakpoint at the given location. This simple breakpoint will trigger whenever execution reaches the given line of code. We can influence this behavior by setting a breakpoint condition, such as:&lt;/p>
&lt;pre>&lt;code>b loop if state == STATE_POWEROFF2
&lt;/code>&lt;/pre>
&lt;p>This breakpoint will only trigger if the expression (&lt;code>state == STATE_POWEROFF2&lt;/code>) evaluates to true.&lt;/p>
&lt;p>Sometimes, we don&amp;rsquo;t want a persistent breakpoint: we want the code to stop once at a given point, and then continue executing afterwards without stopping again at the same place. We can accomplish this by setting a temporary breakpoint using the &lt;code>tb&lt;/code> command. If we were to write the previous example like this&amp;hellip;&lt;/p>
&lt;pre>&lt;code>tb loop if state == STATE_POWEROFF2
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;then the code would stop &lt;em>once&lt;/em> at the given breakpoint, but subsequently iterations of the loop would continue merrily on their way.&lt;/p>
&lt;h2 id="defining-new-commands">Defining new commands&lt;/h2>
&lt;p>The &lt;code>gdb&lt;/code> scripting language permits us to create new commands with the &lt;code>define&lt;/code> command. In the previous post, I simulated the passage of time by iterating through the main loop using a command such as &lt;code>c 100&lt;/code>. This works, but isn&amp;rsquo;t particularly accurate and may make it difficult if one wants to run for a specific amount of time (for example, to run out a timer). We can define a new &lt;code>wait_for&lt;/code> command that will let us wait for a given number of milliseconds:&lt;/p>
&lt;pre>&lt;code># wait for &amp;lt;n&amp;gt; milliseconds
define wait_for
disable 1
set $start_time = now
tb loop if now == $start_time + $arg0
c
enable 1
end
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>disable 1&lt;/code> at the beginning is disabling breakpoint 1, which we assume is the breakpoint created by running &lt;code>b loop&lt;/code> as in the &lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-1/">previous post&lt;/a>. We re-enable the breakpoint at the end of the definition.&lt;/p>
&lt;p>This takes advantage of the fact that the code in &lt;code>pipower.c&lt;/code> is explicitly updating a variable call &lt;code>now&lt;/code> with the output of the &lt;code>millis()&lt;/code> command, which counts milliseconds since the microprocessor started. We can store the current value of that variable in a &lt;code>gdb&lt;/code> variable by using the &lt;code>set&lt;/code> command:&lt;/p>
&lt;pre>&lt;code>set $start_time = now
&lt;/code>&lt;/pre>
&lt;p>This allows us to create a temporary breakpoint with a break condition that makes use of that value:&lt;/p>
&lt;pre>&lt;code>tb loop if now == $start_time + $arg0
&lt;/code>&lt;/pre>
&lt;p>This breakpoint will activate when the global &lt;code>now&lt;/code> variable is equal to the value we saved in &lt;code>$start_time&lt;/code> + whatever was passed as an argument to the &lt;code>wait_for&lt;/code> command.&lt;/p>
&lt;p>Since commands can call other commands, we can use the new &lt;code>wait_for&lt;/code> command to create a new command that simulates a button press. For our purposes, a &amp;ldquo;button press&amp;rdquo; means that &lt;code>PIN_POWER&lt;/code> goes low for 100ms and then goes high. We can simulate that like this:&lt;/p>
&lt;pre>&lt;code> define short_press
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
wait_for 100
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_POWER
c
end
&lt;/code>&lt;/pre>
&lt;p>Recall that &lt;code>c&lt;/code> means &lt;code>continue&lt;/code>, which will cause the code to continue running until it hits a breakpoint.&lt;/p>
&lt;h2 id="automated-testing-the-script">Automated testing: the script&lt;/h2>
&lt;p>Using everything discussed above, we can put together something like the &lt;a href="https://github.com/larsks/pipower/tree/master/sim/simulate.gdb">simulate.gdb&lt;/a> script included in the &lt;code>sim&lt;/code> directory of the Pipower project.&lt;/p>
&lt;p>We start by disabling pagination. This prevent &lt;code>gdb&lt;/code> from stopping and asking us to &amp;ldquo;press return to continue&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>set pagination off
&lt;/code>&lt;/pre>
&lt;p>We load our binary and connect to the simulator:&lt;/p>
&lt;pre>&lt;code>file pipower.elf
target remote :1234
load
&lt;/code>&lt;/pre>
&lt;p>Next, we define a few helper functions to avoid repetitive code in the rest of the script:&lt;/p>
&lt;pre>&lt;code>##
## Helper functions
##
# wait for &amp;lt;n&amp;gt; milliseconds
define wait_for
disable 1
set $start_time = now
tb loop if now == $start_time + $arg0
c
enable 1
end
# simulate a short press of the power button
define short_press
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
wait_for 100
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_POWER
c
end
# log a message
define log
printf &amp;quot;\n* %s\n&amp;quot;, $arg0
end
# run until we reach the given state
define run_until_state
disable 1
tb loop if $arg0 == state
c
enable 1
end
&lt;/code>&lt;/pre>
&lt;p>Prior to running the code, we a breakpoint on the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>##
## Execution starts here
##
# set an initial breakpoint at the start of loop() and advance the program
# to that point
b loop
&lt;/code>&lt;/pre>
&lt;p>And then start things running. This will stop at the top of &lt;code>loop()&lt;/code>:&lt;/p>
&lt;pre>&lt;code>c
&lt;/code>&lt;/pre>
&lt;p>In order to see how things are progressing as the script runs, let&amp;rsquo;s arrange to display the current value of the global &lt;code>state&lt;/code> variable as well as the &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> registers every time we hit a breakpoint:&lt;/p>
&lt;pre>&lt;code># set up some information to display at each breakpoint
display state
display /t PORTB
display /t PINB
display
&lt;/code>&lt;/pre>
&lt;p>Now that our displays are setup, let&amp;rsquo;s run the code for a bit and then set &lt;code>PIN_USB&lt;/code> high (this would indicate that external power is available to our device):&lt;/p>
&lt;pre>&lt;code># let the code advance for 100ms
wait_for 100
# enable external power
log &amp;quot;setting PIN_USB&amp;quot;
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_USB
&lt;/code>&lt;/pre>
&lt;p>We&amp;rsquo;ll use the &lt;code>run_until_state&lt;/code> command that we defined earlier in the file to execute until we reach the &lt;code>STATE_BOOTWAIT1&lt;/code> state:&lt;/p>
&lt;pre>&lt;code>run_until_state STATE_BOOTWAIT1
wait_for 100
&lt;/code>&lt;/pre>
&lt;p>At this point, the code expects an attached Raspberry Pi to assert the &lt;code>BOOT&lt;/code> signal by bringing &lt;code>PIN_BOOT&lt;/code> low:&lt;/p>
&lt;pre>&lt;code># assert BOOT
log &amp;quot;resetting PIN_BOOT&amp;quot;
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_BOOT)
run_until_state STATE_BOOT
&lt;/code>&lt;/pre>
&lt;p>Once the Pi has booted successfully and provided the &lt;code>BOOT&lt;/code> signal to our code, we enter the &lt;code>STATE_BOOT&lt;/code> state. Let&amp;rsquo;s run in this state for a second&amp;hellip;&lt;/p>
&lt;pre>&lt;code>##
## ...the pi has booted...
##
wait_for 1000
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;and then simulate a press of the power button:&lt;/p>
&lt;pre>&lt;code># request a shutdown by pressing the power button
log &amp;quot;pressing power button&amp;quot;
short_press
&lt;/code>&lt;/pre>
&lt;p>Our code sets &lt;code>PIN_SHUTDOWN&lt;/code> high, which would signal to an attached Pi that it should begin the shutdown process. The code enters the &lt;code>STATE_SHUTDOWN1&lt;/code> state in which it waits for the Pi to signal successful shutdown by de-asserting &lt;code>BOOT&lt;/code> by bringing &lt;code>PIN_BOOT&lt;/code> high:&lt;/p>
&lt;pre>&lt;code>run_until_state STATE_SHUTDOWN1
# de-assert BOOT
wait_for 100
log &amp;quot;setting PIN_BOOT&amp;quot;
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_BOOT
&lt;/code>&lt;/pre>
&lt;p>Once we receive the successful shutdown signal, the code enters the poweroff phase, during which it will wait &lt;code>TIMER_POWEROFF&lt;/code> milliseconds before cutting the power. Let&amp;rsquo;s walk through the poweroff state transitions:&lt;/p>
&lt;pre>&lt;code># step through state transitions until we reach
# STATE_IDLE2
run_until_state STATE_POWEROFF0
run_until_state STATE_POWEROFF1
run_until_state STATE_POWEROFF2
log &amp;quot;entering idle mode&amp;quot;
run_until_state STATE_IDLE0
run_until_state STATE_IDLE1
run_until_state STATE_IDLE2
wait_for 100
&lt;/code>&lt;/pre>
&lt;p>And finally force the code to exit:&lt;/p>
&lt;pre>&lt;code>log &amp;quot;setting quit flag&amp;quot;
set state=STATE_QUIT
finish
disconnect
quit
&lt;/code>&lt;/pre>
&lt;h2 id="automated-testing-the-output">Automated testing: the output&lt;/h2>
&lt;p>Running that script produces the following output, which lets us see the state transitions and pin values as the code is running:&lt;/p>
&lt;pre>&lt;code>0x00000000 in __vectors ()
Loading section .text, size 0xa74 lma 0x0
Loading section .data, size 0x6 lma 0xa74
Start address 0x0, load size 2682
Transfer rate: 873 KB/sec, 31 bytes/write.
Breakpoint 1 at 0xb0: file ../pipower.c, line 116.
Breakpoint 1, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_START
2: /t PORTB = 10001
3: /t PINB = 10001
Temporary breakpoint 2 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 2, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10001
* setting PIN_USB
Temporary breakpoint 3 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 3, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 4 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 4, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
* resetting PIN_BOOT
Temporary breakpoint 5 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 5, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 6 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 6, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
* pressing power button
Temporary breakpoint 7 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 7, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 110
Breakpoint 1, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 8 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 8, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
Temporary breakpoint 9 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 9, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
* setting PIN_BOOT
Temporary breakpoint 10 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 10, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF0
2: /t PORTB = 11101
3: /t PINB = 11111
Temporary breakpoint 11 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 11, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 12 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 12, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF2
2: /t PORTB = 10101
3: /t PINB = 10111
* entering idle mode
Temporary breakpoint 13 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 13, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE0
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 14 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 14, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE1
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 15 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 15, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10011
* setting quit flag
main () at ../pipower.c:280
280 while (state != STATE_QUIT) {
1: state = STATE_QUIT
2: /t PORTB = 10001
3: /t PINB = 10011
&lt;/code>&lt;/pre></content></item><item><title>Debugging attiny85 code, part 3: Tracing with simavr</title><link>https://blog.oddbit.com/posts/debugging-attiny-code-pt-3/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/posts/debugging-attiny-code-pt-3/</guid><description>This is the third of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running.</description><content>
&lt;figure class="left" >
&lt;img src="pipower_trace.png" />
&lt;/figure>
&lt;p>This is the third of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In the &lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-2/">previous post&lt;/a> we looked at we can automate &lt;code>gdb&lt;/code> using scripts. In this post, we&amp;rsquo;ll combine that with the tracing facilities offered by &lt;code>simavr&lt;/code> in order to generate traces for pin values and state transitions while the code is running.&lt;/p>
&lt;h2 id="preparing-your-code">Preparing your code&lt;/h2>
&lt;p>We need to embed some metadata in our code that provides &lt;code>simavr&lt;/code> with information about what data we want to collect. We do this by adding some special code that will get embedded in the &lt;code>.mmcu&lt;/code> section of the resulting ELF binary. You can see an example of this in &lt;a href="https://github.com/larsks/pipower/blob/master/sim/simavr.c">sim/simavr.c&lt;/a> in the Pipower project:&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;simavr/avr/avr_mcu_section.h&amp;gt;
#include &amp;quot;pins.h&amp;quot;
extern uint8_t state;
/** Trace data to collect.
*
* We collect each bit of PORTB (inputs and outputs) separately. We also keep
* track of the global state variable.
*/
const struct avr_mmcu_vcd_trace_t _mytrace[] _MMCU_ = {
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_POWER&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_POWER), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_USB&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_USB), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_EN&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_EN), .what = (void*)&amp;amp;PORTB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_SHUTDOWN&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_SHUTDOWN), .what = (void*)&amp;amp;PORTB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_BOOT&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_BOOT), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;STATE&amp;quot;), .what = (void*)&amp;amp;state, },
};
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>_mytrace&lt;/code> variable (the name is unimportant) is an array of &lt;code>struct avr_mmcu_vcd_trace_t&lt;/code> records (the &lt;code>_MMCU_&lt;/code> flag sets an attribute that will embed this data in the appropriate section of the ELF binary). Each record has the following fields:&lt;/p>
&lt;ul>
&lt;li>&lt;code>AVR_MCU_VCD_SYMBOL(&amp;quot;...&amp;quot;)&lt;/code> &amp;ndash; this sets the name of a data series to collect.&lt;/li>
&lt;li>&lt;code>.mask&lt;/code> (optional) &amp;ndash; use this if you only want to collect certain bits. In this example, I am masking out all but a single bit for each pin. I&amp;rsquo;m not using a mask for &lt;code>state&lt;/code> because I want the actual integer value in that case.&lt;/li>
&lt;li>&lt;code>.what&lt;/code> &amp;ndash; this is the variable to collect. It can be pretty much anything that is in scope. Here, &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> are the attiny85 input/output registers, and &lt;code>state&lt;/code> is a global variable from &lt;code>pipower.c&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>You can build a version of the pipower code that includes this metadata by running, in the &lt;code>sim/&lt;/code> directory:&lt;/p>
&lt;pre>&lt;code>make TRACE=1
&lt;/code>&lt;/pre>
&lt;p>You can see the new &lt;code>.mmcu&lt;/code> section of you inspect the section headers of &lt;code>pipower.elf&lt;/code> using, e.g., &lt;code>objdump&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ objdump pipower.elf -h
pipower.elf: file format elf32-little
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 00000a74 00000000 00000000 00000094 2**1
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .mmcu 000000de 00000a74 00000a74 00000b08 2**0
CONTENTS, ALLOC, LOAD, READONLY, DATA
[...]
&lt;/code>&lt;/pre>
&lt;h2 id="gathering-trace-data">Gathering trace data&lt;/h2>
&lt;p>To gather the trace data with &lt;code>simavr&lt;/code>, we simply repeat the steps from the &lt;a href="https://blog.oddbit.com/posts/debugging-attiny-code-pt-2/">previous post&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>Start &lt;code>simavr&lt;/code>&lt;/li>
&lt;li>Run our automated testing script (&lt;code>simulate.gdb&lt;/code>)&lt;/li>
&lt;li>Stop &lt;code>simavr&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>At the end of this process, we will find a new file in our current directory, &lt;code>gtkwave_trace.vcd&lt;/code>. This is a &lt;a href="https://en.wikipedia.org/wiki/Value_change_dump">value change dump&lt;/a> file, which is a standard format for representing digital signals over time.&lt;/p>
&lt;h2 id="visualizing-the-trace-data">Visualizing the trace data&lt;/h2>
&lt;p>We can view the &lt;code>.vcd&lt;/code> file using &lt;a href="http://gtkwave.sourceforge.net/">gtkwave&lt;/a>. From the command line, you can run:&lt;/p>
&lt;pre>&lt;code>gtkwave gtkwave_trace.vcd
&lt;/code>&lt;/pre>
&lt;p>This will bring up the main &lt;code>gtkwave&lt;/code> window, which look like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-1.png" />
&lt;/figure>
&lt;p>Select &lt;code>logic&lt;/code> in the SST (&amp;ldquo;Signal Search Tree&amp;rdquo;) pane. This will display the available signals in the next pane down. Select all the signals (click on the top one, then shift-click on the last one) and select &amp;ldquo;Append&amp;rdquo;. You should end up with a display that looks like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-2.png" />
&lt;/figure>
&lt;p>The graph is displaying our collected signal data, but the initial time scale isn&amp;rsquo;t particularly useful. Select &amp;ldquo;Time -&amp;gt; Zoom -&amp;gt; Zoom Best Fit&amp;rdquo;; you should end up with something that looks like:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-3.png" />
&lt;/figure>
&lt;p>(Note that any time you resize the window you&amp;rsquo;ll need to manually adjust the zoom level. You can use the menu item, or just press &lt;code>CTRL&lt;/code>-&lt;code>ALT&lt;/code>-&lt;code>F&lt;/code>.)&lt;/p>
&lt;p>You can now see a graph of how the various pins changed over the runtime of the program. This is a useful way to verify that the code is behaving as expected. In this case, I think the section just past the 1 second mark is interesting; you can see the power button press, followed by &lt;code>PIN_SHUTDOWN&lt;/code> going high, then &lt;code>PIN_BOOT&lt;/code> going high, and finally &lt;code>PIN_EN&lt;/code> disabling power output after the 1 second timer expiry.&lt;/p>
&lt;p>You&amp;rsquo;ll note that the &lt;code>state&lt;/code> information is displayed numerically, which isn&amp;rsquo;t particularly helpful. We can fix that by setting up a &amp;ldquo;Translate Filter File&amp;rdquo;. Right click on the &lt;code>STATE[7:0]&lt;/code> label in the &amp;ldquo;Signals&amp;rdquo; pane, then select &amp;ldquo;Data Format -&amp;gt; Translate Filter File -&amp;gt; Enable and Select&amp;rdquo;. In the &amp;ldquo;Select Signal Filter&amp;rdquo; window that pops up&amp;hellip;&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-4.png" />
&lt;/figure>
&lt;p>&amp;hellip;select &amp;ldquo;Add Filter to List&amp;rdquo;. Browse to the &lt;code>sim&lt;/code> directory of the &lt;code>pipower&lt;/code> project, and select &lt;code>state_filter.txt&lt;/code>. Now select that same file in the &amp;ldquo;Filter Select&amp;rdquo; list, then click OK. You should now see state names displayed in the graph:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-5.png" />
&lt;/figure>
&lt;hr>
&lt;p>That&amp;rsquo;s the end of this series of posts on debugging AVR code with &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code>. I hope you found it useful!&lt;/p></content></item></channel></rss>