<!doctype html><html lang=en><head><title>Docker :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/tags/docker/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Docker"><meta property="og:description" content><meta property="og:url" content="https://blog.oddbit.com/tags/docker/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/docker/rss.xml rel=alternate type=application/rss+xml title=blog.oddbit.com></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><h1>Posts for: #Docker</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2022-06-20-traefik-multiple-listeners/>Directing different ports to different containers with Traefik</a></h1><div class=post-meta><time class=post-date>2022-06-20</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/containers/>containers</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/traefik/>traefik</a>&nbsp;
</span><img src=/post/2022-06-20-traefik-multiple-listeners/cover.jpg class=post-cover alt="Directing different ports to different containers with Traefik" title="Cover Image"><div class=post-content><p>This post is mostly for myself: I find the <a href=https://traefik.io>Traefik</a> documentation hard to navigate, so having figured this out in response to <a href=https://stackoverflow.com/a/72694677/147356>a question on Stack Overflow</a>, I&rsquo;m putting it here to help it stick in my head.</p><p>The question asks essentially how to perform port-based routing of requests to containers, so that a request for <code>http://example.com</code> goes to one container while a request for <code>http://example.com:9090</code> goes to a different container.</p><h2 id=creating-entrypoints>Creating entrypoints</h2><p>A default Traefik configuration will already have a listener on port 80, but if we want to accept connections on port 9090 we need to create a new listener: what Traefik calls an <a href=https://doc.traefik.io/traefik/routing/entrypoints/>entrypoint</a>. We do this using the <code>--entrypoints.&lt;name>.address</code> option. For example, <code>--entrypoints.ep1.address=80</code> creates an entrypoint named <code>ep1</code> on port 80, while <code>--entrypoints.ep2.address=9090</code> creates an entrypoint named <code>ep2</code> on port 9090. Those names are important because we&rsquo;ll use them for mapping containers to the appropriate listener later on.</p></div><div><a class="read-more button inline" href=/post/2022-06-20-traefik-multiple-listeners/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2020-09-25-building-multi-architecture-im/>Building multi-architecture images with GitHub Actions</a></h1><div class=post-meta><time class=post-date>2020-09-25</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>At work we have a cluster of IBM Power 9 systems running OpenShift. The
problem with this environment is that nobody runs Power 9 on their desktop,
and Docker Hub only offers automatic build support for the x86
architecture. This means there&rsquo;s no convenient options for building Power 9
Docker images&mldr;or so I thought.</p><p>It turns out that <a href=https://github.com/docker>Docker</a> provides <a href=https://github.com/features/actions>GitHub actions</a> that make the process
of producing multi-architecture images quite simple.</p></div><div><a class="read-more button inline" href=/post/2020-09-25-building-multi-architecture-im/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-06-07-running-keystone-with-docker-c/>Running Keystone with Docker Compose</a></h1><div class=post-meta><time class=post-date>2019-06-07</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/keystone/>keystone</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker-compose/>docker-compose</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/tripleo/>tripleo</a>&nbsp;</span><div class=post-content><p>In this article, we will look at what is necessary to run OpenStack&rsquo;s <a href=https://docs.openstack.org/keystone/latest/>Keystone</a> service (and the requisite database server) in containers using <a href=https://docs.docker.com/compose/>Docker Compose</a>.</p><h2 id=running-mariadb>Running MariaDB</h2><p>The standard <a href=https://hub.docker.com/_/mariadb/>mariadb docker image</a> can be configured via a number of environment variables. It also benefits from persistent volume storage, since in most situations you don&rsquo;t want to lose your data when you remove a container. A simple <code>docker</code> command line for starting MariaDB might look something like:</p></div><div><a class="read-more button inline" href=/post/2019-06-07-running-keystone-with-docker-c/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-02-24-docker-build-learns-about-secr/>Docker build learns about secrets and ssh agent forwarding</a></h1><div class=post-meta><time class=post-date>2019-02-24</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/secrets/>secrets</a>&nbsp;</span><div class=post-content><p>A common problem for folks working with Docker is accessing resources which require authentication during the image build step. A particularly common use case is getting access to private git repositories using ssh key-based authentication. Until recently there hasn&rsquo;t been a great solution:</p><ul><li>you can embed secrets in your image, but now you can&rsquo;t share the image with anybody.</li><li>you can use build arguments, but this requires passing in an unenecrypted private key on the <code>docker build</code> command line, which is suboptimal for a number of reasons</li><li>you can perform all the steps requiring authentication at runtime, but this can needlessly complicate your container startup process.</li></ul><p>With Docker 18.09, there are some experimental features available that makes this much easier. You can read the official announcement <a href=https://docs.docker.com/develop/develop-images/build_enhancements/>here</a>, but I wanted to highlight the support for ssh agent forwarding and private keys.</p></div><div><a class="read-more button inline" href=/post/2019-02-24-docker-build-learns-about-secr/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2018-03-12-using-docker-macvlan-networks/>Using Docker macvlan networks</a></h1><div class=post-meta><time class=post-date>2018-03-12</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>A question that crops up regularly on <a href=https://docs.docker.com/opensource/ways/#docker-users>#docker</a> is &ldquo;How do I attach
a container directly to my local network?&rdquo; One possible answer to that
question is the <a href=https://docs.docker.com/network/macvlan/>macvlan</a> network type, which lets you create
&ldquo;clones&rdquo; of a physical interface on your host and use that to attach
containers directly to your local network. For the most part it works
great, but it does come with some minor caveats and limitations. I
would like to explore those here.</p></div><div><a class="read-more button inline" href=/post/2018-03-12-using-docker-macvlan-networks/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-10-13-ansible-20-the-docker-connecti/>Ansible 2.0: The Docker connection driver</a></h1><div class=post-meta><time class=post-date>2015-10-13</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/ansible/>ansible</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ansible_20_series/>ansible_20_series</a>&nbsp;</span><div class=post-content><p>As the release of <a href=http://ansible.com/>Ansible</a> 2.0 draws closer, I&rsquo;d like to take a
look at some of the new features that are coming down the pipe. In
this post, we&rsquo;ll look at the <code>docker</code> connection driver.</p><p>A &ldquo;connection driver&rdquo; is the mechanism by which Ansible connects to
your target hosts. These days it uses <code>ssh</code> by default (which relies
on the OpenSSH command line client for connectivity), and it also
offers the <a href=http://www.paramiko.org/>Paramiko</a> library as an alternative ssh implementation
(this was in fact the default driver in earlier versions of Ansible).
Alternative drivers offered by recent versions of ansible included the
<code>winrm</code> driver, for accessing Windows hosts, the <code>fireball</code> driver, a
(deprecated) driver that used <a href=http://zeromq.org/>0mq</a> for communication, and <code>jail</code>, a
driver for connecting to FreeBSD jails.</p></div><div><a class="read-more button inline" href=/post/2015-10-13-ansible-20-the-docker-connecti/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-10-09-running-ntp-in-a-container/>Running NTP in a Container</a></h1><div class=post-meta><time class=post-date>2015-10-09</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/atomic/>atomic</a>&nbsp;</span><div class=post-content><p>Someone asked on IRC about running ntpd in a container on <a href=http://www.projectatomic.io/>Atomic</a>,
so I&rsquo;ve put together a small example. We&rsquo;ll start with a very simple
<code>Dockerfile</code>:</p><pre><code>FROM alpine
RUN apk update
RUN apk add openntpd
ENTRYPOINT [&quot;ntpd&quot;]
</code></pre><p>I&rsquo;m using the <code>alpine</code> image as my starting point because it&rsquo;s very
small, which makes this whole process go a little faster. I&rsquo;m
installing the <a href=http://www.openntpd.org/>openntpd</a> package, which provides the <code>ntpd</code> binary.</p><p>By setting an <code>ENTRYPOINT</code> here, the <code>ntpd</code> binary will be started by
default, and any arguments passed to <code>docker run</code> after the image name
will be passed to <code>ntpd</code>.</p></div><div><a class="read-more button inline" href=/post/2015-10-09-running-ntp-in-a-container/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-06-19-heatkubernetes-demo-with-autos/>Heat-kubernetes Demo with Autoscaling</a></h1><div class=post-meta><time class=post-date>2015-06-19</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/heat/>heat</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/atomic/>atomic</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>Next week is the <a href=http://www.redhat.com/summit/>Red Hat Summit</a> in Boston, and I&rsquo;ll be taking part
in a <a href=http://www.projectatomic.io/>Project Atomic</a> presentation in which I will discuss various
(well, two) options for deploying Atomic into an OpenStack
environment, focusing on my <a href=https://github.com/projectatomic/heat-kubernetes/>heat-kubernetes</a> templates.</p><p>As part of that presentation, I&rsquo;ve put together a short demonstration video:</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/tS5X0qi04ZU?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>This shows off the autoscaling behavior available with recent versions
of these templates (and also serves as a very brief introduction to
working with Kubernetes).</p></div><div><a class="read-more button inline" href=/post/2015-06-19-heatkubernetes-demo-with-autos/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-04-27-suggestions-for-the-docker-mai/>Suggestions for the Docker MAINTAINER directive</a></h1><div class=post-meta><time class=post-date>2015-04-27</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>Because nobody asked for it, this is my opinion on the use of the
<code>MAINTAINER</code> directive in your Dockerfiles.</p><p>The <a href=https://docs.docker.com/reference/builder/#maintainer>documentation</a> says simply:</p><pre><code>The MAINTAINER instruction allows you to set the Author field of the generated images.
</code></pre><p>Many people end up putting the name and email address of an actual
person here. I think this is ultimately a bad idea, and does a
disservice both to members of a project that produce Docker images and
to people consuming those images.</p></div><div><a class="read-more button inline" href=/post/2015-04-27-suggestions-for-the-docker-mai/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-03-08-converting-hexadecimal-ip-addr/>Converting hexadecimal ip addresses to dotted quads with Bash</a></h1><div class=post-meta><time class=post-date>2015-03-08</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/bash/>bash</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>This is another post that is primarily for my own benefit for the next
time I forget how to do this.</p><p>I wanted to read routing information directly from <code>/proc/net/route</code>
using <code>bash</code>, because you never know what may or may not be available
in the minimal environment of a Docker container (for example, the
<code>iproute</code> package is not installed by default in the Fedora Docker
images). The contents of <code>/proc/net/route</code> looks something like:</p></div><div><a class="read-more button inline" href=/post/2015-03-08-converting-hexadecimal-ip-addr/>[read more]</a></div></article><div class=pagination><div class=pagination__buttons><a href=/tags/docker/page/2/ class="button inline next">[<span class=button__text>Older posts</span>] ></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>