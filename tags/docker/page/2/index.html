<!doctype html><html lang=en><head><title>Docker :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/tags/docker/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Docker"><meta property="og:description" content><meta property="og:url" content="https://blog.oddbit.com/tags/docker/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/docker/rss.xml rel=alternate type=application/rss+xml title=blog.oddbit.com></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><h1>Posts for: #Docker</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-02-13-unpacking-docker-images/>Unpacking Docker images with Undocker</a></h1><div class=post-meta><time class=post-date>2015-02-13</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>In some ways, the most exciting thing about <a href=http://docker.com/>Docker</a> isn&rsquo;t the ability
to start containers. That&rsquo;s been around for a long time in various
forms, such as <a href=https://linuxcontainers.org/>LXC</a> or <a href=http://openvz.org/Main_Page>OpenVZ</a>. What Docker brought to the
party was a convenient method of building and distributing the
filesystems necessary for running containers. Suddenly, it was easy
to build a containerized service <em>and</em> to share it with other people.</p><p>I was taking a closer at the <a href=http://www.freedesktop.org/software/systemd/man/systemd-nspawn.html>systemd-nspawn</a> command, which it
seems has been developing it&rsquo;s own set of container-related
superpowers recently, including a number of options for setting up the
network environment of a container. Like Docker, <code>systemd-nspawn</code>
needs a filesystem on which to operate, but <em>unlike</em> Docker, there is
no convenient distribution mechanism and no ecosystem of existing
images. In fact, the official documentation seems to assume that
you&rsquo;ll be building your own from scratch. Ain&rsquo;t nobody got time for
that&mldr;</p></div><div><a class="read-more button inline" href=/post/2015-02-13-unpacking-docker-images/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-02-11-installing-novadocker-with-dev/>Installing nova-docker with devstack</a></h1><div class=post-meta><time class=post-date>2015-02-11</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/devstack/>devstack</a>&nbsp;</span><div class=post-content><p>This is a long-form response to <a href=https://ask.openstack.org/en/question/60679/installing-docker-on-openstack-with-ubuntu/>this question</a>, and describes
how to get the <a href=http://github.com/stackforge/nova-docker/>nova-docker</a> driver up running with <a href=http://devstack.org/>devstack</a>
under Ubuntu 14.04 (Trusty). I wrote a <a href=https://blog.oddbit.com/post/2015-02-06-installing-nova-docker-on-fedo/>similar post</a> for Fedora
21, although that one was using the <a href=http://openstack.redhat.com/>RDO</a> Juno packages, while this
one is using <a href=http://devstack.org/>devstack</a> and the upstream sources.</p><h2 id=getting-started>Getting started</h2><p>We&rsquo;ll be using the <a href=https://cloud-images.ubuntu.com/trusty/current/>Ubuntu 14.04 cloud image</a> (because my test
environment runs on <a href=http://www.openstack.org/>OpenStack</a>).</p><p>First, let&rsquo;s install a few prerequisites:</p><pre><code>$ sudo apt-get update
$ sudo apt-get -y install git git-review python-pip python-dev
</code></pre><p>And generally make sure things are up-to-date:</p></div><div><a class="read-more button inline" href=/post/2015-02-11-installing-novadocker-with-dev/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-02-10-external-networking-for-kubern/>External networking for Kubernetes services</a></h1><div class=post-meta><time class=post-date>2015-02-10</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;</span><div class=post-content><p>I have recently started running some &ldquo;real&rdquo; services (that is,
&ldquo;services being consumed by someone other than myself&rdquo;) on top of
Kubernetes (running on bare metal), which means I suddenly had to
confront the question of how to provide external access to Kubernetes
hosted services. Kubernetes provides two solutions to this problem,
neither of which is particularly attractive out of the box:</p><ol><li><p>There is a field <code>createExternalLoadBalancer</code> that can be set in a
service description. This is meant to integrate with load
balancers provided by your local cloud environment, but at the
moment there is only support for this when running under <a href=https://cloud.google.com/compute/>GCE</a>.</p></div><div><a class="read-more button inline" href=/post/2015-02-10-external-networking-for-kubern/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-02-06-installing-nova-docker-on-fedo/>Installing nova-docker on Fedora 21/RDO Juno</a></h1><div class=post-meta><time class=post-date>2015-02-06</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/nova/>nova</a>&nbsp;</span><div class=post-content><p>This post comes about indirectly by a request on IRC in <code>#rdo</code> for help getting <a href=https://github.com/stackforge/nova-docker>nova-docker</a> installed on Fedora 21. I ran through the process from start to finish and decided to write everything down for posterity.</p><h2 id=getting-started>Getting started</h2><p>I started with the <a href=https://getfedora.org/en/cloud/download/>Fedora 21 Cloud Image</a>, because I&rsquo;m
installing onto OpenStack and the cloud images include
some features that are useful in this environment.</p><p>We&rsquo;ll be using OpenStack packages from the <a href=https://repos.fedorapeople.org/repos/openstack/openstack-juno/>RDO Juno</a> repository.
Because there is often some skew between the RDO packages and the
current Fedora selinux policy, we&rsquo;re going to start by putting SELinux
into permissive mode (sorry, Dan):</p></div><div><a class="read-more button inline" href=/post/2015-02-06-installing-nova-docker-on-fedo/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-02-05-creating-minimal-docker-images/>Creating minimal Docker images from dynamically linked ELF binaries</a></h1><div class=post-meta><time class=post-date>2015-02-05</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>In this post, we&rsquo;ll look at a method for building minimal Docker
images for dynamically linked ELF binaries, and then at <a href=https://github.com/larsks/dockerize>a
tool</a> for automating this process.</p><p>It is tempting, when creating a simple Docker image, to start with one
of the images provided by the major distributions. For example, if
you need an image that provides <code>tcpdump</code> for use on your <a href=http://www.projectatomic.io/>Atomic</a>
host, you might do something like:</p><pre><code>FROM fedora
RUN yum -y install tcpdump
</code></pre><p>And while this will work, you end up consuming 250MB for <code>tcpdump</code>.
In theory, the layering mechanism that Docker uses to build images
will reduce the practical impact of this (because other images based on
the <code>fedora</code> image will share the common layers), but in practice the
size is noticeable, especially if you often find yourself pulling this
image into a fresh environment with no established cache.</p></div><div><a class="read-more button inline" href=/post/2015-02-05-creating-minimal-docker-images/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-01-18-docker-vs-privatetmp/>Docker vs. PrivateTmp</a></h1><div class=post-meta><time class=post-date>2015-01-18</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/systemd/>systemd</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/namespaces/>namespaces</a>&nbsp;</span><div class=post-content><p>While working with Docker <a href=https://blog.oddbit.com/post/2015-01-17-running-novalibvirt-and-novado/>the other day</a>, I ran into an
undesirable interaction between Docker and <a href=http://www.freedesktop.org/wiki/Software/systemd/>systemd</a> services that
utilize the <code>PrivateTmp</code> directive.</p><p>The <a href="http://www.freedesktop.org/software/systemd/man/systemd.exec.html#PrivateTmp=">PrivateTmp</a> directive, if <code>true</code>, &ldquo;sets up a new file system
namespace for the executed processes and mounts private <code>/tmp</code> and
<code>/var/tmp</code> directories inside it that is not shared by processes outside
of the namespace&rdquo;. This is a great idea from a <a href=https://danwalsh.livejournal.com/51459.html>security
perspective</a>, but can cause some unanticipated consequences.</p><h2 id=the-problem-in-a-nutshell>The problem in a nutshell</h2><ol><li><p>Start a Docker container:</p></div><div><a class="read-more button inline" href=/post/2015-01-18-docker-vs-privatetmp/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-01-17-running-novalibvirt-and-novado/>Running nova-libvirt and nova-docker on the same host</a></h1><div class=post-meta><time class=post-date>2015-01-17</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>I regularly use <a href=http://www.openstack.org/>OpenStack</a> on my laptop with <a href=http://www.libvirt.org/>libvirt</a> as my
hypervisor. I was interested in experimenting with recent versions of
the <a href=https://github.com/stackforge/nova-docker>nova-docker</a> driver, but I didn&rsquo;t have a spare system available
on which to run the driver, and I use my regular <code>nova-compute</code> service
often enough that I didn&rsquo;t want to simply disable it temporarily in
favor of <code>nova-docker</code>.</p><hr><p><strong>NB</strong> As pointed out by <em>gustavo</em> in the comments, running two
<code>neutron-openvswitch-agents</code> on the same host &ndash; as suggested in this
article &ndash; is going to lead to nothing but sadness and doom. So
kids, don&rsquo;t try this at home. I&rsquo;m leaving the article here because I
think it still has some interesting bits.</p></div><div><a class="read-more button inline" href=/post/2015-01-17-running-novalibvirt-and-novado/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-01-04-building-a-minimal-web-server-/>Building a minimal web server for testing Kubernetes</a></h1><div class=post-meta><time class=post-date>2015-01-04</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;</span><div class=post-content><p>I have recently been doing some work with <a href=https://github.com/googlecloudplatform/kubernetes>Kubernetes</a>, and wanted
to put together a minimal image with which I could test service and
pod deployment. Size in this case was critical: I wanted something
that would download quickly when initially deployed, because I am
often setting up and tearing down Kubernetes as part of my testing
(and some of my test environments have poor external bandwidth).</p><h2 id=building-thttpd>Building thttpd</h2><p>My go-to minimal webserver is <a href=http://acme.com/software/thttpd/>thttpd</a>. For the normal case,
building the software is a simple matter of <code>./configure</code> followed by
<code>make</code>. This gets you a dynamically linked binary; using <code>ldd</code> you
could build a Docker image containing only the necessary shared
libraries:</p></div><div><a class="read-more button inline" href=/post/2015-01-04-building-a-minimal-web-server-/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2014-10-22-building-docker-images-with-pu/>Building Docker images with Puppet</a></h1><div class=post-meta><time class=post-date>2014-10-22</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/puppet/>puppet</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>I like <a href=http://docker.com/>Docker</a>, but I&rsquo;m not a huge fan of using shell scripts for
complex system configuration&mldr;and Dockerfiles are basically giant
shell scripts.</p><p>I was curious whether or not it would be possible to use Puppet during
the <code>docker build</code> process. As a test case, I used the
<a href=https://github.com/saz/puppet-ssh>ssh</a> module included in the openstack-puppet-modules package.</p><p>I started with a manifest like this (in <code>puppet/node.pp</code>):</p><pre><code>class { 'ssh': }
</code></pre><p>And a Dockerfile like this:</p></div><div><a class="read-more button inline" href=/post/2014-10-22-building-docker-images-with-pu/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/>Docker networking with dedicated network containers</a></h1><div class=post-meta><time class=post-date>2014-10-06</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;</span><div class=post-content><p>The current version of Docker has a very limited set of networking
options:</p><ul><li><code>bridge</code> &ndash; connect a container to the Docker bridge</li><li><code>host</code> &ndash; run the container in the global network namespace</li><li><code>container:xxx</code> &ndash; connect a container to the network namespace of
another container</li><li><code>none</code> &ndash; do not configure any networking</li></ul><p>If you need something more than that, you can use a tool like
<a href=https://github.com/jpetazzo/pipework>pipework</a> to provision additional network interfaces inside the
container, but this leads to a synchronization problem: <code>pipework</code> can
only be used after your container is running. This means that when
starting your container, you must have logic that will wait until the
necessary networking is available before starting your service.</p></div><div><a class="read-more button inline" href=/post/2014-10-06-docker-networking-with-dedicat/>[read more]</a></div></article><div class=pagination><div class=pagination__buttons><a href=/tags/docker/ class="button inline prev">&lt; [<span class=button__text>Newer posts</span>]
</a>::
<a href=/tags/docker/page/3/ class="button inline next">[<span class=button__text>Older posts</span>] ></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>