<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>secrets on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/secrets/</link><description>Recent content in secrets on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Fri, 03 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/secrets/rss.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes External Secrets</title><link>https://blog.oddbit.com/posts/kubernetes-external-secrets/</link><pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/posts/kubernetes-external-secrets/</guid><description>At $JOB we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using ArgoCD and Kustomize. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials.</description><content>&lt;p>At &lt;em>$JOB&lt;/em> we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using &lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a> and &lt;a href="https://kustomize.io/">Kustomize&lt;/a>. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials.&lt;/p>
&lt;h2 id="rejected-options">Rejected options&lt;/h2>
&lt;p>We initially looked at including secrets directly in the repository through the use of the &lt;a href="https://github.com/viaduct-ai/kustomize-sops">KSOPS&lt;/a> plugin for Kustomize, which uses &lt;a href="https://github.com/mozilla/sops">sops&lt;/a> to encrypt secrets with GPG keys. There are some advantages to this arrangement:&lt;/p>
&lt;ul>
&lt;li>It doesn&amp;rsquo;t require any backend service&lt;/li>
&lt;li>It&amp;rsquo;s easy to control read access to secrets in the repository by encrypting them to different recipients.&lt;/li>
&lt;/ul>
&lt;p>There were some minor disadvantages:&lt;/p>
&lt;ul>
&lt;li>We can&amp;rsquo;t install ArgoCD via the operator because we need a customized image that includes KSOPS, so we have to maintain our own ArgoCD image.&lt;/li>
&lt;/ul>
&lt;p>And there was one major problem:&lt;/p>
&lt;ul>
&lt;li>Using GPG-encrypted secrets in a git repository makes it effectively impossible to recover from a key compromise.&lt;/li>
&lt;/ul>
&lt;p>One a private key is compromised, anyone with access to that key and the git repository will be able to decrypt data in historical commits, even if we re-encrypt all the data with a new key.&lt;/p>
&lt;p>Because of these security implications we decided we would need a different solution (it&amp;rsquo;s worth noting here that Bitnami &lt;a href="https://github.com/bitnami-labs/sealed-secrets">Sealed Secrets&lt;/a> suffers from effectively the same problem).&lt;/p>
&lt;h2 id="our-current-solution">Our current solution&lt;/h2>
&lt;p>We&amp;rsquo;ve selected a solution that uses the &lt;a href="https://github.com/external-secrets/kubernetes-external-secrets">External Secrets&lt;/a> project in concert with the AWS &lt;a href="https://aws.amazon.com/secrets-manager/">SecretsManager&lt;/a> service.&lt;/p>
&lt;h3 id="kubernetes-external-secrets">Kubernetes external secrets&lt;/h3>
&lt;p>The &lt;a href="https://github.com/external-secrets/kubernetes-external-secrets">External Secrets&lt;/a> project allows one to store secrets in an external secrets store, such as AWS &lt;a href="https://aws.amazon.com/secrets-manager/">SecretsManager&lt;/a>, Hashicorp &lt;a href="https://www.vaultproject.io/">Vault&lt;/a>, and others &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. The manifests that get pushed into your OpenShift cluster contain only pointers (called &lt;code>ExternalSecrets&lt;/code>) to those secrets; the external secrets controller running on the cluster uses the information contained in the &lt;code>ExternalSecret&lt;/code> in combination with stored credentials to fetch the secret from your chosen backend and realize the actual &lt;code>Secret&lt;/code> resource. An external secret manifest referring to a secret named &lt;code>mysceret&lt;/code> stored in AWS SecretsManager would look something like:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: &amp;#34;kubernetes-client.io/v1&amp;#34;
kind: ExternalSecret
metadata:
name: example-secret
spec:
backendType: secretsManager
data:
- key: mysecret
name: mysecretvalue
&lt;/code>&lt;/pre>&lt;p>This model means that no encrypted data is ever stored in the git repository, which resolves the main problem we had with the solutions mentioned earlier.&lt;/p>
&lt;p>External Secrets can be installed into your Kubernetes environment using Helm, or you can use &lt;code>helm template&lt;/code> to generate manifests locally and apply them using Kustomize or some other tool (this is the route we took).&lt;/p>
&lt;h3 id="aws-secretsmanager-service">AWS SecretsManager Service&lt;/h3>
&lt;p>AWS &lt;a href="https://aws.amazon.com/secrets-manager/">SecretsManager&lt;/a> is a service for storing and managing secrets and making them accessible via an API. Using SecretsManager we have very granular control over who can view or modify secrets; this allows us, for example, to create cluster-specific secret readers that can only read secrets intended for a specific cluster (e.g. preventing our development environment from accidentally using production secrets).&lt;/p>
&lt;p>SecretsManager provides automatic versioning of secrets to prevent loss of data if you inadvertently change a secret while still requiring the old value.&lt;/p>
&lt;p>We can create secrets through the AWS SecretsManager console, or we can use the &lt;a href="https://aws.amazon.com/cli/">AWS CLI&lt;/a>, which looks something like:&lt;/p>
&lt;pre tabindex="0">&lt;code>aws secretsmanager create-secret \
--name mysecretname \
--secret-string mysecretvalue
&lt;/code>&lt;/pre>&lt;h3 id="two-great-tastes-that-taste-great-together">Two great tastes that taste great together&lt;/h3>
&lt;p>This combination solves a number of our problems:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Because we&amp;rsquo;re not storing actual secrets in the repository, we don&amp;rsquo;t need to worry about encrypting anything.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Because we&amp;rsquo;re not managing encrypted data, replacing secrets is much easier.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>There&amp;rsquo;s a robust mechanism for controlling access to secrets.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This solution offers a separation of concern that simply wasn&amp;rsquo;t possible with the KSOPS model: someone can maintain secrets without having to know anything about Kubernetes manifests, and someone can work on the repository without needing to know any secrets.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="creating-external-secrets">Creating external secrets&lt;/h2>
&lt;p>In its simplest form, an &lt;code>ExternalSecret&lt;/code> resource maps values from specific named secrets in the backend to keys in a &lt;code>Secret&lt;/code> resource. For example, if we wanted to create a &lt;code>Secret&lt;/code> in OpenShift with the username and password for an external service, we could create to separate secrets in SecretsManager. One for the username:&lt;/p>
&lt;pre tabindex="0">&lt;code>aws secretsmanager create-secret \
--name cluster/cluster1/example-secret-username \
--secret-string foo
&lt;/code>&lt;/pre>&lt;p>And one for the password:&lt;/p>
&lt;pre tabindex="0">&lt;code>aws secretsmanager create-secret \
--name cluster/cluster1/example-secret-password \
--secret-string bar \
--tags Key=cluster,Value=cluster1
&lt;/code>&lt;/pre>&lt;p>And then create an &lt;code>ExternalSecret&lt;/code> manifest like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: &amp;#34;kubernetes-client.io/v1&amp;#34;
kind: ExternalSecret
metadata:
name: example-secret
spec:
backendType: secretsManager
data:
- key: cluster/cluster1/example-secret-username
name: username
- key: cluster/cluster1/example-secret-password
name: password
&lt;/code>&lt;/pre>&lt;p>This instructs the External Secrets controller to create an &lt;code>Opaque&lt;/code> secret named &lt;code>example-secret&lt;/code> from data in AWS SecretsManager. The value of the &lt;code>username&lt;/code> key will come from the secret named &lt;code>cluster/cluster1/example-secret-username&lt;/code>, and similarly for &lt;code>password&lt;/code>. The resulting &lt;code>Secret&lt;/code> resource will look something like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: v1
kind: Secret
metadata:
name: example-secret
type: Opaque
data:
password: YmFy
username: Zm9v
&lt;/code>&lt;/pre>&lt;h3 id="templates-for-structured-data">Templates for structured data&lt;/h3>
&lt;p>In the previous example, we created two separate secrets in SecretsManager for storing a username and password. It might be more convenient if we could store both credentials in a single secret. Thanks to the &lt;a href="https://github.com/external-secrets/kubernetes-external-secrets#templating">templating&lt;/a> support in External Secrets, we can do that!&lt;/p>
&lt;p>Let&amp;rsquo;s redo the previous example, but instead of using two separate secrets, we&amp;rsquo;ll create a single secret named &lt;code>cluster/cluster1/example-secret&lt;/code> in which the secret value is a JSON document containing both the username and password:&lt;/p>
&lt;pre tabindex="0">&lt;code>aws secretsmanager create-secret \
--name cluster/cluster1/example-secret \
--secret-string &amp;#39;{&amp;#34;username&amp;#34;: &amp;#34;foo&amp;#34;, &amp;#34;password&amp;#34;: &amp;#34;bar&amp;#34;}&amp;#39;
&lt;/code>&lt;/pre>&lt;p>NB: The &lt;a href="https://github.com/jpmens/jo">jo&lt;/a> utility is a neat little utility for generating JSON from the command line; using that we could write the above like this&amp;hellip;&lt;/p>
&lt;pre tabindex="0">&lt;code>aws secretsmanager create-secret \
--name cluster/cluster1/example-secret \
--secret-string $(jo username=foo password=bar)
&lt;/code>&lt;/pre>&lt;p>&amp;hellip;which makes it easier to write JSON without missing a quote, closing bracket, etc.&lt;/p>
&lt;p>We can extract these values into the appropriate keys by adding a &lt;code>template&lt;/code> section to our &lt;code>ExternalSecret&lt;/code>, and using the &lt;code>JSON.parse&lt;/code> template function, like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: &amp;#34;kubernetes-client.io/v1&amp;#34;
kind: ExternalSecret
metadata:
name: example-secret
namespace: sandbox
spec:
backendType: secretsManager
data:
- key: cluster/cluster1/example-secret
name: creds
template:
stringData:
username: &amp;#34;&amp;lt;%= JSON.parse(data.creds).username %&amp;gt;&amp;#34;
password: &amp;#34;&amp;lt;%= JSON.parse(data.creds).password %&amp;gt;&amp;#34;
&lt;/code>&lt;/pre>&lt;p>The result secret will look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: v1
kind: Secret
metadata:
name: example-secret
type: Opaque
data:
creds: eyJ1c2VybmFtZSI6ICJmb28iLCAicGFzc3dvcmQiOiAiYmFyIn0=
password: YmFy
username: Zm9v
&lt;/code>&lt;/pre>&lt;p>Notice that in addition to the values created in the &lt;code>template&lt;/code> section, the &lt;code>Secret&lt;/code> also contains any keys defined in the &lt;code>data&lt;/code> section of the &lt;code>ExternalSecret&lt;/code>.&lt;/p>
&lt;p>Templating can also be used to override the secret type if you want something other than &lt;code>Opaque&lt;/code>, add metadata, and otherwise influence the generated &lt;code>Secret&lt;/code>.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>E.g. Azure Key Vault, Google Secret Manager, Alibaba Cloud KMS Secret Manager, Akeyless&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content></item><item><title>Docker build learns about secrets and ssh agent forwarding</title><link>https://blog.oddbit.com/posts/docker-build-learns-about-secr/</link><pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/posts/docker-build-learns-about-secr/</guid><description>A common problem for folks working with Docker is accessing resources which require authentication during the image build step. A particularly common use case is getting access to private git repositories using ssh key-based authentication. Until recently there hasn&amp;rsquo;t been a great solution:
you can embed secrets in your image, but now you can&amp;rsquo;t share the image with anybody. you can use build arguments, but this requires passing in an unenecrypted private key on the docker build command line, which is suboptimal for a number of reasons you can perform all the steps requiring authentication at runtime, but this can needlessly complicate your container startup process.</description><content>&lt;p>A common problem for folks working with Docker is accessing resources which require authentication during the image build step. A particularly common use case is getting access to private git repositories using ssh key-based authentication. Until recently there hasn&amp;rsquo;t been a great solution:&lt;/p>
&lt;ul>
&lt;li>you can embed secrets in your image, but now you can&amp;rsquo;t share the image with anybody.&lt;/li>
&lt;li>you can use build arguments, but this requires passing in an unenecrypted private key on the &lt;code>docker build&lt;/code> command line, which is suboptimal for a number of reasons&lt;/li>
&lt;li>you can perform all the steps requiring authentication at runtime, but this can needlessly complicate your container startup process.&lt;/li>
&lt;/ul>
&lt;p>With Docker 18.09, there are some experimental features available that makes this much easier. You can read the official announcement &lt;a href="https://docs.docker.com/develop/develop-images/build_enhancements/">here&lt;/a>, but I wanted to highlight the support for ssh agent forwarding and private keys.&lt;/p>
&lt;h1 id="prerequisites">Prerequisites&lt;/h1>
&lt;p>In order to use the new features, you first need to explicitly enable BuildKit support by setting &lt;code>DOCKER_BUILDKIT=1&lt;/code> in your environment:&lt;/p>
&lt;pre>&lt;code>export DOCKER_BUILDKIT=1
&lt;/code>&lt;/pre>
&lt;p>And to utilize the new &lt;code>Dockerfile&lt;/code> syntax, you need to start your &lt;code>Dockerfile&lt;/code> with this directive:&lt;/p>
&lt;pre>&lt;code># syntax=docker/dockerfile:1.0.0-experimental
&lt;/code>&lt;/pre>
&lt;p>That instructs Docker to use the named image (&lt;code>docker/dockerfile:1.0.0-experimental&lt;/code>) to handle the image build process.&lt;/p>
&lt;h2 id="a-simple-example">A simple example&lt;/h2>
&lt;p>The most common use case will probably be forwarding access to your local ssh agent. In order for the build process to get access to your agent, two things must happen:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The &lt;code>RUN&lt;/code> command that requires credentials must specify &lt;code>--mount=type=ssh&lt;/code> in order to have access to the forwarded agent connection, and&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You must pass an appropriate &lt;code>--ssh&lt;/code> option on the &lt;code>docker build&lt;/code> command line. This is to prevent a Dockerfile from unexpectedly gaining access to your ssh credentials.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>We can see this in action if we start with the following &lt;code>Dockerfile&lt;/code>:&lt;/p>
&lt;pre>&lt;code># syntax=docker/dockerfile:1.0.0-experimental
FROM alpine
RUN apk add --update git openssh
# This is necessary to prevent the &amp;quot;git clone&amp;quot; operation from failing
# with an &amp;quot;unknown host key&amp;quot; error.
RUN mkdir -m 700 /root/.ssh; \
touch -m 600 /root/.ssh/known_hosts; \
ssh-keyscan github.com &amp;gt; /root/.ssh/known_hosts
# This command will have access to the forwarded agent (if one is
# available)
RUN --mount=type=ssh git clone git@github.com:moby/buildkit
&lt;/code>&lt;/pre>
&lt;p>If we run build the image like this&amp;hellip;&lt;/p>
&lt;pre>&lt;code>export DOCKER_BUILDKIT=1
docker build --ssh default -t buildtest .
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;then our &lt;code>git clone&lt;/code> operation will successfully authenticate with github using our ssh private key, assuming that we had one loaded into our local ssh agent.&lt;/p>
&lt;h2 id="but-wait-theres-more">But wait, there&amp;rsquo;s more&lt;/h2>
&lt;p>In the previous example line, the &lt;code>--ssh default&lt;/code> option requests &lt;code>docker build&lt;/code> to forward your default ssh agent. There may be situations in which this isn&amp;rsquo;t appropriate (for example, maybe you need to use a key that isn&amp;rsquo;t loaded into your default agent). You can provide the &lt;code>--ssh&lt;/code> option with one or more paths to ssh agent sockets or (unencrypted) private key files. Let&amp;rsquo;s say you have two service-specific private keys:&lt;/p>
&lt;ul>
&lt;li>For GitHub, you need to use &lt;code>$HOME/.ssh/github_rsa&lt;/code>&lt;/li>
&lt;li>For BitBucket, you need to use &lt;code>$HOME/.ssh/bitbucket_rsa&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>You can provide the keys on the &lt;code>docker build&lt;/code> command line like this:&lt;/p>
&lt;pre>&lt;code>docker build --ssh github=$HOME/.ssh/github_rsa,bitbucket=$HOME/.ssh/bitbucket_rsa -t buildtest .
&lt;/code>&lt;/pre>
&lt;p>Then inside your &lt;code>Dockerfile&lt;/code>, you can use the &lt;code>id=&amp;lt;name&amp;gt;&lt;/code> parameter to the &lt;code>--mount&lt;/code> option to specify which key should be available to the &lt;code>RUN&lt;/code> command:&lt;/p>
&lt;pre>&lt;code># syntax=docker/dockerfile:1.0.0-experimental
FROM alpine
RUN apk add --update git openssh
# This is necessary to prevent the &amp;quot;git clone&amp;quot; operation from failing
# with an &amp;quot;unknown host key&amp;quot; error.
RUN mkdir -m 700 /root/.ssh; \
touch -m 600 /root/.ssh/known_hosts; \
ssh-keyscan github.com bitbucket.com &amp;gt; /root/.ssh/known_hosts
# This command has access to the &amp;quot;github&amp;quot; key
RUN --mount=type=ssh,id=github git clone git@github.com:some/project
# This command has access to the &amp;quot;bitbucket&amp;quot; key
RUN --mount=type=ssh,id=bitbucket git clone git@bitbucket.com:other/project
&lt;/code>&lt;/pre>
&lt;h2 id="other-secrets">Other secrets&lt;/h2>
&lt;p>In this post I&amp;rsquo;ve looked specfically at providing &lt;code>docker build&lt;/code> with access to your ssh keys. Docker 18.09 also introduces support for exposing other secrets to the build process; see the official announcement (linked above) for details.&lt;/p></content></item></channel></rss>