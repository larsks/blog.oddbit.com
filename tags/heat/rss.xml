<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Heat on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/heat/</link><description>Recent content in Heat on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 11 Aug 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/heat/rss.xml" rel="self" type="application/rss+xml"/><item><title>Exploring YAQL Expressions</title><link>https://blog.oddbit.com/post/2016-08-11-exploring-yaql-expressions/</link><pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2016-08-11-exploring-yaql-expressions/</guid><description>&lt;p>The Newton release of &lt;a href="https://wiki.openstack.org/wiki/Heat">Heat&lt;/a> adds support for a &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#yaql">yaql&lt;/a>
intrinsic function, which allows you to evaluate &lt;a href="https://yaql.readthedocs.io/en/latest/">yaql&lt;/a> expressions
in your Heat templates. Unfortunately, the existing yaql
documentation is somewhat limited, and does not offer examples of many
of yaql&amp;rsquo;s more advanced features.&lt;/p>
&lt;p>I am working on a &lt;a href="http://www.fluentd.org/">Fluentd&lt;/a> composable service for &lt;a href="https://wiki.openstack.org/wiki/TripleO">TripleO&lt;/a>. I
want to allow each service to specify a logging source configuration
fragment, for example:&lt;/p></description><content>&lt;p>The Newton release of &lt;a href="https://wiki.openstack.org/wiki/Heat">Heat&lt;/a> adds support for a &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#yaql">yaql&lt;/a>
intrinsic function, which allows you to evaluate &lt;a href="https://yaql.readthedocs.io/en/latest/">yaql&lt;/a> expressions
in your Heat templates. Unfortunately, the existing yaql
documentation is somewhat limited, and does not offer examples of many
of yaql&amp;rsquo;s more advanced features.&lt;/p>
&lt;p>I am working on a &lt;a href="http://www.fluentd.org/">Fluentd&lt;/a> composable service for &lt;a href="https://wiki.openstack.org/wiki/TripleO">TripleO&lt;/a>. I
want to allow each service to specify a logging source configuration
fragment, for example:&lt;/p>
&lt;pre>&lt;code>parameters:
NovaAPILoggingSource:
type: json
description: Fluentd logging configuration for nova-api.
default:
tag: openstack.nova.api
type: tail
format: |
/(?&amp;lt;time&amp;gt;\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d+) (?&amp;lt;pid&amp;gt;\d+) (?&amp;lt;priority&amp;gt;\S+) (?&amp;lt;message&amp;gt;.*)/
path: /var/log/nova/nova-api.log
pos_file: /var/run/fluentd/openstack.nova.api.pos
&lt;/code>&lt;/pre>
&lt;p>This generally works, but several parts of this fragment are going to
be the same across all OpenStack services. I wanted to reduce the
above to just the unique attributes, which would look something like:&lt;/p>
&lt;pre>&lt;code>parameters:
NovaAPILoggingSource:
type: json
description: Fluentd logging configuration for nova-api.
default:
tag: openstack.nova.api
path: /var/log/nova/nova-api.log
&lt;/code>&lt;/pre>
&lt;p>This would ultimately give me a list of dictionaries of the form:&lt;/p>
&lt;pre>&lt;code>[
{
&amp;quot;tag&amp;quot;: &amp;quot;openstack.nova.api&amp;quot;,
&amp;quot;path&amp;quot;: &amp;quot;/var/log/nova/nova-api.log&amp;quot;
},
{
&amp;quot;tag&amp;quot;: &amp;quot;openstack.nova.scheduler&amp;quot;,
&amp;quot;path&amp;quot;: &amp;quot;/var/log/nova/nova-scheduler.log&amp;quot;
}
]
&lt;/code>&lt;/pre>
&lt;p>I want to iterate over this list, adding default values for attributes
that are not explicitly provided.&lt;/p>
&lt;p>The yaql language has a &lt;code>select&lt;/code> function, somewhat analagous to the
SQL &lt;code>select&lt;/code> statement, that can be used to construct a new data
structure from an existing one. For example, given the above data in
a parameter called &lt;code>sources&lt;/code>, I could write:&lt;/p>
&lt;pre>&lt;code>outputs:
sources:
yaql:
data:
sources: {get_param: sources}
expression: &amp;gt;
$.data.sources.select({
'path' =&amp;gt; $.path,
'tag' =&amp;gt; $.tag,
'type' =&amp;gt; $.get('type', 'tail')})
&lt;/code>&lt;/pre>
&lt;p>This makes use of the &lt;code>.get&lt;/code> method to insert a default value of
&lt;code>tail&lt;/code> for the &lt;code>type&lt;/code> attribute for items that don&amp;rsquo;t specify it
explicitly. This would produce a list that looks like:&lt;/p>
&lt;pre>&lt;code>[
{
&amp;quot;path&amp;quot;: &amp;quot;/var/log/nova/nova-api.log&amp;quot;,
&amp;quot;tag&amp;quot;: &amp;quot;openstack.nova.api&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;tail&amp;quot;
},
{
&amp;quot;path&amp;quot;: &amp;quot;/var/log/nova/nova-scheduler.log&amp;quot;,
&amp;quot;tag&amp;quot;: &amp;quot;openstack.nova.scheduler&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;tail&amp;quot;
}
]
&lt;/code>&lt;/pre>
&lt;p>That works fine, but what if I want to parameterize the default value
such that it can be provided as part of the template? I wanted to be
able to pass the yaql expression something like this&amp;hellip;&lt;/p>
&lt;pre>&lt;code>outputs:
sources:
yaql:
data:
sources: {get_param: sources}
default_type: tail
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;and then within the yaql expression, insert the value of
&lt;code>default_type&lt;/code> into items that don&amp;rsquo;t provide an explicit value for the
&lt;code>type&lt;/code> attribute.&lt;/p>
&lt;p>This is trickier than it might sound at first because within the
context of the &lt;code>select&lt;/code> method, &lt;code>$&lt;/code> is bound to the &lt;em>local&lt;/em> context,
which will be an individual item from the list. So while I can ask
for &lt;code>$.path&lt;/code>, there&amp;rsquo;s no way to refer to items from the top-level
context. Or is there?&lt;/p>
&lt;p>The &lt;a href="https://yaql.readthedocs.io/en/latest/getting_started.html#operators">operators&lt;/a> documentation for yaql mentions the &amp;ldquo;context pass&amp;rdquo;
operator, &lt;code>-&amp;gt;&lt;/code>, but doesn&amp;rsquo;t provide any examples of how it can be
used. It turns out that this operator will be the key to our solution.
But before we look at that in more detail, we need to introduce the
&lt;code>let&lt;/code> statement, which can be used to define variables. The &lt;code>let&lt;/code>
statement isn&amp;rsquo;t mentioned in the documentation at all, but it looks
like this:&lt;/p>
&lt;pre>&lt;code>let(var =&amp;gt; value, ...)
&lt;/code>&lt;/pre>
&lt;p>By itself, this isn&amp;rsquo;t particularly useful. In fact, if you were to
type a bare &lt;code>let&lt;/code> statement in a yaql evaluator, you would get an
error:&lt;/p>
&lt;pre>&lt;code>yaql&amp;gt; let(foo =&amp;gt; 10, bar =&amp;gt; 20)
Execution exception: &amp;lt;yaql.language.contexts.Context object at 0x7fbaf9772e50&amp;gt; is not JSON serializable
&lt;/code>&lt;/pre>
&lt;p>This is where the &lt;code>-&amp;gt;&lt;/code> operator comes into play. We use that to pass
the context created by the &lt;code>let&lt;/code> statement into a yaql expression. For
example:&lt;/p>
&lt;pre>&lt;code>yaql&amp;gt; let(foo =&amp;gt; 10, bar =&amp;gt; 20) -&amp;gt; $foo
10
yaql&amp;gt; let(foo =&amp;gt; 10, bar =&amp;gt; 20) -&amp;gt; $bar
20
&lt;/code>&lt;/pre>
&lt;p>With that in mind, we can return to our earlier task, and rewrite the
yaql expression like this:&lt;/p>
&lt;pre>&lt;code>outputs:
sources:
yaql:
data:
sources: {get_param: sources}
default_type: tail
expression: &amp;gt;
let(default_type =&amp;gt; $.data.default_type) -&amp;gt;
$.data.sources.select({
'path' =&amp;gt; $.path,
'tag' =&amp;gt; $.tag,
'type' =&amp;gt; $.get('type', $default_type)})
&lt;/code>&lt;/pre>
&lt;p>Which will give us exactly what we want. This can of course be
extended to support additional default values:&lt;/p>
&lt;pre>&lt;code>outputs:
sources:
yaql:
data:
sources: {get_param: sources}
default_type: tail
default_format: &amp;gt;
/some regular expression/
expression: &amp;gt;
let(
default_type =&amp;gt; $.data.default_type,
default_format =&amp;gt; $.data.default_format
) -&amp;gt;
$.data.sources.select({
'path' =&amp;gt; $.path,
'tag' =&amp;gt; $.tag,
'type' =&amp;gt; $.get('type', $default_type),
'format' =&amp;gt; $.get('format', $default_format)
})
&lt;/code>&lt;/pre>
&lt;p>Going out on a bit of a tangent, there is another statement not
mentioned in the documentation: the &lt;code>def&lt;/code> statement lets you defined a
yaql function. The general format is:&lt;/p>
&lt;pre>&lt;code>def(func_name, func_body)
&lt;/code>&lt;/pre>
&lt;p>Where &lt;code>func_body&lt;/code> is a yaql expresion. For example:&lt;/p>
&lt;pre>&lt;code>def(upperpath, $.path.toUpper()) -&amp;gt;
$.data.sources.select(upperpath($))
&lt;/code>&lt;/pre>
&lt;p>Which would generate:&lt;/p>
&lt;pre>&lt;code>[
&amp;quot;/VAR/LOG/NOVA/NOVA-API.LOG&amp;quot;,
&amp;quot;/VAR/LOG/NOVA/NOVA-SCHEDULER.LOG&amp;quot;
]
&lt;/code>&lt;/pre>
&lt;p>This obviously becomes more useful as you use user-defined functions
to encapsulate more complex yaql expressions for re-use.&lt;/p>
&lt;p>Thanks to &lt;a href="https://github.com/sergmelikyan">sergmelikyan&lt;/a> for his help figuring this out.&lt;/p></content></item><item><title>Heat-kubernetes Demo with Autoscaling</title><link>https://blog.oddbit.com/post/2015-06-19-heatkubernetes-demo-with-autos/</link><pubDate>Fri, 19 Jun 2015 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2015-06-19-heatkubernetes-demo-with-autos/</guid><description>&lt;p>Next week is the &lt;a href="http://www.redhat.com/summit/">Red Hat Summit&lt;/a> in Boston, and I&amp;rsquo;ll be taking part
in a &lt;a href="http://www.projectatomic.io/">Project Atomic&lt;/a> presentation in which I will discuss various
(well, two) options for deploying Atomic into an OpenStack
environment, focusing on my &lt;a href="https://github.com/projectatomic/heat-kubernetes/">heat-kubernetes&lt;/a> templates.&lt;/p>
&lt;p>As part of that presentation, I&amp;rsquo;ve put together a short demonstration video:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/tS5X0qi04ZU?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div>
&lt;p>This shows off the autoscaling behavior available with recent versions
of these templates (and also serves as a very brief introduction to
working with Kubernetes).&lt;/p></description><content>&lt;p>Next week is the &lt;a href="http://www.redhat.com/summit/">Red Hat Summit&lt;/a> in Boston, and I&amp;rsquo;ll be taking part
in a &lt;a href="http://www.projectatomic.io/">Project Atomic&lt;/a> presentation in which I will discuss various
(well, two) options for deploying Atomic into an OpenStack
environment, focusing on my &lt;a href="https://github.com/projectatomic/heat-kubernetes/">heat-kubernetes&lt;/a> templates.&lt;/p>
&lt;p>As part of that presentation, I&amp;rsquo;ve put together a short demonstration video:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/tS5X0qi04ZU?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div>
&lt;p>This shows off the autoscaling behavior available with recent versions
of these templates (and also serves as a very brief introduction to
working with Kubernetes).&lt;/p></content></item><item><title>Heat Hangout</title><link>https://blog.oddbit.com/post/2014-09-05-heat-hangout/</link><pubDate>Fri, 05 Sep 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-09-05-heat-hangout/</guid><description>&lt;p>I ran a Google Hangout this morning on &lt;a href="https://plus.google.com/events/c9u4sjn7ksb8jrmma7vd25aok94">Deploying with Heat&lt;/a>. You
can find the slides for the presentation on line &lt;a href="http://oddbit.com/rdo-hangout-heat-intro/#/">here&lt;/a>, and the
Heat templates (as well as slide sources) are available &lt;a href="https://github.com/larsks/rdo-hangout-heat-intro/">on
github&lt;/a>.&lt;/p>
&lt;p>If you have any questions about the presentation, please feel free to
ping me on irc (&lt;code>larsks&lt;/code>).&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/qH-qYE1Kmpg?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div></description><content>&lt;p>I ran a Google Hangout this morning on &lt;a href="https://plus.google.com/events/c9u4sjn7ksb8jrmma7vd25aok94">Deploying with Heat&lt;/a>. You
can find the slides for the presentation on line &lt;a href="http://oddbit.com/rdo-hangout-heat-intro/#/">here&lt;/a>, and the
Heat templates (as well as slide sources) are available &lt;a href="https://github.com/larsks/rdo-hangout-heat-intro/">on
github&lt;/a>.&lt;/p>
&lt;p>If you have any questions about the presentation, please feel free to
ping me on irc (&lt;code>larsks&lt;/code>).&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/qH-qYE1Kmpg?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div></content></item><item><title>Visualizing Heat stacks</title><link>https://blog.oddbit.com/post/2014-09-02-visualizing-heat-stacks/</link><pubDate>Tue, 02 Sep 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-09-02-visualizing-heat-stacks/</guid><description>&lt;p>I spent some time today learning about Heat &lt;a href="https://wiki.openstack.org/wiki/Heat/AutoScaling">autoscaling groups&lt;/a>,
which are incredibly nifty but a little opaque from the Heat command
line, since commands such as &lt;code>heat resource-list&lt;/code> don&amp;rsquo;t recurse into
nested stacks. It is possible to introspect these resources (you can
pass the physical resource id of a nested stack to &lt;code>heat resource-list&lt;/code>, for example)&amp;hellip;&lt;/p>
&lt;p>&amp;hellip;but I really like visualizing things, so I wrote a quick hack
called &lt;a href="http://github.com/larsks/dotstack">dotstack&lt;/a> that will generate &lt;a href="http://en.wikipedia.org/wiki/DOT_(graph_description_language)">dot&lt;/a> language output from a
Heat stack. You can process this with &lt;a href="http://www.graphviz.org/">Graphviz&lt;/a> to produce output
like this, in which graph nodes are automatically colorized by
resource type:&lt;/p></description><content>&lt;p>I spent some time today learning about Heat &lt;a href="https://wiki.openstack.org/wiki/Heat/AutoScaling">autoscaling groups&lt;/a>,
which are incredibly nifty but a little opaque from the Heat command
line, since commands such as &lt;code>heat resource-list&lt;/code> don&amp;rsquo;t recurse into
nested stacks. It is possible to introspect these resources (you can
pass the physical resource id of a nested stack to &lt;code>heat resource-list&lt;/code>, for example)&amp;hellip;&lt;/p>
&lt;p>&amp;hellip;but I really like visualizing things, so I wrote a quick hack
called &lt;a href="http://github.com/larsks/dotstack">dotstack&lt;/a> that will generate &lt;a href="http://en.wikipedia.org/wiki/DOT_(graph_description_language)">dot&lt;/a> language output from a
Heat stack. You can process this with &lt;a href="http://www.graphviz.org/">Graphviz&lt;/a> to produce output
like this, in which graph nodes are automatically colorized by
resource type:&lt;/p>
&lt;figure class="left" >
&lt;img src="sample.svg" />
&lt;/figure>
&lt;p>Or like this, in which each node contains information about its
resource type and physical resource id:&lt;/p>
&lt;figure class="left" >
&lt;img src="sample-detailed.svg" />
&lt;/figure>
&lt;p>The source code is available on &lt;a href="http://github.com/larsks/dotstack">github&lt;/a>.&lt;/p></content></item><item><title>Docker plugin bugs</title><link>https://blog.oddbit.com/post/2014-09-01-docker-plugin-bugs/</link><pubDate>Mon, 01 Sep 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-09-01-docker-plugin-bugs/</guid><description>&lt;p>This is a companion to my &lt;a href="https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/">article on the Docker plugin for Heat&lt;/a>.&lt;/p>
&lt;p>While writing that article, I encountered a number of bugs in the
Docker plugin and elsewhere. I&amp;rsquo;ve submitted patches for most of the
issues I encountered:&lt;/p>
&lt;h2 id="bugs-in-the-heat-plugin">Bugs in the Heat plugin&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://bugs.launchpad.net/heat/+bug/1364017">https://bugs.launchpad.net/heat/+bug/1364017&lt;/a>&lt;/p>
&lt;p>docker plugin fails to delete a container resource in
&lt;code>CREATE_FAILED&lt;/code> state.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://bugs.launchpad.net/heat/+bug/1364041">https://bugs.launchpad.net/heat/+bug/1364041&lt;/a>&lt;/p></description><content>&lt;p>This is a companion to my &lt;a href="https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/">article on the Docker plugin for Heat&lt;/a>.&lt;/p>
&lt;p>While writing that article, I encountered a number of bugs in the
Docker plugin and elsewhere. I&amp;rsquo;ve submitted patches for most of the
issues I encountered:&lt;/p>
&lt;h2 id="bugs-in-the-heat-plugin">Bugs in the Heat plugin&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://bugs.launchpad.net/heat/+bug/1364017">https://bugs.launchpad.net/heat/+bug/1364017&lt;/a>&lt;/p>
&lt;p>docker plugin fails to delete a container resource in
&lt;code>CREATE_FAILED&lt;/code> state.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://bugs.launchpad.net/heat/+bug/1364041">https://bugs.launchpad.net/heat/+bug/1364041&lt;/a>&lt;/p>
&lt;p>docker plugin &lt;code>volumes_from&lt;/code> parameter should be a list.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://bugs.launchpad.net/heat/+bug/1364039">https://bugs.launchpad.net/heat/+bug/1364039&lt;/a>&lt;/p>
&lt;p>docker plugin &lt;code>volumes_from&lt;/code> parameter results in an error&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://bugs.launchpad.net/heat/+bug/1364019">https://bugs.launchpad.net/heat/+bug/1364019&lt;/a>&lt;/p>
&lt;p>docker plugin does not actually remove containers on delete&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="bugs-in-docker-python-module">Bugs in docker Python module&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/docker/docker-py/pull/310">https://github.com/docker/docker-py/pull/310&lt;/a>&lt;/p>
&lt;p>allow ports to be specified as &lt;code>port/proto&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>Annotated documentation for DockerInc::Docker::Container</title><link>https://blog.oddbit.com/post/2014-08-30-docker-contain-doc/</link><pubDate>Sat, 30 Aug 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-08-30-docker-contain-doc/</guid><description>&lt;p>This is a companion to my &lt;a href="https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/">article on the Docker plugin for Heat&lt;/a>.&lt;/p>
&lt;h2 id="dockerincdockercontainer">DockerInc::Docker::Container&lt;/h2>
&lt;h3 id="properties">Properties&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>cmd&lt;/code> : List&lt;/p>
&lt;p>Command to run after spawning the container.&lt;/p>
&lt;p>Optional property.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> cmd: [ 'thttpd', '-C', '/etc/thttpd.conf', '-D', '-c', '*.cgi']
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dns&lt;/code> : List&lt;/p>
&lt;p>Set custom DNS servers.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> dns:
- 8.8.8.8
- 8.8.4.4
&lt;/code>&lt;/pr</description><content>&lt;p>This is a companion to my &lt;a href="https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/">article on the Docker plugin for Heat&lt;/a>.&lt;/p>
&lt;h2 id="dockerincdockercontainer">DockerInc::Docker::Container&lt;/h2>
&lt;h3 id="properties">Properties&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>cmd&lt;/code> : List&lt;/p>
&lt;p>Command to run after spawning the container.&lt;/p>
&lt;p>Optional property.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> cmd: [ 'thttpd', '-C', '/etc/thttpd.conf', '-D', '-c', '*.cgi']
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dns&lt;/code> : List&lt;/p>
&lt;p>Set custom DNS servers.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> dns:
- 8.8.8.8
- 8.8.4.4
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>docker_endopint&lt;/code> : String&lt;/p>
&lt;p>Docker daemon endpoint. By default the local Docker daemon will
be used.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> docker_endpoint: tcp://192.168.1.100:2375
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>env&lt;/code> : String&lt;/p>
&lt;p>Set environment variables.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> env:
- MYSQL_ROOT_PASSWORD=secret
- &amp;quot;ANOTHER_VARIABLE=something long with spaces&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>hostname&lt;/code> : String&lt;/p>
&lt;p>Hostname of the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> hostname: mywebserver
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>image&lt;/code> : String&lt;/p>
&lt;p>Image name to boot.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> image: mysql
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>links&lt;/code> : Mapping&lt;/p>
&lt;p>Links to other containers.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> links:
name_in_this_container: name_of_that_container
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>memory&lt;/code> : Number&lt;/p>
&lt;p>Memory limit in bytes.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> # 512 MB
memory: 536870912
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>name&lt;/code> : String&lt;/p>
&lt;p>Name of the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> name: dbserver
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>open_stdin&lt;/code> : Boolean&lt;/p>
&lt;p>True to open &lt;code>stdin&lt;/code>.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> open_stdin: true
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>port_bindings&lt;/code> : Map&lt;/p>
&lt;p>TCP/UDP port bindings.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> # bind port 8080 in the container to port 80 on the host
port_bindings:
8080: 80
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>port_specs&lt;/code> : List&lt;/p>
&lt;p>List of TCP/UDP ports exposed by the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> port_specs:
- 80
- 53/udp
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>privileged&lt;/code> : Boolean&lt;/p>
&lt;p>Enable extended privileges.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> privileged: true
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stdin_once&lt;/code> : Boolean&lt;/p>
&lt;p>If &lt;code>true&lt;/code>, close &lt;code>stdin&lt;/code> after the one attached client disconnects.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> stdin_once: true
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>tty&lt;/code> : Boolean&lt;/p>
&lt;p>Allocate a pseudo-tty if &lt;code>true&lt;/code>.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> tty: true
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>user&lt;/code> : String&lt;/p>
&lt;p>Username or UID for running the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> username: apache
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>volumes&lt;/code> : Map&lt;/p>
&lt;p>Create a bind mount.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> volumes:
/var/tmp/data_on_host: /srv/data_in_container
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>volumes_from&lt;/code> : String&lt;/p>
&lt;p>&lt;em>This option is broken in the current version of the Docker
plugin.&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="attributes">Attributes&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>info&lt;/code> : Map&lt;/p>
&lt;p>Information about the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> info:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;info&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>Output:&lt;/p>
&lt;pre>&lt;code> {
&amp;quot;HostsPath&amp;quot;: &amp;quot;/var/lib/docker/containers/d6d84d1bbf2984fa3e04cea36c8d10d27d318b6d96b57c41fca2cbc1da23bf71/hosts&amp;quot;,
&amp;quot;Created&amp;quot;: &amp;quot;2014-09-01T14:21:02.7577874Z&amp;quot;,
&amp;quot;Image&amp;quot;: &amp;quot;a950533b3019d8f6dfdcb8fdc42ef810b930356619b3e4786d4f2acec514238d&amp;quot;,
&amp;quot;Args&amp;quot;: [
&amp;quot;mysqld&amp;quot;,
&amp;quot;--datadir=/var/lib/mysql&amp;quot;,
&amp;quot;--user=mysql&amp;quot;
],
&amp;quot;Driver&amp;quot;: &amp;quot;devicemapper&amp;quot;,
&amp;quot;HostConfig&amp;quot;: {
&amp;quot;CapDrop&amp;quot;: null,
&amp;quot;PortBindings&amp;quot;: {
&amp;quot;3306/tcp&amp;quot;: [
{
&amp;quot;HostPort&amp;quot;: &amp;quot;3306&amp;quot;,
&amp;quot;HostIp&amp;quot;: &amp;quot;&amp;quot;
}
]
},
&amp;quot;NetworkMode&amp;quot;: &amp;quot;&amp;quot;,
.
.
.
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>logs&lt;/code> : String&lt;/p>
&lt;p>Logs from the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> logs:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;logs&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>logs_head&lt;/code> : String&lt;/p>
&lt;p>Most recent log line from the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> logs:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;logs_head&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>Output:&lt;/p>
&lt;pre>&lt;code> &amp;quot;2014-09-01 14:21:04 0 [Warning] TIMESTAMP with implicit DEFAULT
value is deprecated. Please use --explicit_defaults_for_timestamp
server option (see documentation for more details).&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>network_gateway&lt;/code> : String&lt;/p>
&lt;p>IP address of the network gateway for the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> network_gateway:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;network_gateway&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>Output:&lt;/p>
&lt;pre>&lt;code> &amp;quot;172.17.42.1&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>network_info&lt;/code> : Map&lt;/p>
&lt;p>Information about the network configuration of the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> network_info:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;network_info&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>Output:&lt;/p>
&lt;pre>&lt;code> {
&amp;quot;Bridge&amp;quot;: &amp;quot;docker0&amp;quot;,
&amp;quot;TcpPorts&amp;quot;: &amp;quot;3306&amp;quot;,
&amp;quot;PortMapping&amp;quot;: null,
&amp;quot;IPPrefixLen&amp;quot;: 16,
&amp;quot;UdpPorts&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;IPAddress&amp;quot;: &amp;quot;172.17.0.10&amp;quot;,
&amp;quot;Gateway&amp;quot;: &amp;quot;172.17.42.1&amp;quot;,
&amp;quot;Ports&amp;quot;: {
&amp;quot;3306/tcp&amp;quot;: [
{
&amp;quot;HostPort&amp;quot;: &amp;quot;3306&amp;quot;,
&amp;quot;HostIp&amp;quot;: &amp;quot;0.0.0.0&amp;quot;
}
]
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>network_ip&lt;/code> : String&lt;/p>
&lt;p>IP address assigned to the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> network_ip:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;network_ip&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>Output:&lt;/p>
&lt;pre>&lt;code> &amp;quot;172.17.0.10&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>network_tcp_ports&lt;/code> : String&lt;/p>
&lt;p>A comma delimited list of TCP ports exposed by the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> network_tcp_ports:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;network_tcp_ports&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>Output:&lt;/p>
&lt;pre>&lt;code> &amp;quot;8443,8080&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>network_udp_ports&lt;/code> : String&lt;/p>
&lt;p>A comma delimited list of TCP ports exposed by the container.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code> network_udp_ports:
value: {get_attr: [&amp;quot;docker_dbserver&amp;quot;, &amp;quot;network_udp_ports&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>Output:&lt;/p>
&lt;pre>&lt;code> &amp;quot;8443,8080&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul></content></item><item><title>Docker plugin for OpenStack Heat</title><link>https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/</link><pubDate>Sat, 30 Aug 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/</guid><description>&lt;p>I have been looking at both Docker and OpenStack recently. In my &lt;a href="https://blog.oddbit.com/post/2014-08-28-novadocker-and-environment-var/">last
post&lt;/a> I talked a little about the &lt;a href="https://github.com/stackforge/nova-docker">Docker driver for Nova&lt;/a>; in
this post I&amp;rsquo;ll be taking an in-depth look at the Docker plugin for
Heat, which has been available &lt;a href="https://blog.docker.com/2014/03/docker-will-be-in-openstack-icehouse/">since the Icehouse release&lt;/a> but is
surprisingly under-documented.&lt;/p>
&lt;p>The &lt;a href="https://blog.docker.com/2014/03/docker-will-be-in-openstack-icehouse/">release announcement&lt;/a> on the Docker blog includes an
example Heat template, but it is unfortunately grossly inaccurate and
has led many people astray. In particular:&lt;/p></description><content>&lt;p>I have been looking at both Docker and OpenStack recently. In my &lt;a href="https://blog.oddbit.com/post/2014-08-28-novadocker-and-environment-var/">last
post&lt;/a> I talked a little about the &lt;a href="https://github.com/stackforge/nova-docker">Docker driver for Nova&lt;/a>; in
this post I&amp;rsquo;ll be taking an in-depth look at the Docker plugin for
Heat, which has been available &lt;a href="https://blog.docker.com/2014/03/docker-will-be-in-openstack-icehouse/">since the Icehouse release&lt;/a> but is
surprisingly under-documented.&lt;/p>
&lt;p>The &lt;a href="https://blog.docker.com/2014/03/docker-will-be-in-openstack-icehouse/">release announcement&lt;/a> on the Docker blog includes an
example Heat template, but it is unfortunately grossly inaccurate and
has led many people astray. In particular:&lt;/p>
&lt;ul>
&lt;li>It purports to but does not actually install Docker, due to a basic
&lt;a href="http://en.wikipedia.org/wiki/YAML">YAML&lt;/a> syntax error, and&lt;/li>
&lt;li>Even if you were to fix that problem, the lack of synchronization
between the two resources in the template would mean that you would
never be able to successfully launch a container.&lt;/li>
&lt;/ul>
&lt;p>In this post, I will present a fully functional example that will work
with the Icehouse release of Heat. We will install the Docker plugin
for Heat, then write a template that will (a) launch a Fedora 20
server and automatically install Docker, and then (b) use the Docker
plugin to launch some containers on that server.&lt;/p>
&lt;p>The &lt;a href="https://github.com/larsks/heat-docker-example">complete template&lt;/a> referenced in this article can be found on GitHub:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/larsks/heat-docker-example">https://github.com/larsks/heat-docker-example&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="installing-the-docker-plugin">Installing the Docker plugin&lt;/h2>
&lt;p>The first thing we need to do is install the Docker plugin. I am
running &lt;a href="http://openstack.redhat.com/">RDO&lt;/a> packages for Icehouse locally, which do not include
the Docker plugin. We&amp;rsquo;r going to install the plugin from the Heat
sources.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Download the Heat repository:&lt;/p>
&lt;pre>&lt;code> $ git clone https://github.com/openstack/heat.git
Cloning into 'heat'...
remote: Counting objects: 50382, done.
remote: Compressing objects: 100% (22/22), done.
remote: Total 50382 (delta 7), reused 1 (delta 0)
Receiving objects: 100% (50382/50382), 19.84 MiB | 1.81 MiB/s, done.
Resolving deltas: 100% (34117/34117), done.
Checking connectivity... done.
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>This will result in a directory called &lt;code>heat&lt;/code> in your current
working directory. Change into this directory:&lt;/p>
&lt;pre>&lt;code> $ cd heat
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Patch the Docker plugin.&lt;/p>
&lt;p>You have now checked out the &lt;code>master&lt;/code> branch of the Heat
repository; this is the most recent code committed to the project.
At this point we could check out the &lt;code>stable/icehouse&lt;/code> branch of
the repository to get the version of the plugin released at the
same time as the version of Heat that we&amp;rsquo;re running, but we would
find that the Docker plugin was, at that point in time, somewhat
crippled; in particular:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>It does not support mapping container ports to host ports, so
there is no easy way to expose container services for external
access, and&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It does not know how to automatically &lt;code>pull&lt;/code> missing images, so
you must arrange to run &lt;code>docker pull&lt;/code> a priori for each image you
plan to use in your Heat template.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>That would make us sad, so instead we&amp;rsquo;re going to use the plugin
from the &lt;code>master&lt;/code> branch, which only requires a trivial change in
order to work with the Icehouse release of Heat.&lt;/p>
&lt;p>Look at the file
&lt;code>contrib/heat_docker/heat_docker/resources/docker_container.py&lt;/code>.
Locate the following line:&lt;/p>
&lt;pre>&lt;code> attributes_schema = {
&lt;/code>&lt;/pre>
&lt;p>Add a line immediately before that so that the file look like
this:&lt;/p>
&lt;pre>&lt;code> attributes.Schema = lambda x: x
attributes_schema = {
&lt;/code>&lt;/pre>
&lt;p>If you&amp;rsquo;re curious, here is what we accomplished with that
additional line:&lt;/p>
&lt;p>The code following that point contains multiple stanzas of the
form:&lt;/p>
&lt;pre>&lt;code> INFO: attributes.Schema(
_('Container info.')
),
&lt;/code>&lt;/pre>
&lt;p>In Icehouse, the &lt;code>heat.engine.attributes&lt;/code> module does not have a
&lt;code>Schema&lt;/code> class so this fails. Our patch above adds a module
member named &lt;code>Schema&lt;/code> that simply returns it&amp;rsquo;s arguments (that
is, it is an identity function).&lt;/p>
&lt;p>(&lt;strong>NB&lt;/strong>: At the time this was written, Heat&amp;rsquo;s &lt;code>master&lt;/code> branch was
at &lt;code>a767880&lt;/code>.)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Install the Docker plugin into your Heat plugin directory, which
on my system is &lt;code>/usr/lib/heat&lt;/code> (you can set this explicitly using
the &lt;code>plugin_dirs&lt;/code> directive in &lt;code>/etc/heat/heat.conf&lt;/code>):&lt;/p>
&lt;pre>&lt;code> $ rsync -a --exclude=tests/ contrib/heat_docker/heat_docker \
/usr/lib/heat
&lt;/code>&lt;/pre>
&lt;p>We&amp;rsquo;re excluding the &lt;code>tests&lt;/code> directory here because it has
additional prerequisites that aren&amp;rsquo;t operationally necessary but
that will prevent Heat from starting up if they are missing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Restart your &lt;code>heat-engine&lt;/code> service. On Fedora, that would be:&lt;/p>
&lt;pre>&lt;code> # systemctl restart openstack-heat-engine
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Verify that the new &lt;code>DockerInc::Docker::Container&lt;/code> resource is
available:&lt;/p>
&lt;pre>&lt;code> $ heat resource-type-list | grep Docker
| DockerInc::Docker::Container |
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="templates-installing-docker">Templates: Installing docker&lt;/h2>
&lt;p>We would like our template to automatically install Docker on a Nova
server. The example in the &lt;a href="https://blog.docker.com/2014/03/docker-will-be-in-openstack-icehouse/">Docker blog&lt;/a> mentioned earlier
attempts to do this by setting the &lt;code>user_data&lt;/code> parameter of a
&lt;code>OS::Nova::Server&lt;/code> resource like this:&lt;/p>
&lt;pre>&lt;code>user_data: #include https://get.docker.io
&lt;/code>&lt;/pre>
&lt;p>Unfortunately, an unquoted &lt;code>#&lt;/code> introduces a comment in &lt;a href="http://en.wikipedia.org/wiki/YAML">YAML&lt;/a>, so
this is completely ignored. It would be written more correctly like
this (the &lt;code>|&lt;/code> introduces a block of literal text):&lt;/p>
&lt;pre>&lt;code>user_data: |
#include https://get.docker.io
&lt;/code>&lt;/pre>
&lt;p>Or possibly like this, although this would restrict you to a single
line and thus wouldn&amp;rsquo;t be used much in practice:&lt;/p>
&lt;pre>&lt;code>user_data: &amp;quot;#include https://get.docker.io&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>And, all other things being correct, this would install Docker on a
system&amp;hellip;but would not necessarily start it, nor would it configure
Docker to listen on a TCP socket. On my Fedora system, I ended up
creating the following &lt;code>user_data&lt;/code> script:&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
yum -y upgrade
# I have occasionally seen 'yum install' fail with errors
# trying to contact mirrors. Because it can be a pain to
# delete and re-create the stack, just loop here until it
# succeeds.
while :; do
yum -y install docker-io
[ -x /usr/bin/docker ] &amp;amp;&amp;amp; break
sleep 5
done
# Add a tcp socket for docker
cat &amp;gt; /etc/systemd/system/docker-tcp.socket &amp;lt;&amp;lt;EOF
[Unit]
Description=Docker remote access socket
[Socket]
ListenStream=2375
BindIPv6Only=both
Service=docker.service
[Install]
WantedBy=sockets.target
EOF
# Start and enable the docker service.
for sock in docker.socket docker-tcp.socket; do
systemctl start $sock
systemctl enable $sock
done
&lt;/code>&lt;/pre>
&lt;p>This takes care of making sure our packages are current, installing
Docker, and arranging for it to listen on a tcp socket. For that last
bit, we&amp;rsquo;re creating a new &lt;code>systemd&lt;/code> socket file
(&lt;code>/etc/systemd/system/docker-tcp.socket&lt;/code>), which means that &lt;code>systemd&lt;/code>
will actually open the socket for listening and start &lt;code>docker&lt;/code> if
necessary when a client connects.&lt;/p>
&lt;h2 id="templates-synchronizing-resources">Templates: Synchronizing resources&lt;/h2>
&lt;p>In our Heat template, we are starting a Nova server that will run
Docker, and then we are instantiating one or more Docker containers
that will run on this server. This means that timing is suddenly very
important. If we use the &lt;code>user_data&lt;/code> script as presented in the
previous section, we would probably end up with an error like this in
our &lt;code>heat-engine.log&lt;/code>:&lt;/p>
&lt;pre>&lt;code>2014-08-29 17:10:37.598 15525 TRACE heat.engine.resource ConnectionError:
HTTPConnectionPool(host='192.168.200.11', port=2375): Max retries exceeded
with url: /v1.12/containers/create (Caused by &amp;lt;class 'socket.error'&amp;gt;:
[Errno 113] EHOSTUNREACH)
&lt;/code>&lt;/pre>
&lt;p>This happens because it takes &lt;em>time&lt;/em> to install packages. Absent any
dependencies, Heat creates resources in parallel, so Heat is happily
trying to spawn our Docker containers when our server is still
fetching the Docker package.&lt;/p>
&lt;p>Heat does have a &lt;code>depends_on&lt;/code> property that can be applied to
resources. For example, if we have:&lt;/p>
&lt;pre>&lt;code>docker_server:
type: &amp;quot;OS::Nova::Server&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>We can make a Docker container depend on that resource:&lt;/p>
&lt;pre>&lt;code>docker_container_mysql:
type: &amp;quot;DockerInc::Docker::Container&amp;quot;
depends_on:
- docker_server
&lt;/code>&lt;/pre>
&lt;p>Looks good, but this does not, in fact, help us. From Heat&amp;rsquo;s
perspective, the dependency is satisfied as soon as the Nova server
&lt;em>boots&lt;/em>, so really we&amp;rsquo;re back where we started.&lt;/p>
&lt;p>The Heat solution to this is the &lt;code>AWS::CloudFormation::WaitCondition&lt;/code>
resource (and its boon companion, the and
&lt;code>AWS::CloudFormation::WaitConditionHandle&lt;/code> resource). A
&lt;code>WaitCondition&lt;/code> is a resource this is not &amp;ldquo;created&amp;rdquo; until it has
received an external signal. We define a wait condition like this:&lt;/p>
&lt;pre>&lt;code>docker_wait_handle:
type: &amp;quot;AWS::CloudFormation::WaitConditionHandle&amp;quot;
docker_wait_condition:
type: &amp;quot;AWS::CloudFormation::WaitCondition&amp;quot;
depends_on:
- docker_server
properties:
Handle:
get_resource: docker_wait_handle
Timeout: &amp;quot;6000&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>And then we make our container depend on the wait condition:&lt;/p>
&lt;pre>&lt;code>docker_container_mysql:
type: &amp;quot;DockerInc::Docker::Container&amp;quot;
depends_on:
- docker_wait_condition
&lt;/code>&lt;/pre>
&lt;p>With this in place, Heat will not attempt to create the Docker
container until we signal the wait condition resource. In order to do
that, we need to modify our &lt;code>user_data&lt;/code> script to embed the
notification URL generated by heat. We&amp;rsquo;ll use both the &lt;code>get_resource&lt;/code>
and &lt;code>str_replace&lt;/code> &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#intrinsic-functions">intrinsic function&lt;/a> in order to generate the appropriate
script:&lt;/p>
&lt;pre>&lt;code> user_data:
# We're using Heat's 'str_replace' function in order to
# substitute into this script the Heat-generated URL for
# signaling the docker_wait_condition resource.
str_replace:
template: |
#!/bin/sh
yum -y upgrade
# I have occasionally seen 'yum install' fail with errors
# trying to contact mirrors. Because it can be a pain to
# delete and re-create the stack, just loop here until it
# succeeds.
while :; do
yum -y install docker-io
[ -x /usr/bin/docker ] &amp;amp;&amp;amp; break
sleep 5
done
# Add a tcp socket for docker
cat &amp;gt; /etc/systemd/system/docker-tcp.socket &amp;lt;&amp;lt;EOF
[Unit]
Description=Docker remote access socket
[Socket]
ListenStream=2375
BindIPv6Only=both
Service=docker.service
[Install]
WantedBy=sockets.target
EOF
# Start and enable the docker service.
for sock in docker.socket docker-tcp.socket; do
systemctl start $sock
systemctl enable $sock
done
# Signal heat that we are finished settings things up.
cfn-signal -e0 --data 'OK' -r 'Setup complete' '$WAIT_HANDLE'
params:
&amp;quot;$WAIT_HANDLE&amp;quot;:
get_resource: docker_wait_handle
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>str_replace&lt;/code> function probably deserves a closer look; the
general format is:&lt;/p>
&lt;pre>&lt;code>str_replace:
template:
params:
&lt;/code>&lt;/pre>
&lt;p>Where &lt;code>template&lt;/code> is text content containing 0 or more things to be
replaced, and &lt;code>params&lt;/code> is a list of tokens to search for and replace
in the &lt;code>template&lt;/code>.&lt;/p>
&lt;p>We use &lt;code>str_replace&lt;/code> to substitute the token &lt;code>$WAIT_HANDLE&lt;/code> with the
result of calling &lt;code>get_resource&lt;/code> on our &lt;code>docker_wait_handle&lt;/code> resource.
This results in a URL that contains an EC2-style signed URL that will
deliver the necessary notification to Heat. In this example we&amp;rsquo;re
using the &lt;code>cfn-signal&lt;/code> tool, which is included in the Fedora cloud
images, but you could accomplish the same thing with &lt;code>curl&lt;/code>:&lt;/p>
&lt;pre>&lt;code>curl -X PUT -H 'Content-Type: application/json' \
--data-binary '{&amp;quot;Status&amp;quot;: &amp;quot;SUCCESS&amp;quot;,
&amp;quot;Reason&amp;quot;: &amp;quot;Setup complete&amp;quot;,
&amp;quot;Data&amp;quot;: &amp;quot;OK&amp;quot;, &amp;quot;UniqueId&amp;quot;: &amp;quot;00000&amp;quot;}' \
&amp;quot;$WAIT_HANDLE&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>You need to have correctly configured Heat in order for this to work;
I&amp;rsquo;ve written a short &lt;a href="https://blog.oddbit.com/post/2014-08-30-using-wait-conditions-with-hea/">companion article&lt;/a> that contains a checklist
and pointers to additional documentation to help work around some
common issues.&lt;/p>
&lt;h2 id="templates-defining-docker-containers">Templates: Defining Docker containers&lt;/h2>
&lt;p>&lt;strong>UPDATE&lt;/strong>: I have generated some &lt;a href="https://blog.oddbit.com/post/2014-08-30-docker-contain-doc/">annotated documentation for the
Docker plugin&lt;/a>.&lt;/p>
&lt;p>Now that we have arranged for Heat to wait for the server to finish
configuration before starting Docker contains, how do we create a
container? As Scott Lowe noticed in his &lt;a href="http://blog.scottlowe.org/2014/08/22/a-heat-template-for-docker-containers/">blog post about Heat and
Docker&lt;/a>, there is very little documentation available out there
for the Docker plugin (something I am trying to remedy with this blog
post!). Things are not quite as bleak as you might think, because
Heat resources are to a certain extent self-documenting. If you run:&lt;/p>
&lt;pre>&lt;code>$ heat resource-template DockerInc::Docker::Container
&lt;/code>&lt;/pre>
&lt;p>You will get a complete description of the attributes and properties
available in the named resource. The &lt;code>parameters&lt;/code> section is probably
the most descriptive:&lt;/p>
&lt;pre>&lt;code>parameters:
cmd:
Default: []
Description: Command to run after spawning the container.
Type: CommaDelimitedList
dns: {Description: Set custom dns servers., Type: CommaDelimitedList}
docker_endpoint: {Description: Docker daemon endpoint (by default the local docker
daemon will be used)., Type: String}
env: {Description: Set environment variables., Type: CommaDelimitedList}
hostname: {Default: '', Description: Hostname of the container., Type: String}
image: {Description: Image name., Type: String}
links: {Description: Links to other containers., Type: Json}
memory: {Default: 0, Description: Memory limit (Bytes)., Type: Number}
name: {Description: Name of the container., Type: String}
open_stdin:
AllowedValues: ['True', 'true', 'False', 'false']
Default: false
Description: Open stdin.
Type: String
port_bindings: {Description: TCP/UDP ports bindings., Type: Json}
port_specs: {Description: TCP/UDP ports mapping., Type: CommaDelimitedList}
privileged:
AllowedValues: ['True', 'true', 'False', 'false']
Default: false
Description: Enable extended privileges.
Type: String
stdin_once:
AllowedValues: ['True', 'true', 'False', 'false']
Default: false
Description: If true, close stdin after the 1 attached client disconnects.
Type: String
tty:
AllowedValues: ['True', 'true', 'False', 'false']
Default: false
Description: Allocate a pseudo-tty.
Type: String
user: {Default: '', Description: Username or UID., Type: String}
volumes:
Default: {}
Description: Create a bind mount.
Type: Json
volumes_from: {Default: '', Description: Mount all specified volumes., Type: String}
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>port_specs&lt;/code> and &lt;code>port_bindings&lt;/code> parameters require a little
additional explanation.&lt;/p>
&lt;p>The &lt;code>port_specs&lt;/code> parameter is a list of (TCP) ports that will be
&amp;ldquo;exposed&amp;rdquo; by the container (similar to the &lt;code>EXPOSE&lt;/code> directive in a
Dockerfile). This corresponds to the &lt;code>PortSpecs&lt;/code> argument in the the
&lt;a href="https://docs.docker.com/reference/api/docker_remote_api_v1.14/#create-a-container">/containers/create&lt;/a> call of the &lt;a href="https://docs.docker.com/reference/api/docker_remote_api/">Docker remote API&lt;/a>.
For example:&lt;/p>
&lt;pre>&lt;code>port_specs:
- 3306
- 53/udp
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>port_bindings&lt;/code> parameter is a mapping that allows you to bind
host ports to ports in the container, similar to the &lt;code>-p&lt;/code> argument to
&lt;code>docker run&lt;/code>. This corresponds to the
&lt;a href="https://docs.docker.com/reference/api/docker_remote_api_v1.14/#start-a-container">/containers/(id)/start&lt;/a> call in the &lt;a href="https://docs.docker.com/reference/api/docker_remote_api/">Docker remote API&lt;/a>.
In the mappings, the key (left-hand side) is the &lt;em>container&lt;/em> port, and
the value (right-hand side) is the &lt;em>host&lt;/em> port.&lt;/p>
&lt;p>For example, to bind container port 3306 to host port 3306:&lt;/p>
&lt;pre>&lt;code>port_bindings:
3306: 3306
&lt;/code>&lt;/pre>
&lt;p>To bind port 9090 in a container to port 80 on the host:&lt;/p>
&lt;pre>&lt;code>port_bindings:
9090: 80
&lt;/code>&lt;/pre>
&lt;p>And in theory, this should also work for UDP ports (but in practice
there is an issue between the Docker plugin and the &lt;code>docker-py&lt;/code> Python
module which makes it impossible to expose UDP ports via &lt;code>port_specs&lt;/code>;
this is fixed in
&lt;a href="https://github.com/docker/docker-py/pull/310" class="pull-request">#310&lt;/a>
on GitHub).&lt;/p>
&lt;pre>&lt;code>port_bindings:
53/udp: 5300
&lt;/code>&lt;/pre>
&lt;p>With all of this in mind, we can create a container resource
definition:&lt;/p>
&lt;pre>&lt;code>docker_dbserver:
type: &amp;quot;DockerInc::Docker::Container&amp;quot;
# here's where we set the dependency on the WaitCondition
# resource we mentioned earlier.
depends_on:
- docker_wait_condition
properties:
docker_endpoint:
str_replace:
template: &amp;quot;tcp://$HOST:2375&amp;quot;
params:
&amp;quot;$HOST&amp;quot;:
get_attr:
- docker_server_floating
- floating_ip_address
image: mysql
env:
# The official MySQL docker image expect the database root
# password to be provided in the MYSQL_ROOT_PASSWORD
# environment variable.
- str_replace:
template: MYSQL_ROOT_PASSWORD=$PASSWORD
params:
&amp;quot;$PASSWORD&amp;quot;:
get_param:
mysql_root_password
port_specs:
- 3306
port_bindings:
3306: 3306
&lt;/code>&lt;/pre>
&lt;p>Take a close look at how we&amp;rsquo;re setting the &lt;code>docker_endpoint&lt;/code> property:&lt;/p>
&lt;pre>&lt;code>docker_endpoint:
str_replace:
template: &amp;quot;tcp://$HOST:2375&amp;quot;
params:
&amp;quot;$HOST&amp;quot;:
get_attr:
- docker_server_floating
- floating_ip_address
&lt;/code>&lt;/pre>
&lt;p>This uses the &lt;code>get_attr&lt;/code> function to get the &lt;code>floating_ip_address&lt;/code>
attribute from the &lt;code>docker_server_floating&lt;/code> resource, which you can
find in the &lt;a href="https://github.com/larsks/heat-docker-example">complete template&lt;/a>. We take the return value from that
function and use &lt;code>str_replace&lt;/code> to substitute that into the
&lt;code>docker_endpoint&lt;/code> URL.&lt;/p>
&lt;h2 id="the-pudding">The pudding&lt;/h2>
&lt;p>Using the &lt;a href="https://github.com/larsks/heat-docker-example">complete template&lt;/a> with an appropriate local environment
file, I can launch this stack by runnign:&lt;/p>
&lt;pre>&lt;code>$ heat stack-create -f docker-server.yml -e local.env docker
&lt;/code>&lt;/pre>
&lt;p>And after a while, I can run&lt;/p>
&lt;pre>&lt;code>$ heat stack-list
&lt;/code>&lt;/pre>
&lt;p>And see that the stack has been created successfully:&lt;/p>
&lt;pre>&lt;code>+--------------------------------------+------------+-----------------+----------------------+
| id | stack_name | stack_status | creation_time |
+--------------------------------------+------------+-----------------+----------------------+
| c0fd793e-a1f7-4b35-afa9-12ba1005925a | docker | CREATE_COMPLETE | 2014-08-31T03:01:14Z |
+--------------------------------------+------------+-----------------+----------------------+
&lt;/code>&lt;/pre>
&lt;p>And I can ask for status information on the individual resources in
the stack:&lt;/p>
&lt;pre>&lt;code>$ heat resource-list docker
+------------------------+------------------------------------------+-----------------+
| resource_name | resource_type | resource_status |
+------------------------+------------------------------------------+-----------------+
| fixed_network | OS::Neutron::Net | CREATE_COMPLETE |
| secgroup_db | OS::Neutron::SecurityGroup | CREATE_COMPLETE |
| secgroup_docker | OS::Neutron::SecurityGroup | CREATE_COMPLETE |
| secgroup_webserver | OS::Neutron::SecurityGroup | CREATE_COMPLETE |
| docker_wait_handle | AWS::CloudFormation::WaitConditionHandle | CREATE_COMPLETE |
| extrouter | OS::Neutron::Router | CREATE_COMPLETE |
| fixed_subnet | OS::Neutron::Subnet | CREATE_COMPLETE |
| secgroup_common | OS::Neutron::SecurityGroup | CREATE_COMPLETE |
| docker_server_eth0 | OS::Neutron::Port | CREATE_COMPLETE |
| extrouter_inside | OS::Neutron::RouterInterface | CREATE_COMPLETE |
| docker_server | OS::Nova::Server | CREATE_COMPLETE |
| docker_server_floating | OS::Neutron::FloatingIP | CREATE_COMPLETE |
| docker_wait_condition | AWS::CloudFormation::WaitCondition | CREATE_COMPLETE |
| docker_webserver | DockerInc::Docker::Container | CREATE_COMPLETE |
| docker_dbserver | DockerInc::Docker::Container | CREATE_COMPLETE |
+------------------------+------------------------------------------+-----------------+
&lt;/code>&lt;/pre>
&lt;p>I can run &lt;code>nova list&lt;/code> and see information about my running Nova
server:&lt;/p>
&lt;pre>&lt;code>+--------...+-----------------...+------------------------------------------------------------+
| ID ...| Name ...| Networks |
+--------...+-----------------...+------------------------------------------------------------+
| 301c5ec...| docker-docker_se...| docker-fixed_network-whp3fxhohkxk=10.0.0.2, 192.168.200.46 |
+--------...+-----------------...+------------------------------------------------------------+
&lt;/code>&lt;/pre>
&lt;p>I can point a Docker client at the remote address and see the running
containers:&lt;/p>
&lt;pre>&lt;code>$ docker-1.2 -H tcp://192.168.200.46:2375 ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
f2388c871b20 mysql:5 /entrypoint.sh mysql 5 minutes ago Up 5 minutes 0.0.0.0:3306-&amp;gt;3306/tcp grave_almeida
9596cbe51291 larsks/simpleweb:latest /bin/sh -c '/usr/sbi 11 minutes ago Up 11 minutes 0.0.0.0:80-&amp;gt;80/tcp hungry_tesla
&lt;/code>&lt;/pre>
&lt;p>And I can point a &lt;code>mysql&lt;/code> client at the remote address and access the
database server:&lt;/p>
&lt;pre>&lt;code>$ mysql -h 192.168.200.46 -u root -psecret mysql
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
[...]
MySQL [mysql]&amp;gt;
&lt;/code>&lt;/pre>
&lt;h2 id="when-things-go-wrong">When things go wrong&lt;/h2>
&lt;p>Your &lt;code>heat-engine&lt;/code> log, generally &lt;code>/var/log/heat/engine.log&lt;/code>, is going
to be your best source of information if things go wrong. The &lt;code>heat stack-show&lt;/code> command will generally provide useful fault information if
your stack ends up in the &lt;code>CREATE_FAILED&lt;/code> (or &lt;code>DELETE_FAILED&lt;/code>) state.&lt;/p></content></item><item><title>Using wait conditions with Heat</title><link>https://blog.oddbit.com/post/2014-08-30-using-wait-conditions-with-hea/</link><pubDate>Sat, 30 Aug 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-08-30-using-wait-conditions-with-hea/</guid><description>&lt;p>This post accompanies my &lt;a href="https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/">article on the Docker plugin for
Heat&lt;/a>.&lt;/p>
&lt;p>In order for &lt;code>WaitCondition&lt;/code> resources to operate correctly in Heat, you
will need to make sure that that you have:&lt;/p>
&lt;ul>
&lt;li>Created the necessary Heat domain and administrative user in
Keystone,&lt;/li>
&lt;li>Configured appropriate values in &lt;code>heat.conf&lt;/code> for
&lt;code>stack_user_domain&lt;/code>, &lt;code>stack_domain_admin&lt;/code>, and
&lt;code>stack_domain_admin_password&lt;/code>.&lt;/li>
&lt;li>Configured an appropriate value in &lt;code>heat.conf&lt;/code> for
&lt;code>heat_waitcondition_server_url&lt;/code>. On a single-system install this
will often be pointed by default at &lt;code>127.0.0.1&lt;/code>, which, hopefully for
obvious reasons, won&amp;rsquo;t be of any use to your Nova servers.&lt;/li>
&lt;li>Enabled the &lt;code>heat-api-cfn&lt;/code> service,&lt;/li>
&lt;li>Configured your firewall to permit access to the CFN service (which
runs on port 8000).&lt;/li>
&lt;/ul>
&lt;p>Steve Hardy has a blog post on &lt;a href="http://hardysteven.blogspot.co.uk/2014/04/heat-auth-model-updates-part-2-stack.html">stack domain users&lt;/a> that goes into
detail on configuring authentication for Heat and Keystone.&lt;/p></description><content>&lt;p>This post accompanies my &lt;a href="https://blog.oddbit.com/post/2014-08-30-docker-plugin-for-openstack-he/">article on the Docker plugin for
Heat&lt;/a>.&lt;/p>
&lt;p>In order for &lt;code>WaitCondition&lt;/code> resources to operate correctly in Heat, you
will need to make sure that that you have:&lt;/p>
&lt;ul>
&lt;li>Created the necessary Heat domain and administrative user in
Keystone,&lt;/li>
&lt;li>Configured appropriate values in &lt;code>heat.conf&lt;/code> for
&lt;code>stack_user_domain&lt;/code>, &lt;code>stack_domain_admin&lt;/code>, and
&lt;code>stack_domain_admin_password&lt;/code>.&lt;/li>
&lt;li>Configured an appropriate value in &lt;code>heat.conf&lt;/code> for
&lt;code>heat_waitcondition_server_url&lt;/code>. On a single-system install this
will often be pointed by default at &lt;code>127.0.0.1&lt;/code>, which, hopefully for
obvious reasons, won&amp;rsquo;t be of any use to your Nova servers.&lt;/li>
&lt;li>Enabled the &lt;code>heat-api-cfn&lt;/code> service,&lt;/li>
&lt;li>Configured your firewall to permit access to the CFN service (which
runs on port 8000).&lt;/li>
&lt;/ul>
&lt;p>Steve Hardy has a blog post on &lt;a href="http://hardysteven.blogspot.co.uk/2014/04/heat-auth-model-updates-part-2-stack.html">stack domain users&lt;/a> that goes into
detail on configuring authentication for Heat and Keystone.&lt;/p></content></item><item><title>An introduction to OpenStack Heat</title><link>https://blog.oddbit.com/post/2013-12-06-an-introduction-to-openstack-h/</link><pubDate>Fri, 06 Dec 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-12-06-an-introduction-to-openstack-h/</guid><description>&lt;p>&lt;a href="https://wiki.openstack.org/wiki/Heat">Heat&lt;/a> is a template-based orchestration mechanism for use with
OpenStack. With Heat, you can deploy collections of resources &amp;ndash;
networks, servers, storage, and more &amp;ndash; all from a single,
parameterized template.&lt;/p>
&lt;p>In this article I will introduce Heat templates and the &lt;code>heat&lt;/code> command
line client.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="writing-templates">Writing templates&lt;/h2>
&lt;p>Because Heat began life as an analog of AWS &lt;a href="http://aws.amazon.com/cloudformation/">CloudFormation&lt;/a>, it
supports the template formats used by the CloudFormation (CFN) tools.
It also supports its own native template format, called HOT (&amp;ldquo;Heat
Orchestration Templates&amp;rdquo;). In this article I will be using the HOT
template syntax, which is fully specified on &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html">the OpenStack
website&lt;/a>.&lt;/p></description><content>&lt;p>&lt;a href="https://wiki.openstack.org/wiki/Heat">Heat&lt;/a> is a template-based orchestration mechanism for use with
OpenStack. With Heat, you can deploy collections of resources &amp;ndash;
networks, servers, storage, and more &amp;ndash; all from a single,
parameterized template.&lt;/p>
&lt;p>In this article I will introduce Heat templates and the &lt;code>heat&lt;/code> command
line client.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="writing-templates">Writing templates&lt;/h2>
&lt;p>Because Heat began life as an analog of AWS &lt;a href="http://aws.amazon.com/cloudformation/">CloudFormation&lt;/a>, it
supports the template formats used by the CloudFormation (CFN) tools.
It also supports its own native template format, called HOT (&amp;ldquo;Heat
Orchestration Templates&amp;rdquo;). In this article I will be using the HOT
template syntax, which is fully specified on &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html">the OpenStack
website&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>NB: Heat is under active development, and there are a variety of
discussions going on right now regarding the HOT specification. I
will try to keep this post up-to-date as the spec evolves.&lt;/p>
&lt;/blockquote>
&lt;p>A HOT template is written using &lt;a href="http://en.wikipedia.org/wiki/YAML">YAML&lt;/a> syntax and has three major
sections:&lt;/p>
&lt;ul>
&lt;li>&lt;em>parameters&lt;/em> &amp;ndash; these are input parameters that you provide when you
deploy from the template.&lt;/li>
&lt;li>&lt;em>resources&lt;/em> &amp;ndash; these are things created by the template.&lt;/li>
&lt;li>&lt;em>outputs&lt;/em> &amp;ndash; these are output parameters generated by Heat and
available to you via the API.&lt;/li>
&lt;/ul>
&lt;h3 id="parameters">Parameters&lt;/h3>
&lt;p>The &lt;code>parameters&lt;/code> section defines the list of available parameters.
For each parameter, you define a data type, an optional default value
(that will be used if you do not otherwise specify a value for the
parameter), an optional description, constraints to validate the data,
and so forth. The definition from &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html">the spec&lt;/a> looks like this:&lt;/p>
&lt;pre>&lt;code>parameters:
&amp;lt;param name&amp;gt;:
type: &amp;lt;string | number | json | comma_delimited_list&amp;gt;
description: &amp;lt;description of the parameter&amp;gt;
default: &amp;lt;default value for parameter&amp;gt;
hidden: &amp;lt;true | false&amp;gt;
constraints:
&amp;lt;parameter constraints&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>A simple example might look like this:&lt;/p>
&lt;pre>&lt;code>parameters:
flavor:
type: string
default: m1.small
constraints:
- allowed_values: [m1.nano, m1.tiny, m1.small, m1.large]
description: Value must be one of 'm1.tiny', 'm1.small' or 'm1.large'
&lt;/code>&lt;/pre>
&lt;p>This defines one parameter named &lt;code>flavor&lt;/code> with a default value of
&lt;code>m1.small&lt;/code>. Any value passed in when you deploy from this template
must match of one the values in the &lt;code>allowed_values&lt;/code> constraint.&lt;/p>
&lt;h3 id="resources">Resources&lt;/h3>
&lt;p>The &lt;code>resources&lt;/code> section of your template defines the items that will
be created by Heat when you deploy from your template. This may
include storage, networks, ports, routers, security groups, firewall
rules, or any other of the &lt;a href="http://docs.openstack.org/developer/heat/template_guide/openstack.html">many available resources&lt;/a>.&lt;/p>
&lt;p>The definition of this section from &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html">the spec&lt;/a> looks like
this:&lt;/p>
&lt;pre>&lt;code>resources:
&amp;lt;resource ID&amp;gt;:
type: &amp;lt;resource type&amp;gt;
properties:
&amp;lt;property name&amp;gt;: &amp;lt;property value&amp;gt;
# more resource specific metadata
&lt;/code>&lt;/pre>
&lt;p>Here&amp;rsquo;s a simple example that would create a single server:&lt;/p>
&lt;pre>&lt;code>resources:
instance0:
type: OS::Nova::Server
properties:
name: instance0
image: cirros
flavor: m1.tiny
key_name: mykey
&lt;/code>&lt;/pre>
&lt;p>The complete list of resources and their available properties can be
found &lt;a href="http://docs.openstack.org/developer/heat/template_guide/openstack.html">in the documentation&lt;/a>.&lt;/p>
&lt;p>You&amp;rsquo;ll notice that the above example is static: it will always result
in an instance using the &lt;code>cirros&lt;/code> image and the &lt;code>m1.tiny&lt;/code> flavor.
This isn&amp;rsquo;t terribly useful, so let&amp;rsquo;s redefine this example assuming
that we have available the &lt;code>parameter&lt;/code> section from the previous
example:&lt;/p>
&lt;pre>&lt;code>resources:
instance0:
type: OS::Nova::Server
properties:
name: instance0
image: cirros
flavor: {get_param: flavor}
key_name: mykey
&lt;/code>&lt;/pre>
&lt;p>Here we are using the &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#get-param">get_param&lt;/a> &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#intrinsic-functions">intrinsic function&lt;/a> to
retrieve an insert the value of the &lt;code>flavor&lt;/code> parameter.&lt;/p>
&lt;h3 id="outputs">Outputs&lt;/h3>
&lt;p>The &lt;code>outputs&lt;/code> section of your template defines parameters that will be
available to you (via the API or command line client) after your stack
has been deployed. This may include things like this ip addresses
assigned to your instances. The &lt;code>outputs&lt;/code> section definition is:&lt;/p>
&lt;pre>&lt;code>outputs:
&amp;lt;parameter name&amp;gt;:
description: &amp;lt;description&amp;gt;
value: &amp;lt;parameter value&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>In order to make the &lt;code>outputs&lt;/code> section useful, we&amp;rsquo;ll need another
template function, &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#get-attr">get_attr&lt;/a>. Where &lt;code>get_param&lt;/code> accesses values from
your &lt;code>parameters&lt;/code> section, &lt;code>get_attr&lt;/code> accesses attributes of your
resources. For example:&lt;/p>
&lt;pre>&lt;code>outputs:
instance_ip:
value: {get_attr: [instance0, first_address]}
&lt;/code>&lt;/pre>
&lt;p>You will again want to refer to the &lt;a href="http://docs.openstack.org/developer/heat/template_guide/openstack.html">list of resource types&lt;/a>
for a list of available attributes.&lt;/p>
&lt;h3 id="putting-it-all-together">Putting it all together&lt;/h3>
&lt;p>Using the above information, let&amp;rsquo;s put together a slightly more
complete template. This example will:&lt;/p>
&lt;ul>
&lt;li>Deploy a single instance&lt;/li>
&lt;li>Assign it a floating ip address&lt;/li>
&lt;li>Ensure ssh access via an ssh key published to Nova&lt;/li>
&lt;/ul>
&lt;p>We&amp;rsquo;ll get the flavor name, image name, key name, and network
information from user-provided parameters.&lt;/p>
&lt;p>Since this is a complete example, we need to add the
&lt;code>heat_template_version&lt;/code> key to our template:&lt;/p>
&lt;pre>&lt;code>heat_template_version: 2013-05-23
&lt;/code>&lt;/pre>
&lt;p>And a description provides useful documentation:&lt;/p>
&lt;pre>&lt;code>description: &amp;gt;
A simple HOT template for demonstrating Heat.
&lt;/code>&lt;/pre>
&lt;p>We define parameters for the key name, flavor, and image, as well as
network ids for address provisioning:&lt;/p>
&lt;pre>&lt;code>parameters:
key_name:
type: string
default: lars
description: Name of an existing key pair to use for the instance
flavor:
type: string
description: Instance type for the instance to be created
default: m1.small
constraints:
- allowed_values: [m1.nano, m1.tiny, m1.small, m1.large]
description: Value must be one of 'm1.tiny', 'm1.small' or 'm1.large'
image:
type: string
default: cirros
description: ID or name of the image to use for the instance
private_net_id:
type: string
description: Private network id
private_subnet_id:
type: string
description: Private subnet id
public_net_id:
type: string
description: Public network id
&lt;/code>&lt;/pre>
&lt;p>In the &lt;code>resources&lt;/code> section, we define a single instance of
&lt;code>OS::Nova::Server&lt;/code>, attach to it an instance of &lt;code>OS::Neutron::Port&lt;/code>,
and attach to that port an instance of &lt;code>OS::Neutron::FloatingIP&lt;/code>.
Note that use of the &lt;a href="http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#get-resource">get_resource&lt;/a> function here to refer to a
resource defined elsewhere in the template:&lt;/p>
&lt;pre>&lt;code>resources:
instance0:
type: OS::Nova::Server
properties:
name: instance0
image: { get_param: image }
flavor: { get_param: flavor }
key_name: { get_param: key_name }
networks:
- port: { get_resource: instance0_port0 }
instance0_port0:
type: OS::Neutron::Port
properties:
network_id: { get_param: private_net_id }
security_groups:
- default
fixed_ips:
- subnet_id: { get_param: private_subnet_id }
instance0_public:
type: OS::Neutron::FloatingIP
properties:
floating_network_id: { get_param: public_net_id }
port_id: { get_resource: instance0_port0 }
&lt;/code>&lt;/pre>
&lt;p>As outputs we provide the fixed and floating ip addresses assigned to
our instance:&lt;/p>
&lt;pre>&lt;code>outputs:
instance0_private_ip:
description: IP address of instance0 in private network
value: { get_attr: [ instance0, first_address ] }
instance0_public_ip:
description: Floating IP address of instance0 in public network
value: { get_attr: [ instance0_public, floating_ip_address ] }
&lt;/code>&lt;/pre>
&lt;h2 id="filling-in-the-blanks">Filling in the blanks&lt;/h2>
&lt;p>Now that we have a complete template, what do we do with it?&lt;/p>
&lt;p>When you deploy from a template, you need to provide values for any
parameters required by the template (and you may also want to override
default values). You can do this using the &lt;code>-P&lt;/code> (aka &lt;code>--parameter&lt;/code>)
command line option, which takes a semicolon-delimited list of
&lt;code>name=value&lt;/code> pairs:&lt;/p>
&lt;pre>&lt;code>heat stack-create -P 'param1=value1;param2=value2' ...
&lt;/code>&lt;/pre>
&lt;p>While this works, it&amp;rsquo;s not terribly useful, especially as the
parameter list grows long. You can also provide parameters via an
&lt;a href="https://wiki.openstack.org/wiki/Heat/Environments">environment file&lt;/a>, which a YAML configuration file containing a
&lt;code>parameters&lt;/code> key (you can use environment files for other things, too,
but here we&amp;rsquo;re going to focus on their use for template parameters).
A sample file, equivalent to arguments to &lt;code>-P&lt;/code> in the above command
line, might look like:&lt;/p>
&lt;pre>&lt;code>parameters:
param1: value1
param2: value2
&lt;/code>&lt;/pre>
&lt;p>An environment file appropriate to our example template from the
previous section might look like this:&lt;/p>
&lt;pre>&lt;code>parameters:
image: fedora-19-x86_64
flavor: m1.small
private_net_id: 99ab8ebf-ad2f-4a4b-9890-fee37cea4254
private_subnet_id: ed8ad5f5-4c47-4204-9ca3-1b3bc4de286d
public_net_id: 7e687cc3-8155-4ec2-bd11-ba741ecbf4f0
&lt;/code>&lt;/pre>
&lt;p>You would, of course, need to replace the network ids with ones
appropriate to your environment.&lt;/p>
&lt;h2 id="command-line-client">Command line client&lt;/h2>
&lt;p>With the template in a file called &lt;code>template.yml&lt;/code> and the parameters
in a file called &lt;code>environment.yml&lt;/code>, we could deploy an instance like
this:&lt;/p>
&lt;pre>&lt;code>heat stack-create -f template.yml \
-e environment.yml mystack
&lt;/code>&lt;/pre>
&lt;p>This would, assuming no errors, create a stack called &lt;code>mystack&lt;/code>. You
can view the status of your stacks with the &lt;code>stack-list&lt;/code> subcommand:&lt;/p>
&lt;pre>&lt;code>$ heat stack-list
+-------+------------+-----------------+----------------------+
| id | stack_name | stack_status | creation_time |
+-------+------------+-----------------+----------------------+
| 0...6 | mystack | CREATE_COMPLETE | 2013-12-06T21:37:32Z |
+-------+------------+-----------------+----------------------+
&lt;/code>&lt;/pre>
&lt;p>You can view detailed information about your stack &amp;ndash; including the
values of your outputs &amp;ndash; using the &lt;code>stack-show&lt;/code> subcommand:&lt;/p>
&lt;pre>&lt;code>$ heat stack-show mystack
&lt;/code>&lt;/pre>
&lt;p>(The output is a little too verbose to include here.)&lt;/p>
&lt;p>If you want more convenient access to the values of your outputs,
you&amp;rsquo;re going to have to either make direct use of the Heat &lt;a href="http://api.openstack.org/api-ref-orchestration.html">REST
API&lt;/a>, or wait for my &lt;a href="https://review.openstack.org/#/c/60591/">proposed change&lt;/a> to the
&lt;a href="https://launchpad.net/python-heatclient">python-heatclient&lt;/a> package, which will add the &lt;code>output-list&lt;/code> and
&lt;code>output-get&lt;/code> subcommands:&lt;/p>
&lt;pre>&lt;code>$ heat output-list mystack
instance0_private_ip
instance0_public_ip
$ heat output-get mystack instance0_public_ip
192.168.122.203
&lt;/code>&lt;/pre>
&lt;h2 id="working-with-neutron">Working with Neutron&lt;/h2>
&lt;p>If you are using Heat in an environment that uses &lt;a href="https://wiki.openstack.org/wiki/Neutron">Neutron&lt;/a> for
networking you may need to take a few additional steps. By default,
your virtual instances will not be associated with &lt;em>any&lt;/em> security
groups, which means that they will have neither outbound or inbound
network connectivity. This is in contrast to instances started using
the &lt;code>nova boot&lt;/code> command, which will automatically be members of the
&lt;code>default&lt;/code> security group.&lt;/p>
&lt;p>In order to provide your instances with appropriate network
connectivity, you will need to associate each &lt;code>OS::Neutron::Port&lt;/code>
resource in your template with one or more security groups. For
example, the following configuration snippet would create a port
&lt;code>instance0_port0&lt;/code> and assign it to the &lt;code>default&lt;/code> and &lt;code>webserver&lt;/code>
security groups:&lt;/p>
&lt;pre>&lt;code>instance0_port0:
type: OS::Neutron::Port
properties:
network_id: { get_param: private_net_id }
security_groups:
- default
- webserver
fixed_ips:
- subnet_id: { get_param: private_subnet_id }
&lt;/code>&lt;/pre>
&lt;p>For this to work, you will need to be running a (very) recent version
of Heat. Until commit &lt;a href="https://github.com/openstack/heat/commit/902154c">902154c&lt;/a>, Heat was unable to look up Neutron security
groups by name. It worked fine if you specified security groups by
UUID:&lt;/p>
&lt;pre>&lt;code>security_groups:
- 4296f3ff-9dc0-4b0b-a633-c30eacc8493d
- 8c49cd42-7c42-4a1f-af1d-492a0687fc12
&lt;/code>&lt;/pre>
&lt;h2 id="see-also">See also&lt;/h2>
&lt;ul>
&lt;li>The Heat project maintains a &lt;a href="https://github.com/openstack/heat-templates">repository of example
templates&lt;/a>.&lt;/li>
&lt;/ul></content></item></channel></rss>