<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Puppet on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/puppet/</link><description>Recent content in Puppet on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 10:58:10 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/puppet/rss.xml" rel="self" type="application/rss+xml"/><item><title>Building Docker images with Puppet</title><link>https://blog.oddbit.com/post/2014-10-22-building-docker-images-with-pu/</link><pubDate>Wed, 22 Oct 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-10-22-building-docker-images-with-pu/</guid><description>&lt;p&gt;I like &lt;a href="http://docker.com/"&gt;Docker&lt;/a&gt;, but I&amp;rsquo;m not a huge fan of using shell scripts for
complex system configuration&amp;hellip;and Dockerfiles are basically giant
shell scripts.&lt;/p&gt;
&lt;p&gt;I was curious whether or not it would be possible to use Puppet during
the &lt;code&gt;docker build&lt;/code&gt; process. As a test case, I used the
&lt;a href="https://github.com/saz/puppet-ssh"&gt;ssh&lt;/a&gt; module included in the openstack-puppet-modules package.&lt;/p&gt;
&lt;p&gt;I started with a manifest like this (in &lt;code&gt;puppet/node.pp&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class { 'ssh': }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And a Dockerfile like this:&lt;/p&gt;</description></item><item><title>Extending Puppet</title><link>https://blog.oddbit.com/post/2014-04-16-article-on-extending-puppet/</link><pubDate>Wed, 16 Apr 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-04-16-article-on-extending-puppet/</guid><description>&lt;p&gt;I wanted to learn about writing custom Puppet types and providers.
The official documentation is a little sparse, but I finally stumbled
upon the following series of articles by &lt;a href="http://garylarizza.com/"&gt;Gary Larizza&lt;/a&gt; that provide
a great deal of insight into the process and a bunch of example code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://garylarizza.com/blog/2013/11/25/fun-with-providers/"&gt;Fun With Puppet Providers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/"&gt;Who Abstracted My Ruby?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://garylarizza.com/blog/2013/12/15/seriously-what-is-this-provider-doing/"&gt;Seriously, What Is This Provider Doing?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>A quote about XMLRPC</title><link>https://blog.oddbit.com/post/2013-02-25-puppet-xmlrpc-quote/</link><pubDate>Mon, 25 Feb 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-02-25-puppet-xmlrpc-quote/</guid><description>&lt;p&gt;I&amp;rsquo;ve been reading up on Puppet 3 lately, and came across the
following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XMLRPC was the new hotness when development on Puppet started. Now,
XMLRPC is that horrible thing with the XML and the angle brackets and
the pain and sad.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;(from &lt;a href="http://somethingsinistral.net/blog/the-angry-guide-to-puppet-3/"&gt;http://somethingsinistral.net/blog/the-angry-guide-to-puppet-3/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&amp;hellip;which also accurately sums up my feelings when I come across yet
another piece of software where someone has decided that XML (or even
JSON) is a good user-facing configuration syntax.&lt;/p&gt;</description></item><item><title>Puppet, scope, and inheritance</title><link>https://blog.oddbit.com/post/2011-08-16-puppet-scope-and-inheritance/</link><pubDate>Tue, 16 Aug 2011 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2011-08-16-puppet-scope-and-inheritance/</guid><description>&lt;p&gt;I note this here because it wasn&amp;rsquo;t apparent to me from the Puppet documentation.&lt;/p&gt;
&lt;p&gt;If you have a Puppet class like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class foo {
 File { ensure =&amp;gt; file,
 mode =&amp;gt; 600,
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class bar {
 include foo

 file { '/tmp/myfile': }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then /tmp/myfile will not be created. But if instead you do this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class bar inherits foo {
 file { '/tmp/myfile': }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will be created with mode 0600. In other words, if you use inherits then definitions in the parent class are available in the scope of your subclass. If you include, then definitions in he included class are &amp;ldquo;below&amp;rdquo; the scope of the including class.&lt;/p&gt;</description></item></channel></rss>