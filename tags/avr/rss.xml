<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Avr on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/avr/</link><description>Recent content in Avr on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Mon, 11 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/avr/rss.xml" rel="self" type="application/rss+xml"/><item><title>In which I PEBKAC so you don't have to</title><link>https://blog.oddbit.com/post/2019-02-11-in-which-i-pebkac-so-you-dont-/</link><pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-02-11-in-which-i-pebkac-so-you-dont-/</guid><description>&lt;p>Say you have a simple bit of code:&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;util/delay.h&amp;gt;
#define LED_BUILTIN _BV(PORTB5)
int main(void)
{
DDRB |= LED_BUILTIN;
while (1)
{
PORTB |= LED_BUILTIN; // turn on led
_delay_ms(1000); // delay 1s
PORTB &amp;amp;= ~LED_BUILTIN; // turn off led
_delay_ms(1000); // delay 1s
}
}
&lt;/code>&lt;/pr</description><content>&lt;p>Say you have a simple bit of code:&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;util/delay.h&amp;gt;
#define LED_BUILTIN _BV(PORTB5)
int main(void)
{
DDRB |= LED_BUILTIN;
while (1)
{
PORTB |= LED_BUILTIN; // turn on led
_delay_ms(1000); // delay 1s
PORTB &amp;amp;= ~LED_BUILTIN; // turn off led
_delay_ms(1000); // delay 1s
}
}
&lt;/code>&lt;/pre>
&lt;p>You have a Makefile that compiles that into an object (&lt;code>.o&lt;/code>) file like this:&lt;/p>
&lt;pre>&lt;code>avr-gcc -mmcu=atmega328p -DF_CPU=16000000 -Os -c blink.c
&lt;/code>&lt;/pre>
&lt;p>If you were to forget to set the device type when compiling your &lt;code>.c&lt;/code> file into an object file (&lt;code>.o&lt;/code>), you would get a warning:&lt;/p>
&lt;pre>&lt;code>$ avr-gcc -DF_CPU=16000000 -Os -c blink.c
In file included from blink.c:1:0:
/usr/avr/include/avr/io.h:623:6: warning: #warning &amp;quot;device type not defined&amp;quot; [-Wcpp]
# warning &amp;quot;device type not defined&amp;quot;
^~~~~~~
&lt;/code>&lt;/pre>
&lt;p>But if you were to forget to set the device type when linking the final ELF binary, you would not be so lucky:&lt;/p>
&lt;pre>&lt;code>$ avr-gcc -o blink.elf blink.o
&amp;lt;...silence...&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>So you would, perhaps, be surprised when you flash this to your device and it doesn&amp;rsquo;t work. If you take a look at the assembly generated for the above command, it looks like this:&lt;/p>
&lt;pre>&lt;code>$ avr-objdump -d blink.elf
blink.elf: file format elf32-avr
Disassembly of section .text:
00000000 &amp;lt;main&amp;gt;:
0: 25 9a sbi 0x04, 5 ; 4
2: 2d 9a sbi 0x05, 5 ; 5
4: 2f e3 ldi r18, 0x3F ; 63
6: 8d e0 ldi r24, 0x0D ; 13
8: 93 e0 ldi r25, 0x03 ; 3
a: 21 50 subi r18, 0x01 ; 1
c: 80 40 sbci r24, 0x00 ; 0
e: 90 40 sbci r25, 0x00 ; 0
10: e1 f7 brne .-8 ; 0xa &amp;lt;__zero_reg__+0x9&amp;gt;
12: 00 c0 rjmp .+0 ; 0x14 &amp;lt;__zero_reg__+0x13&amp;gt;
14: 00 00 nop
16: 2d 98 cbi 0x05, 5 ; 5
18: 2f e3 ldi r18, 0x3F ; 63
1a: 8d e0 ldi r24, 0x0D ; 13
1c: 93 e0 ldi r25, 0x03 ; 3
1e: 21 50 subi r18, 0x01 ; 1
20: 80 40 sbci r24, 0x00 ; 0
22: 90 40 sbci r25, 0x00 ; 0
24: e1 f7 brne .-8 ; 0x1e &amp;lt;__zero_reg__+0x1d&amp;gt;
26: 00 c0 rjmp .+0 ; 0x28 &amp;lt;__zero_reg__+0x27&amp;gt;
28: 00 00 nop
2a: eb cf rjmp .-42 ; 0x2 &amp;lt;__zero_reg__+0x1&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>If you remember to include the device type:&lt;/p>
&lt;pre>&lt;code>$ avr-gcc -mmcu=atmega328p -o blink.elf blink.o
&lt;/code>&lt;/pre>
&lt;p>You instead get:&lt;/p>
&lt;pre>&lt;code>$ avr-objdump -d blink.elf
blink.elf: file format elf32-avr
Disassembly of section .text:
00000000 &amp;lt;__vectors&amp;gt;:
0: 0c 94 34 00 jmp 0x68 ; 0x68 &amp;lt;__ctors_end&amp;gt;
4: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
8: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
c: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
10: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
14: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
18: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
1c: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
20: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
24: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
28: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
2c: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
30: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
34: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
38: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
3c: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
40: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
44: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
48: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
4c: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
50: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
54: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
58: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
5c: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
60: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
64: 0c 94 3e 00 jmp 0x7c ; 0x7c &amp;lt;__bad_interrupt&amp;gt;
00000068 &amp;lt;__ctors_end&amp;gt;:
68: 11 24 eor r1, r1
6a: 1f be out 0x3f, r1 ; 63
6c: cf ef ldi r28, 0xFF ; 255
6e: d8 e0 ldi r29, 0x08 ; 8
70: de bf out 0x3e, r29 ; 62
72: cd bf out 0x3d, r28 ; 61
74: 0e 94 40 00 call 0x80 ; 0x80 &amp;lt;main&amp;gt;
78: 0c 94 56 00 jmp 0xac ; 0xac &amp;lt;_exit&amp;gt;
0000007c &amp;lt;__bad_interrupt&amp;gt;:
7c: 0c 94 00 00 jmp 0 ; 0x0 &amp;lt;__vectors&amp;gt;
00000080 &amp;lt;main&amp;gt;:
80: 25 9a sbi 0x04, 5 ; 4
82: 2d 9a sbi 0x05, 5 ; 5
84: 2f e3 ldi r18, 0x3F ; 63
86: 8d e0 ldi r24, 0x0D ; 13
88: 93 e0 ldi r25, 0x03 ; 3
8a: 21 50 subi r18, 0x01 ; 1
8c: 80 40 sbci r24, 0x00 ; 0
8e: 90 40 sbci r25, 0x00 ; 0
90: e1 f7 brne .-8 ; 0x8a &amp;lt;main+0xa&amp;gt;
92: 00 c0 rjmp .+0 ; 0x94 &amp;lt;main+0x14&amp;gt;
94: 00 00 nop
96: 2d 98 cbi 0x05, 5 ; 5
98: 2f e3 ldi r18, 0x3F ; 63
9a: 8d e0 ldi r24, 0x0D ; 13
9c: 93 e0 ldi r25, 0x03 ; 3
9e: 21 50 subi r18, 0x01 ; 1
a0: 80 40 sbci r24, 0x00 ; 0
a2: 90 40 sbci r25, 0x00 ; 0
a4: e1 f7 brne .-8 ; 0x9e &amp;lt;main+0x1e&amp;gt;
a6: 00 c0 rjmp .+0 ; 0xa8 &amp;lt;main+0x28&amp;gt;
a8: 00 00 nop
aa: eb cf rjmp .-42 ; 0x82 &amp;lt;main+0x2&amp;gt;
000000ac &amp;lt;_exit&amp;gt;:
ac: f8 94 cli
000000ae &amp;lt;__stop_program&amp;gt;:
ae: ff cf rjmp .-2 ; 0xae &amp;lt;__stop_program&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>You can see that this code includes things like the jump table, without which your code won&amp;rsquo;t run.&lt;/p>
&lt;p>The moral of this story is: don&amp;rsquo;t forget to set the device type.&lt;/p></content></item><item><title>ATOMIC_BLOCK magic in avr-libc</title><link>https://blog.oddbit.com/post/2019-02-01-atomicblock-magic-in-avrlibc/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-02-01-atomicblock-magic-in-avrlibc/</guid><description>&lt;p>The AVR C library, &lt;a href="https://www.nongnu.org/avr-libc/">avr-libc&lt;/a>, provide an &lt;code>ATOMIC_BLOCK&lt;/code> macro that you can use to wrap critical sections of your code to ensure that interrupts are disabled while the code executes. At high level, the &lt;code>ATOMIC_BLOCK&lt;/code> macro (when called using &lt;code>ATOMIC_FORCEON&lt;/code>) does something like this:&lt;/p>
&lt;pre>&lt;code>cli();
...your code here...
seti();
&lt;/code>&lt;/pre>
&lt;p>But it&amp;rsquo;s more than that. If you read &lt;a href="https://www.nongnu.org/avr-libc/user-manual/group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4">the documentation&lt;/a> for the macro, it says:&lt;/p></description><content>&lt;p>The AVR C library, &lt;a href="https://www.nongnu.org/avr-libc/">avr-libc&lt;/a>, provide an &lt;code>ATOMIC_BLOCK&lt;/code> macro that you can use to wrap critical sections of your code to ensure that interrupts are disabled while the code executes. At high level, the &lt;code>ATOMIC_BLOCK&lt;/code> macro (when called using &lt;code>ATOMIC_FORCEON&lt;/code>) does something like this:&lt;/p>
&lt;pre>&lt;code>cli();
...your code here...
seti();
&lt;/code>&lt;/pre>
&lt;p>But it&amp;rsquo;s more than that. If you read &lt;a href="https://www.nongnu.org/avr-libc/user-manual/group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4">the documentation&lt;/a> for the macro, it says:&lt;/p>
&lt;blockquote>
&lt;p>Creates a block of code that is guaranteed to be executed atomically. Upon entering the block the Global Interrupt Status flag in SREG is disabled, and re-enabled upon exiting the block &lt;strong>from any exit path&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>I didn&amp;rsquo;t really think much about the bit that I&amp;rsquo;ve highlighted until I wrote some code that looked something like this:&lt;/p>
&lt;pre>&lt;code>ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
while(some_condition) {
if (something_failed)
goto fail;
do_something_else();
}
}
fail:
return false;
&lt;/code>&lt;/pre>
&lt;p>There&amp;rsquo;s a &lt;code>goto&lt;/code> statement there; that&amp;rsquo;s an unconditional jump to the &lt;code>fail&lt;/code> label outside the &lt;code>ATOMIC_BLOCK&lt;/code> block. There isn&amp;rsquo;t really any opportunity there for anything to re-enable interrupts, and yet, my code worked just fine. What&amp;rsquo;s going on?&lt;/p>
&lt;p>It turns out that this is due to GCC magic. If you look at the expansion of the &lt;code>ATOMIC_BLOCK&lt;/code> macro, it looks like this:&lt;/p>
&lt;pre>&lt;code>#define ATOMIC_BLOCK(type) for ( type, __ToDo = __iCliRetVal(); \
__ToDo ; __ToDo = 0 )
&lt;/code>&lt;/pre>
&lt;p>It accepts a &lt;code>type&lt;/code> parameter which can be one of &lt;code>ATOMIC_RESTORESTATE&lt;/code> or &lt;code>ATOMIC_FORCEON&lt;/code>, which look like this:&lt;/p>
&lt;pre>&lt;code>#define ATOMIC_RESTORESTATE uint8_t sreg_save \
__attribute__((__cleanup__(__iRestore))) = SREG
&lt;/code>&lt;/pre>
&lt;p>And this:&lt;/p>
&lt;pre>&lt;code>#define ATOMIC_FORCEON uint8_t sreg_save \
__attribute__((__cleanup__(__iSeiParam))) = 0
&lt;/code>&lt;/pre>
&lt;p>The magic is the &lt;code>__attribute__&lt;/code> keyword: GCC supports &lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html">custom attributes&lt;/a> on variables that can change the way the variable is stored or used. In this case, the code is using the &lt;code>__cleanup__&lt;/code> attribute, which:&lt;/p>
&lt;blockquote>
&lt;p>&amp;hellip;runs a function when the variable goes out of scope.&lt;/p>
&lt;/blockquote>
&lt;p>So when we write:&lt;/p>
&lt;pre>&lt;code>ATOMIC_BLOCK(ATOMIC_FORCEON) {
do_something_here();
}
&lt;/code>&lt;/pre>
&lt;p>That becomes:&lt;/p>
&lt;pre>&lt;code>for ( uint8_t sreg_save __attribute__((__cleanup__(__iSeiParam))) = 0, __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) {
do_something_here();
}
&lt;/code>&lt;/pre>
&lt;p>Which instructs GCC to ensure that the &lt;code>iSeiParam&lt;/code> function is run whenever the &lt;code>sreg_save&lt;/code> variable goes out of scope. The &lt;code>iSeiParam()&lt;/code> method looks like:&lt;/p>
&lt;pre>&lt;code>static __inline__ void __iSeiParam(const uint8_t *__s)
{
__asm__ __volatile__ (&amp;quot;sei&amp;quot; ::: &amp;quot;memory&amp;quot;);
__asm__ volatile (&amp;quot;&amp;quot; ::: &amp;quot;memory&amp;quot;);
(void)__s;
}
&lt;/code>&lt;/pre>
&lt;p>In other words, this is very much like a &lt;code>try&lt;/code>/&lt;code>finally&lt;/code> block in Python, although the cleanup action is attached to a particular variable rather than to the block of code itself. I think that&amp;rsquo;s pretty neat.&lt;/p></content></item><item><title>AVR micro-optimization: Avr-gcc and --short-enums</title><link>https://blog.oddbit.com/post/2019-01-28-avr-gcc-short-enums/</link><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-28-avr-gcc-short-enums/</guid><description>&lt;h2 id="how-big-is-an-enum">How big is an enum?&lt;/h2>
&lt;p>I noticed something odd while browsing through the assembly output of some AVR C code &lt;a href="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/">I wrote recently&lt;/a>. In the code, I have the following expression:&lt;/p>
&lt;pre>&lt;code>int main() {
setup();
while (state != STATE_QUIT) {
loop();
}
}
&lt;/code>&lt;/pre>
&lt;p>Here, &lt;code>state&lt;/code> is a variable of type &lt;code>enum STATE&lt;/code>, which looks something like this (not exactly like this; there are actually &lt;a href="https://github.com/larsks/pipower/blob/master/states.h">19 possible values&lt;/a> but I didn&amp;rsquo;t want to clutter this post with unnecessary code listings):&lt;/p></description><content>&lt;h2 id="how-big-is-an-enum">How big is an enum?&lt;/h2>
&lt;p>I noticed something odd while browsing through the assembly output of some AVR C code &lt;a href="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/">I wrote recently&lt;/a>. In the code, I have the following expression:&lt;/p>
&lt;pre>&lt;code>int main() {
setup();
while (state != STATE_QUIT) {
loop();
}
}
&lt;/code>&lt;/pre>
&lt;p>Here, &lt;code>state&lt;/code> is a variable of type &lt;code>enum STATE&lt;/code>, which looks something like this (not exactly like this; there are actually &lt;a href="https://github.com/larsks/pipower/blob/master/states.h">19 possible values&lt;/a> but I didn&amp;rsquo;t want to clutter this post with unnecessary code listings):&lt;/p>
&lt;pre>&lt;code>enum STATE {
STATE_0,
STATE_1,
STATE_QUIT
};
&lt;/code>&lt;/pre>
&lt;p>Now, if you do a little research, you&amp;rsquo;ll find that the size of an &lt;code>enum&lt;/code> is unspecified by the C standard: it is implementation dependent. You will also find &lt;a href="https://www.embedded.fm/blog/2016/6/28/how-big-is-an-enum">articles&lt;/a> that say:&lt;/p>
&lt;blockquote>
&lt;p>The GCC C compiler will allocate enough memory for an enum to hold any of the values that you have declared. So, if your code only uses values below 256, your enum should be 8 bits wide.&lt;/p>
&lt;/blockquote>
&lt;p>The boolean expression in the &lt;code>while&lt;/code> loop gets translated as:&lt;/p>
&lt;pre>&lt;code> lds r24,state
lds r25,state+1
sbiw r24,2
brne .L9
&lt;/code>&lt;/pre>
&lt;p>In other words, that statement about the GCC compiler doesn&amp;rsquo;t appear to be true: We can see that the compiler is treating the &lt;code>state&lt;/code> variable as a 16-bit integer despite the &lt;code>enum&lt;/code> have only three values, which means that (a) two &lt;code>lds&lt;/code> operations are required to load the value into registers, and (b) it&amp;rsquo;s using &lt;code>sbiw&lt;/code>, which takes 2 clock cycles, rather than the &lt;code>cpi&lt;/code> operand, which only takes a single clock cycle. We see similar behavior in a &lt;code>switch&lt;/code> statement inside the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>void loop() {
switch(state) {
case STATE_0:
state = STATE_1;
break;
case STATE_1:
state = STATE_QUIT;
break;
case STATE_QUIT:
break;
}
}
&lt;/code>&lt;/pre>
&lt;p>The generated assembly for this includes the following:&lt;/p>
&lt;pre>&lt;code> lds r24,state
lds r25,state+1
cpi r24,1
cpc r25,__zero_reg__
breq .L3
sbiw r24,1
brsh .L6
ldi r24,lo8(1)
ldi r25,0
sts state+1,r25
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>As before, this requires two &lt;code>lds&lt;/code> instructions to load a value from the &lt;code>state&lt;/code> variable:&lt;/p>
&lt;pre>&lt;code> lds r24,state
lds r25,state+1
&lt;/code>&lt;/pre>
&lt;p>And two &lt;code>ldi&lt;/code> + two &lt;code>sts&lt;/code> instructions to store a new value into the &lt;code>state&lt;/code> variable:&lt;/p>
&lt;pre>&lt;code> ldi r24,lo8(1)
ldi r25,0
sts state+1,r25
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>And either multiple instructions (&lt;code>cpi&lt;/code> + &lt;code>cpc&lt;/code>) or multi-cycle instructions (&lt;code>sbiw&lt;/code>) to compare the value in the &lt;code>state&lt;/code> variable to constant values.&lt;/p>
&lt;p>The code we&amp;rsquo;re looking at here isn&amp;rsquo;t at all performance sensitive, but I figured that there had to be a way to get &lt;code>avr-gcc&lt;/code> to use a smaller data size for this &lt;code>enum&lt;/code>. While searching for a solution I stumbled across Rafael Baptista&amp;rsquo;s &amp;ldquo;&lt;a href="https://oroboro.com/short-enum/">The trouble with GCC&amp;rsquo;s &amp;ndash;short-enums flag&lt;/a>&amp;rdquo;, which is an interesting read all by itself but also introduced me to the &lt;code>--short-enums&lt;/code> flag, which does this:&lt;/p>
&lt;blockquote>
&lt;p>Allocate to an &amp;ldquo;enum&amp;rdquo; type only as many bytes as it needs for the declared range
of possible values. Specifically, the &amp;ldquo;enum&amp;rdquo; type is equivalent to the smallest
integer type that has enough room.&lt;/p>
&lt;/blockquote>
&lt;p>That sure sounds like exactly what I want. After rebuilding the code using &lt;code>--short-enums&lt;/code>, the generated assembly for &lt;code>main()&lt;/code> becomes:&lt;/p>
&lt;pre>&lt;code> lds r24,state
cpi r24,lo8(2)
brne .L10
&lt;/code>&lt;/pre>
&lt;p>The original code required six cycles (&lt;code>lds&lt;/code> + &lt;code>lds&lt;/code> + &lt;code>sbiw&lt;/code>), but this code only takes three (&lt;code>lds&lt;/code> + &lt;code>cpi&lt;/code>). The &lt;code>loop()&lt;/code> function becomes:&lt;/p>
&lt;pre>&lt;code> lds r24,state
mov r24,r24
ldi r25,0
cpi r24,1
cpc r25,__zero_reg__
breq .L3
cpi r24,2
cpc r25,__zero_reg__
breq .L6
or r24,r25
breq .L5
rjmp .L7
.L5:
ldi r24,lo8(1)
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>While the compiler is still performing comparisons on 16 bit values&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cpi r24,1
cpc r25,__zero_reg__
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;it now only requires a single instruction to load or store values from/to the &lt;code>state&lt;/code> variable:&lt;/p>
&lt;pre>&lt;code> ldi r24,lo8(1)
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>So, the tl;dr is that the &lt;code>--short-enums&lt;/code> flag makes a lot of sense when compiling code for an 8-bit device, and arguably makes the compiler generate code that is more intuitive.&lt;/p></content></item><item><title>AVR micro-optimization: Losing malloc</title><link>https://blog.oddbit.com/post/2019-01-28-losing-malloc/</link><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-28-losing-malloc/</guid><description>&lt;p>Pssst! Hey&amp;hellip;hey, buddy, wanna get an extra KB for cheap?&lt;/p>
&lt;p>When I write OO-style code in C, I usually start with something like the following, in which I use &lt;code>malloc()&lt;/code> to allocate memory for a variable of a particular type, perform some initialization actions, and then return it to the caller:&lt;/p>
&lt;pre>&lt;code>Button *button_new(uint8_t pin, uint8_t poll_freq) {
Button *button = (Button *)malloc(sizeof(Button));
// do some initialization stuff
return button;
}
&lt;/code>&lt;/pr</description><content>&lt;p>Pssst! Hey&amp;hellip;hey, buddy, wanna get an extra KB for cheap?&lt;/p>
&lt;p>When I write OO-style code in C, I usually start with something like the following, in which I use &lt;code>malloc()&lt;/code> to allocate memory for a variable of a particular type, perform some initialization actions, and then return it to the caller:&lt;/p>
&lt;pre>&lt;code>Button *button_new(uint8_t pin, uint8_t poll_freq) {
Button *button = (Button *)malloc(sizeof(Button));
// do some initialization stuff
return button;
}
&lt;/code>&lt;/pre>
&lt;p>And when initially writing &lt;a href="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/">pipower&lt;/a>, that&amp;rsquo;s exactly what I did. But while thinking about it after the fact, I realized the following:&lt;/p>
&lt;ul>
&lt;li>I&amp;rsquo;m designing for a fixed piece of hardware. I have a fixed number of inputs; I don&amp;rsquo;t actually need to create new &lt;code>Button&lt;/code> variables dynamically at runtime.&lt;/li>
&lt;li>The ATtiny85 only has 8KB of memory. Do I really need the overhead of &lt;code>malloc()&lt;/code>?&lt;/li>
&lt;/ul>
&lt;p>The answer, of course, is that no, I don&amp;rsquo;t, so I rewrote the code so that it only has statically allocated structures. This reduced the size of the resulting binary from this:&lt;/p>
&lt;pre>&lt;code>AVR Memory Usage
----------------
Device: attiny85
Program: 3916 bytes (47.8% Full)
(.text + .data + .bootloader)
Data: 35 bytes (6.8% Full)
(.data + .bss + .noinit)
&lt;/code>&lt;/pre>
&lt;p>To this:&lt;/p>
&lt;pre>&lt;code>AVR Memory Usage
----------------
Device: attiny85
Program: 3146 bytes (38.4% Full)
(.text + .data + .bootloader)
Data: 29 bytes (5.7% Full)
(.data + .bss + .noinit)
&lt;/code>&lt;/pre>
&lt;p>That&amp;rsquo;s a savings of just under 800 bytes, which on the one hand doesn&amp;rsquo;t seem like it a lot&amp;hellip;but on the other hand saves 10% of the available memory!&lt;/p>
&lt;h2 id="debugging-caveat">Debugging caveat&lt;/h2>
&lt;p>If you remove &lt;code>malloc()&lt;/code> from your code and then try to debug it with &lt;code>gdb&lt;/code>, you may find yourself staring at the following error:&lt;/p>
&lt;pre>&lt;code>evaluation of this expression requires the program to have a function &amp;quot;malloc&amp;quot;.
&lt;/code>&lt;/pre>
&lt;p>This will happen if you ask &lt;code>gdb&lt;/code> to do something that requires allocating memory for e.g., a string buffer. The solution is to ensure that &lt;code>malloc()&lt;/code> is linked into your code when you build for debugging. I use something like the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef DEBUG
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">__attribute__&lt;/span>((&lt;span style="color:#a6e22e">optimize&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;O0&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">_force_malloc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">malloc&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>__attribute__((optimize(&amp;quot;O0&amp;quot;)))&lt;/code> directive disables all optimizations for this function, which should prevent gcc from optimizing out the reference to &lt;code>malloc()&lt;/code>.&lt;/p></content></item><item><title>Debugging attiny85 code, part 1: simavr and gdb</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/</guid><description>&lt;p>In a case of awful timing, after my &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/">recent project involving some attiny85 programming&lt;/a> I finally got around to learning how to use &lt;a href="https://github.com/buserror/simavr">simavr&lt;/a> and &lt;code>gdb&lt;/code> to help debug my AVR code. It was too late for me (and I will never get the time back that I spent debugging things with an LED and lots of re-flashing), but maybe this will help someone else!&lt;/p>
&lt;p>I&amp;rsquo;ve split this into three posts:&lt;/p></description><content>&lt;p>In a case of awful timing, after my &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/">recent project involving some attiny85 programming&lt;/a> I finally got around to learning how to use &lt;a href="https://github.com/buserror/simavr">simavr&lt;/a> and &lt;code>gdb&lt;/code> to help debug my AVR code. It was too late for me (and I will never get the time back that I spent debugging things with an LED and lots of re-flashing), but maybe this will help someone else!&lt;/p>
&lt;p>I&amp;rsquo;ve split this into three posts:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>This is part 1.&lt;/p>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/">an earlier post&lt;/a>. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In this walkthrough I won&amp;rsquo;t be attempting to fix a bug, so perhaps the term &amp;ldquo;debugging&amp;rdquo; is, if not a misnomer, than at least only broadly applied. Rather, I am attempting to verify that my code behaves as expected in response to various inputs to the microcontroller pins.&lt;/p>
&lt;p>&lt;a href="https://github.com/larsks/pipower">Pipower&lt;/a> is implemented as a simple state machine. In each operational state, changes to input pins or timer expirations can cause it to transition into another state. The complete set of states look like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="pipower_states.png" />
&lt;/figure>
&lt;p>We&amp;rsquo;re going to walk through a particular set of state transitions.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>Before we start debugging, we should make sure that the code is built with debugging symbols and without optimizations. If you &lt;code>cd&lt;/code> into the &lt;code>sim&lt;/code> directory of the &lt;code>pipower&lt;/code> project and run &lt;code>make&lt;/code>, that&amp;rsquo;s exactly what you&amp;rsquo;ll get.&lt;/p>
&lt;pre>&lt;code>$ cd sim
$ make
[...]
avr-gcc -I.. -DTIMER_BOOTWAIT=1000 -DTIMER_SHUTDOWN=1000 -DTIMER_POWEROFF=1000 -Wall -g -Og -DF_CPU=1000000 -mmcu=attiny85 -c ../pipower.c -o pipower.o
[...]
&lt;/code>&lt;/pre>
&lt;p>There are several things happening here:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The &lt;code>Makefile&lt;/code> in this directory sets &lt;code>VPATH=..&lt;/code>, which means &lt;code>make&lt;/code> will look in the parent directory to find our sources. We need to tell the compiler to also look for include files in that directory; we do that with &lt;code>-I..&lt;/code>.&lt;/p>
&lt;p>A caveat to the above is that &lt;code>make&lt;/code> will also look in &lt;code>..&lt;/code> for object files to determine whether or not they need to be rebuilt. If you have previously built &lt;code>pipower&lt;/code> from the project root directory, you&amp;rsquo;ll want to run a &lt;code>make clean&lt;/code> in that directory first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We&amp;rsquo;re enabling debug symbols (with &lt;code>-g&lt;/code>) and disabling most optimizations with &lt;code>-Og&lt;/code>. From the &lt;code>gcc&lt;/code> &lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">manual&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>-Og&lt;/code> should be the optimization level of choice for the standard edit-compile-debug cycle, offering a reasonable level of optimization while maintaining fast compilation and a good debugging experience. It is a better choice than &lt;code>-O0&lt;/code> for producing debuggable code because some compiler passes that collect debug information are disabled at &lt;code>-O0&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>We are redefining several timers to be much shorter so that we don&amp;rsquo;t have to wait around when debugging (&lt;code>-DTIMER_BOOTWAIT=1000&lt;/code>, etc).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="start-simavr">Start simavr&lt;/h2>
&lt;p>We need to start &lt;code>simavr&lt;/code> before we can attach to it with &lt;code>gdb&lt;/code>. We&amp;rsquo;ll need to provide it with a path to our compiled &lt;code>pipower.elf&lt;/code> file, and we also want to make sure that we provide a clock frequency that matches the value of &lt;code>F_CPU&lt;/code> we used when building our code (&lt;code>1000000&lt;/code>):&lt;/p>
&lt;pre>&lt;code>$ simavr -m attiny85 -f 1000000 pipower.elf -g
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>-g&lt;/code> flag instructs &lt;code>simavr&lt;/code> to wait for a debugger connection before it starts to execute the code.&lt;/p>
&lt;h2 id="connect-with-gdb">Connect with gdb&lt;/h2>
&lt;p>Now that &lt;code>simavr&lt;/code> is running, we start up &lt;code>avr-gdb&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb
GNU gdb (GDB) 8.1
[...]
&lt;/code>&lt;/pre>
&lt;p>Load our binary:&lt;/p>
&lt;pre>&lt;code>(gdb) file pipower.elf
Reading symbols from pipower.elf...done.
&lt;/code>&lt;/pre>
&lt;p>Attach to the simulator (by default, &lt;code>simavr&lt;/code> listens on port &lt;code>1234&lt;/code>):&lt;/p>
&lt;pre>&lt;code>(gdb) target remote :1234
Remote debugging using :1234
0x00000000 in __vectors ()
&lt;/code>&lt;/pre>
&lt;p>And load the code into the simulator:&lt;/p>
&lt;pre>&lt;code>(gdb) load
Loading section .text, size 0xa42 lma 0x0
Loading section .data, size 0x6 lma 0xa42
Start address 0x0, load size 2632
Transfer rate: 2570 KB/sec, 175 bytes/write.
&lt;/code>&lt;/pre>
&lt;h2 id="run-the-code">Run the code&lt;/h2>
&lt;p>At this point, our &lt;code>main()&lt;/code> function has not started executing. Before we start the code, let&amp;rsquo;s set a breakpoint in the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L94">loop()&lt;/a> function:&lt;/p>
&lt;pre>&lt;code>(gdb) b loop
Breakpoint 1 at 0xaa: file pipower.c, line 98.
&lt;/code>&lt;/pre>
&lt;p>With this in place, when we start executing our code via the &lt;code>continue&lt;/code> command&amp;hellip;&lt;/p>
&lt;pre>&lt;code>(gdb) c
Continuing.
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;execution will stop as soon as it reaches the top of the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>Breakpoint 1, loop () at pipower.c:98
98 now = millis();
&lt;/code>&lt;/pre>
&lt;p>While debugging this code, I find it helpful to have the current state of the attiny85 pins displayed whenever we hit a breakpoint, as well as the current value of the &lt;code>state&lt;/code> variable. The following commands will display the current state and the binary contents of the &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> registers:&lt;/p>
&lt;pre>&lt;code>(gdb) display state
(gdb) display /t PORTB
(gdb) display /t PINB
&lt;/code>&lt;/pre>
&lt;p>Pin assignments used in this project as as follows:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">Pin&lt;/th>
&lt;th style="text-align: left">Name&lt;/th>
&lt;th style="text-align: left">I/O&lt;/th>
&lt;th style="text-align: left">Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">0&lt;/td>
&lt;td style="text-align: left">&lt;code>POWER&lt;/code>&lt;/td>
&lt;td style="text-align: left">I&lt;/td>
&lt;td style="text-align: left">Connected to active-low power button&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">1&lt;/td>
&lt;td style="text-align: left">&lt;code>USB&lt;/code>&lt;/td>
&lt;td style="text-align: left">I&lt;/td>
&lt;td style="text-align: left">USB signal from powerboost&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">2&lt;/td>
&lt;td style="text-align: left">&lt;code>EN&lt;/code>&lt;/td>
&lt;td style="text-align: left">O&lt;/td>
&lt;td style="text-align: left">EN signal to powerboost (turns on power)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">3&lt;/td>
&lt;td style="text-align: left">&lt;code>SHUTDOWN&lt;/code>&lt;/td>
&lt;td style="text-align: left">O&lt;/td>
&lt;td style="text-align: left">Signal to Pi requesting shutdown&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">4&lt;/td>
&lt;td style="text-align: left">&lt;code>BOOT&lt;/code>&lt;/td>
&lt;td style="text-align: left">I&lt;/td>
&lt;td style="text-align: left">Signal from Pi that it has booted&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>We can see the initial value of everything by running the &lt;code>display&lt;/code> command without any arguments:&lt;/p>
&lt;pre>&lt;code>(gdb) display
1: state = STATE_START
2: /t PORTB = 10001
3: /t PINB = 10001
&lt;/code>&lt;/pre>
&lt;p>Since this is the first iteration of the loop, we&amp;rsquo;re in state &lt;code>STATE_START&lt;/code>. Looking at &lt;code>PINB&lt;/code>, we can see that the &lt;code>USB&lt;/code> signal (pin 1) is low, indicating that external power is not connected.&lt;/p>
&lt;p>Let&amp;rsquo;s run the loop for a few iterations:&lt;/p>
&lt;pre>&lt;code>(gdb) c 10
Will ignore next 9 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10001
(gdb)
&lt;/code>&lt;/pre>
&lt;p>Since there was no external power available (&lt;code>PIN_USB&lt;/code> is low), the code has entered the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L232">STATE_IDLE2&lt;/a> state, as expected. Let&amp;rsquo;s see what happens when power becomes available. We start by setting &lt;code>PIN_USB&lt;/code> high:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_USB
&lt;/code>&lt;/pre>
&lt;p>And then run the loop a few times:&lt;/p>
&lt;pre>&lt;code>(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
&lt;/code>&lt;/pre>
&lt;p>The code has entered &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L163">STATE_BOOTWAIT1&lt;/a>, which means it is waiting for an attached Raspberry Pi to set &lt;code>PIN_BOOT&lt;/code> low. You can also see the &lt;code>PIN_EN&lt;/code> has been set high, which instructs the &lt;a href="https://www.adafruit.com/product/2465">power supply&lt;/a> to provide power to the Pi.&lt;/p>
&lt;p>In practice, an attached Raspberry Pi would set &lt;code>PIN_BOOT&lt;/code> high to signal that it had successfully booted. Let&amp;rsquo;s simulate that here and run the loop for a few more iterations:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_BOOT)
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
&lt;/code>&lt;/pre>
&lt;p>This brings us to the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L172">STATE_BOOT&lt;/a> state, which means that our Pi has successfully booted. At this point, a button press should trigger the shutdown sequence. Let&amp;rsquo;s see if that actually works! We will simulate a button press by first setting &lt;code>PIN_POWER&lt;/code> low, running the loop a few times, and then setting it high:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
(gdb) c 100
[...]
(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_POWER
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
&lt;/code>&lt;/pre>
&lt;p>The code recognized and responded to the button press, and is now in state &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L188">STATE_SHUTDOWN1&lt;/a>, waiting for the Pi to set &lt;code>PIN_BOOT&lt;/code> high. We can raise &lt;code>PIN_BOOT&lt;/code>:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_BOOT
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_POWEROFF1
2: /t PORTB = 10101
3: /t PINB = 10111
&lt;/code>&lt;/pre>
&lt;p>This brings us to &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L203">STATE_POWEROFF1&lt;/a>, during which the controller will wait some amount of time before cutting power to the Pi. Our debug build has reduced this timer to 1 second, but if you don&amp;rsquo;t have time for that we can simply run until the next state transition like this:&lt;/p>
&lt;pre>&lt;code>(gdb) disable 1
(gdb) tb loop if state != STATE_POWEROFF1
Note: breakpoint 1 (disabled) also set at pc 0xaa.
Temporary breakpoint 2 at 0xaa: file ../pipower.c, line 98.
(gdb) c
Continuing.
Temporary breakpoint 2, loop () at ../pipower.c:98
115 now = millis();
1: state = STATE_POWEROFF2
(gdb) enable1
(gdb)
&lt;/code>&lt;/pre>
&lt;p>This works by disabling the unqualified breakpoint at the top of &lt;code>loop()&lt;/code> and creating a new temporary breakpoint (meaning it will be removed once it triggers) that will only trigger when the global &lt;code>state&lt;/code> value has changed.&lt;/p>
&lt;p>From &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L213">STATE_POWEROFF2&lt;/a>, Pipower will enter the various &lt;code>IDLE*&lt;/code> stages, during which it enters a very low power sleep mode.&lt;/p>
&lt;hr>
&lt;p>That&amp;rsquo;s it for the walk-through! Hopefully that has given you some idea of how you can use &lt;code>simavr&lt;/code> and a debugger to test your AVR code without having to flash it to a device first.&lt;/p></content></item><item><title>Debugging attiny85 code, part 2: Automating GDB with scripts</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/</guid><description>&lt;p>This is the second of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p></description><content>&lt;p>This is the second of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">the first post&lt;/a> on this topic, we looked at how one can use &lt;code>gdb&lt;/code> and &lt;a href="https://github.com/buserror/simavr">simavr&lt;/a> to debug your attiny85 (or other AVR code) without flashing it to a device. In this post, I would like to extend that by looking at how we can automate some aspects of the debugging process.&lt;/p>
&lt;h2 id="sending-commands-to-gdb">Sending commands to gdb&lt;/h2>
&lt;p>In the previous post, we were entering commands into &lt;code>gdb&lt;/code> manually. It is also possible to provide &lt;code>gdb&lt;/code> with a script of commands to execute. Let&amp;rsquo;s assume we have a file that contains the following commands:&lt;/p>
&lt;pre>&lt;code>file pipower.elf
target remote :1234
load
&lt;/code>&lt;/pre>
&lt;p>There are a few different mechanisms available for passing these commands to &lt;code>gdb&lt;/code>. Naively we can simply redirect &lt;code>stdin&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb &amp;lt; commands.gdb
GNU gdb (GDB) 8.1
[...]
(gdb) Reading symbols from pipower.elf...done.
(gdb) Remote debugging using :1234
0x00000000 in __vectors ()
(gdb) Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb) quit
A debugging session is active.
Inferior 1 [Remote target] will be detached.
Quit anyway? (y or n) [answered Y; input not from terminal]
Detaching from program: /home/lars/projects/pipower/sim/pipower.elf, Remote target
&lt;/code>&lt;/pre>
&lt;p>This will work fine in situations in which you expect &lt;code>gdb&lt;/code> to run with no user interaction, but in this particular example, that makes our command file useless: while &lt;code>gdb&lt;/code> does connect to &lt;code>simavr&lt;/code>, it then exits immediately. This is where the &lt;code>--command&lt;/code> (or &lt;code>-x&lt;/code>) options comes in handy: that will read commands from a file and then return to the &lt;code>(gdb)&lt;/code> prompt:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb -x commands.gdb
GNU gdb (GDB) 8.1
[...]
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb)
&lt;/code>&lt;/pre>
&lt;p>This allows us to preload our debugging session with commands and then continue with an interactive session. You can achieve something similar using the &lt;code>source&lt;/code> command in &lt;code>gdb&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb
GNU gdb (GDB) 8.1
[...]
(gdb) source commands.gdb
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 431 KB/sec, 31 bytes/write.
(gdb)
&lt;/code>&lt;/pre>
&lt;h2 id="conditional-and-temporary-breakpoints">Conditional and temporary breakpoints&lt;/h2>
&lt;p>There are several different ways to set breakpoints in &lt;code>gdb&lt;/code>. The simplest is the &lt;code>b&lt;/code> command, which sets a breakpoint at the given location. This simple breakpoint will trigger whenever execution reaches the given line of code. We can influence this behavior by setting a breakpoint condition, such as:&lt;/p>
&lt;pre>&lt;code>b loop if state == STATE_POWEROFF2
&lt;/code>&lt;/pre>
&lt;p>This breakpoint will only trigger if the expression (&lt;code>state == STATE_POWEROFF2&lt;/code>) evaluates to true.&lt;/p>
&lt;p>Sometimes, we don&amp;rsquo;t want a persistent breakpoint: we want the code to stop once at a given point, and then continue executing afterwards without stopping again at the same place. We can accomplish this by setting a temporary breakpoint using the &lt;code>tb&lt;/code> command. If we were to write the previous example like this&amp;hellip;&lt;/p>
&lt;pre>&lt;code>tb loop if state == STATE_POWEROFF2
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;then the code would stop &lt;em>once&lt;/em> at the given breakpoint, but subsequently iterations of the loop would continue merrily on their way.&lt;/p>
&lt;h2 id="defining-new-commands">Defining new commands&lt;/h2>
&lt;p>The &lt;code>gdb&lt;/code> scripting language permits us to create new commands with the &lt;code>define&lt;/code> command. In the previous post, I simulated the passage of time by iterating through the main loop using a command such as &lt;code>c 100&lt;/code>. This works, but isn&amp;rsquo;t particularly accurate and may make it difficult if one wants to run for a specific amount of time (for example, to run out a timer). We can define a new &lt;code>wait_for&lt;/code> command that will let us wait for a given number of milliseconds:&lt;/p>
&lt;pre>&lt;code># wait for &amp;lt;n&amp;gt; milliseconds
define wait_for
disable 1
set $start_time = now
tb loop if now == $start_time + $arg0
c
enable 1
end
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>disable 1&lt;/code> at the beginning is disabling breakpoint 1, which we assume is the breakpoint created by running &lt;code>b loop&lt;/code> as in the &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">previous post&lt;/a>. We re-enable the breakpoint at the end of the definition.&lt;/p>
&lt;p>This takes advantage of the fact that the code in &lt;code>pipower.c&lt;/code> is explicitly updating a variable call &lt;code>now&lt;/code> with the output of the &lt;code>millis()&lt;/code> command, which counts milliseconds since the microprocessor started. We can store the current value of that variable in a &lt;code>gdb&lt;/code> variable by using the &lt;code>set&lt;/code> command:&lt;/p>
&lt;pre>&lt;code>set $start_time = now
&lt;/code>&lt;/pre>
&lt;p>This allows us to create a temporary breakpoint with a break condition that makes use of that value:&lt;/p>
&lt;pre>&lt;code>tb loop if now == $start_time + $arg0
&lt;/code>&lt;/pre>
&lt;p>This breakpoint will activate when the global &lt;code>now&lt;/code> variable is equal to the value we saved in &lt;code>$start_time&lt;/code> + whatever was passed as an argument to the &lt;code>wait_for&lt;/code> command.&lt;/p>
&lt;p>Since commands can call other commands, we can use the new &lt;code>wait_for&lt;/code> command to create a new command that simulates a button press. For our purposes, a &amp;ldquo;button press&amp;rdquo; means that &lt;code>PIN_POWER&lt;/code> goes low for 100ms and then goes high. We can simulate that like this:&lt;/p>
&lt;pre>&lt;code> define short_press
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
wait_for 100
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_POWER
c
end
&lt;/code>&lt;/pre>
&lt;p>Recall that &lt;code>c&lt;/code> means &lt;code>continue&lt;/code>, which will cause the code to continue running until it hits a breakpoint.&lt;/p>
&lt;h2 id="automated-testing-the-script">Automated testing: the script&lt;/h2>
&lt;p>Using everything discussed above, we can put together something like the &lt;a href="https://github.com/larsks/pipower/tree/master/sim/simulate.gdb">simulate.gdb&lt;/a> script included in the &lt;code>sim&lt;/code> directory of the Pipower project.&lt;/p>
&lt;p>We start by disabling pagination. This prevent &lt;code>gdb&lt;/code> from stopping and asking us to &amp;ldquo;press return to continue&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>set pagination off
&lt;/code>&lt;/pre>
&lt;p>We load our binary and connect to the simulator:&lt;/p>
&lt;pre>&lt;code>file pipower.elf
target remote :1234
load
&lt;/code>&lt;/pre>
&lt;p>Next, we define a few helper functions to avoid repetitive code in the rest of the script:&lt;/p>
&lt;pre>&lt;code>##
## Helper functions
##
# wait for &amp;lt;n&amp;gt; milliseconds
define wait_for
disable 1
set $start_time = now
tb loop if now == $start_time + $arg0
c
enable 1
end
# simulate a short press of the power button
define short_press
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
wait_for 100
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_POWER
c
end
# log a message
define log
printf &amp;quot;\n* %s\n&amp;quot;, $arg0
end
# run until we reach the given state
define run_until_state
disable 1
tb loop if $arg0 == state
c
enable 1
end
&lt;/code>&lt;/pre>
&lt;p>Prior to running the code, we a breakpoint on the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>##
## Execution starts here
##
# set an initial breakpoint at the start of loop() and advance the program
# to that point
b loop
&lt;/code>&lt;/pre>
&lt;p>And then start things running. This will stop at the top of &lt;code>loop()&lt;/code>:&lt;/p>
&lt;pre>&lt;code>c
&lt;/code>&lt;/pre>
&lt;p>In order to see how things are progressing as the script runs, let&amp;rsquo;s arrange to display the current value of the global &lt;code>state&lt;/code> variable as well as the &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> registers every time we hit a breakpoint:&lt;/p>
&lt;pre>&lt;code># set up some information to display at each breakpoint
display state
display /t PORTB
display /t PINB
display
&lt;/code>&lt;/pre>
&lt;p>Now that our displays are setup, let&amp;rsquo;s run the code for a bit and then set &lt;code>PIN_USB&lt;/code> high (this would indicate that external power is available to our device):&lt;/p>
&lt;pre>&lt;code># let the code advance for 100ms
wait_for 100
# enable external power
log &amp;quot;setting PIN_USB&amp;quot;
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_USB
&lt;/code>&lt;/pre>
&lt;p>We&amp;rsquo;ll use the &lt;code>run_until_state&lt;/code> command that we defined earlier in the file to execute until we reach the &lt;code>STATE_BOOTWAIT1&lt;/code> state:&lt;/p>
&lt;pre>&lt;code>run_until_state STATE_BOOTWAIT1
wait_for 100
&lt;/code>&lt;/pre>
&lt;p>At this point, the code expects an attached Raspberry Pi to assert the &lt;code>BOOT&lt;/code> signal by bringing &lt;code>PIN_BOOT&lt;/code> low:&lt;/p>
&lt;pre>&lt;code># assert BOOT
log &amp;quot;resetting PIN_BOOT&amp;quot;
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_BOOT)
run_until_state STATE_BOOT
&lt;/code>&lt;/pre>
&lt;p>Once the Pi has booted successfully and provided the &lt;code>BOOT&lt;/code> signal to our code, we enter the &lt;code>STATE_BOOT&lt;/code> state. Let&amp;rsquo;s run in this state for a second&amp;hellip;&lt;/p>
&lt;pre>&lt;code>##
## ...the pi has booted...
##
wait_for 1000
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;and then simulate a press of the power button:&lt;/p>
&lt;pre>&lt;code># request a shutdown by pressing the power button
log &amp;quot;pressing power button&amp;quot;
short_press
&lt;/code>&lt;/pre>
&lt;p>Our code sets &lt;code>PIN_SHUTDOWN&lt;/code> high, which would signal to an attached Pi that it should begin the shutdown process. The code enters the &lt;code>STATE_SHUTDOWN1&lt;/code> state in which it waits for the Pi to signal successful shutdown by de-asserting &lt;code>BOOT&lt;/code> by bringing &lt;code>PIN_BOOT&lt;/code> high:&lt;/p>
&lt;pre>&lt;code>run_until_state STATE_SHUTDOWN1
# de-assert BOOT
wait_for 100
log &amp;quot;setting PIN_BOOT&amp;quot;
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_BOOT
&lt;/code>&lt;/pre>
&lt;p>Once we receive the successful shutdown signal, the code enters the poweroff phase, during which it will wait &lt;code>TIMER_POWEROFF&lt;/code> milliseconds before cutting the power. Let&amp;rsquo;s walk through the poweroff state transitions:&lt;/p>
&lt;pre>&lt;code># step through state transitions until we reach
# STATE_IDLE2
run_until_state STATE_POWEROFF0
run_until_state STATE_POWEROFF1
run_until_state STATE_POWEROFF2
log &amp;quot;entering idle mode&amp;quot;
run_until_state STATE_IDLE0
run_until_state STATE_IDLE1
run_until_state STATE_IDLE2
wait_for 100
&lt;/code>&lt;/pre>
&lt;p>And finally force the code to exit:&lt;/p>
&lt;pre>&lt;code>log &amp;quot;setting quit flag&amp;quot;
set state=STATE_QUIT
finish
disconnect
quit
&lt;/code>&lt;/pre>
&lt;h2 id="automated-testing-the-output">Automated testing: the output&lt;/h2>
&lt;p>Running that script produces the following output, which lets us see the state transitions and pin values as the code is running:&lt;/p>
&lt;pre>&lt;code>0x00000000 in __vectors ()
Loading section .text, size 0xa74 lma 0x0
Loading section .data, size 0x6 lma 0xa74
Start address 0x0, load size 2682
Transfer rate: 873 KB/sec, 31 bytes/write.
Breakpoint 1 at 0xb0: file ../pipower.c, line 116.
Breakpoint 1, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_START
2: /t PORTB = 10001
3: /t PINB = 10001
Temporary breakpoint 2 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 2, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10001
* setting PIN_USB
Temporary breakpoint 3 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 3, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 4 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 4, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
* resetting PIN_BOOT
Temporary breakpoint 5 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 5, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 6 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 6, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
* pressing power button
Temporary breakpoint 7 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 7, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 110
Breakpoint 1, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 8 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 8, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
Temporary breakpoint 9 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 9, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
* setting PIN_BOOT
Temporary breakpoint 10 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 10, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF0
2: /t PORTB = 11101
3: /t PINB = 11111
Temporary breakpoint 11 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 11, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 12 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 12, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF2
2: /t PORTB = 10101
3: /t PINB = 10111
* entering idle mode
Temporary breakpoint 13 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 13, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE0
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 14 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 14, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE1
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 15 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 15, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10011
* setting quit flag
main () at ../pipower.c:280
280 while (state != STATE_QUIT) {
1: state = STATE_QUIT
2: /t PORTB = 10001
3: /t PINB = 10011
&lt;/code>&lt;/pre></content></item><item><title>Debugging attiny85 code, part 3: Tracing with simavr</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/</guid><description>&lt;figure class="left" >
&lt;img src="pipower_trace.png" />
&lt;/figure>
&lt;p>This is the third of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p></description><content>
&lt;figure class="left" >
&lt;img src="pipower_trace.png" />
&lt;/figure>
&lt;p>This is the third of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In the &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">previous post&lt;/a> we looked at we can automate &lt;code>gdb&lt;/code> using scripts. In this post, we&amp;rsquo;ll combine that with the tracing facilities offered by &lt;code>simavr&lt;/code> in order to generate traces for pin values and state transitions while the code is running.&lt;/p>
&lt;h2 id="preparing-your-code">Preparing your code&lt;/h2>
&lt;p>We need to embed some metadata in our code that provides &lt;code>simavr&lt;/code> with information about what data we want to collect. We do this by adding some special code that will get embedded in the &lt;code>.mmcu&lt;/code> section of the resulting ELF binary. You can see an example of this in &lt;a href="https://github.com/larsks/pipower/blob/master/sim/simavr.c">sim/simavr.c&lt;/a> in the Pipower project:&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;simavr/avr/avr_mcu_section.h&amp;gt;
#include &amp;quot;pins.h&amp;quot;
extern uint8_t state;
/** Trace data to collect.
*
* We collect each bit of PORTB (inputs and outputs) separately. We also keep
* track of the global state variable.
*/
const struct avr_mmcu_vcd_trace_t _mytrace[] _MMCU_ = {
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_POWER&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_POWER), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_USB&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_USB), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_EN&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_EN), .what = (void*)&amp;amp;PORTB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_SHUTDOWN&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_SHUTDOWN), .what = (void*)&amp;amp;PORTB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_BOOT&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_BOOT), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;STATE&amp;quot;), .what = (void*)&amp;amp;state, },
};
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>_mytrace&lt;/code> variable (the name is unimportant) is an array of &lt;code>struct avr_mmcu_vcd_trace_t&lt;/code> records (the &lt;code>_MMCU_&lt;/code> flag sets an attribute that will embed this data in the appropriate section of the ELF binary). Each record has the following fields:&lt;/p>
&lt;ul>
&lt;li>&lt;code>AVR_MCU_VCD_SYMBOL(&amp;quot;...&amp;quot;)&lt;/code> &amp;ndash; this sets the name of a data series to collect.&lt;/li>
&lt;li>&lt;code>.mask&lt;/code> (optional) &amp;ndash; use this if you only want to collect certain bits. In this example, I am masking out all but a single bit for each pin. I&amp;rsquo;m not using a mask for &lt;code>state&lt;/code> because I want the actual integer value in that case.&lt;/li>
&lt;li>&lt;code>.what&lt;/code> &amp;ndash; this is the variable to collect. It can be pretty much anything that is in scope. Here, &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> are the attiny85 input/output registers, and &lt;code>state&lt;/code> is a global variable from &lt;code>pipower.c&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>You can build a version of the pipower code that includes this metadata by running, in the &lt;code>sim/&lt;/code> directory:&lt;/p>
&lt;pre>&lt;code>make TRACE=1
&lt;/code>&lt;/pre>
&lt;p>You can see the new &lt;code>.mmcu&lt;/code> section of you inspect the section headers of &lt;code>pipower.elf&lt;/code> using, e.g., &lt;code>objdump&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ objdump pipower.elf -h
pipower.elf: file format elf32-little
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 00000a74 00000000 00000000 00000094 2**1
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .mmcu 000000de 00000a74 00000a74 00000b08 2**0
CONTENTS, ALLOC, LOAD, READONLY, DATA
[...]
&lt;/code>&lt;/pre>
&lt;h2 id="gathering-trace-data">Gathering trace data&lt;/h2>
&lt;p>To gather the trace data with &lt;code>simavr&lt;/code>, we simply repeat the steps from the &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">previous post&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>Start &lt;code>simavr&lt;/code>&lt;/li>
&lt;li>Run our automated testing script (&lt;code>simulate.gdb&lt;/code>)&lt;/li>
&lt;li>Stop &lt;code>simavr&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>At the end of this process, we will find a new file in our current directory, &lt;code>gtkwave_trace.vcd&lt;/code>. This is a &lt;a href="https://en.wikipedia.org/wiki/Value_change_dump">value change dump&lt;/a> file, which is a standard format for representing digital signals over time.&lt;/p>
&lt;h2 id="visualizing-the-trace-data">Visualizing the trace data&lt;/h2>
&lt;p>We can view the &lt;code>.vcd&lt;/code> file using &lt;a href="http://gtkwave.sourceforge.net/">gtkwave&lt;/a>. From the command line, you can run:&lt;/p>
&lt;pre>&lt;code>gtkwave gtkwave_trace.vcd
&lt;/code>&lt;/pre>
&lt;p>This will bring up the main &lt;code>gtkwave&lt;/code> window, which look like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-1.png" />
&lt;/figure>
&lt;p>Select &lt;code>logic&lt;/code> in the SST (&amp;ldquo;Signal Search Tree&amp;rdquo;) pane. This will display the available signals in the next pane down. Select all the signals (click on the top one, then shift-click on the last one) and select &amp;ldquo;Append&amp;rdquo;. You should end up with a display that looks like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-2.png" />
&lt;/figure>
&lt;p>The graph is displaying our collected signal data, but the initial time scale isn&amp;rsquo;t particularly useful. Select &amp;ldquo;Time -&amp;gt; Zoom -&amp;gt; Zoom Best Fit&amp;rdquo;; you should end up with something that looks like:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-3.png" />
&lt;/figure>
&lt;p>(Note that any time you resize the window you&amp;rsquo;ll need to manually adjust the zoom level. You can use the menu item, or just press &lt;code>CTRL&lt;/code>-&lt;code>ALT&lt;/code>-&lt;code>F&lt;/code>.)&lt;/p>
&lt;p>You can now see a graph of how the various pins changed over the runtime of the program. This is a useful way to verify that the code is behaving as expected. In this case, I think the section just past the 1 second mark is interesting; you can see the power button press, followed by &lt;code>PIN_SHUTDOWN&lt;/code> going high, then &lt;code>PIN_BOOT&lt;/code> going high, and finally &lt;code>PIN_EN&lt;/code> disabling power output after the 1 second timer expiry.&lt;/p>
&lt;p>You&amp;rsquo;ll note that the &lt;code>state&lt;/code> information is displayed numerically, which isn&amp;rsquo;t particularly helpful. We can fix that by setting up a &amp;ldquo;Translate Filter File&amp;rdquo;. Right click on the &lt;code>STATE[7:0]&lt;/code> label in the &amp;ldquo;Signals&amp;rdquo; pane, then select &amp;ldquo;Data Format -&amp;gt; Translate Filter File -&amp;gt; Enable and Select&amp;rdquo;. In the &amp;ldquo;Select Signal Filter&amp;rdquo; window that pops up&amp;hellip;&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-4.png" />
&lt;/figure>
&lt;p>&amp;hellip;select &amp;ldquo;Add Filter to List&amp;rdquo;. Browse to the &lt;code>sim&lt;/code> directory of the &lt;code>pipower&lt;/code> project, and select &lt;code>state_filter.txt&lt;/code>. Now select that same file in the &amp;ldquo;Filter Select&amp;rdquo; list, then click OK. You should now see state names displayed in the graph:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-5.png" />
&lt;/figure>
&lt;hr>
&lt;p>That&amp;rsquo;s the end of this series of posts on debugging AVR code with &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code>. I hope you found it useful!&lt;/p></content></item></channel></rss>