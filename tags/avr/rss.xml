<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Avr on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/avr/</link><description>Recent content in Avr on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 10:58:10 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/avr/rss.xml" rel="self" type="application/rss+xml"/><item><title>In which I PEBKAC so you don't have to</title><link>https://blog.oddbit.com/post/2019-02-11-in-which-i-pebkac-so-you-dont-/</link><pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-02-11-in-which-i-pebkac-so-you-dont-/</guid><description>&lt;p&gt;Say you have a simple bit of code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;util/delay.h&amp;gt; 

#define LED_BUILTIN _BV(PORTB5)

int main(void) 
{
 DDRB |= LED_BUILTIN;

 while (1)
 {
 PORTB |= LED_BUILTIN; // turn on led
 _delay_ms(1000); // delay 1s

 PORTB &amp;amp;= ~LED_BUILTIN; // turn off led
 _delay_ms(1000); // delay 1s
 } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You have a Makefile that compiles that into an object (&lt;code&gt;.o&lt;/code&gt;) file like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;avr-gcc -mmcu=atmega328p -DF_CPU=16000000 -Os -c blink.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you were to forget to set the device type when compiling your &lt;code&gt;.c&lt;/code&gt; file into an object file (&lt;code&gt;.o&lt;/code&gt;), you would get a warning:&lt;/p&gt;</description></item><item><title>ATOMIC_BLOCK magic in avr-libc</title><link>https://blog.oddbit.com/post/2019-02-01-atomicblock-magic-in-avrlibc/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-02-01-atomicblock-magic-in-avrlibc/</guid><description>&lt;p&gt;The AVR C library, &lt;a href="https://www.nongnu.org/avr-libc/"&gt;avr-libc&lt;/a&gt;, provide an &lt;code&gt;ATOMIC_BLOCK&lt;/code&gt; macro that you can use to wrap critical sections of your code to ensure that interrupts are disabled while the code executes. At high level, the &lt;code&gt;ATOMIC_BLOCK&lt;/code&gt; macro (when called using &lt;code&gt;ATOMIC_FORCEON&lt;/code&gt;) does something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cli();

...your code here...

seti();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But it&amp;rsquo;s more than that. If you read &lt;a href="https://www.nongnu.org/avr-libc/user-manual/group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4"&gt;the documentation&lt;/a&gt; for the macro, it says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Creates a block of code that is guaranteed to be executed atomically. Upon entering the block the Global Interrupt Status flag in SREG is disabled, and re-enabled upon exiting the block &lt;strong&gt;from any exit path&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>AVR micro-optimization: Avr-gcc and --short-enums</title><link>https://blog.oddbit.com/post/2019-01-28-avr-gcc-short-enums/</link><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-28-avr-gcc-short-enums/</guid><description>&lt;h2 id="how-big-is-an-enum"&gt;How big is an enum?&lt;/h2&gt;
&lt;p&gt;I noticed something odd while browsing through the assembly output of some AVR C code &lt;a href="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/"&gt;I wrote recently&lt;/a&gt;. In the code, I have the following expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main() {
 setup();

 while (state != STATE_QUIT) {
 loop();
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, &lt;code&gt;state&lt;/code&gt; is a variable of type &lt;code&gt;enum STATE&lt;/code&gt;, which looks something like this (not exactly like this; there are actually &lt;a href="https://github.com/larsks/pipower/blob/master/states.h"&gt;19 possible values&lt;/a&gt; but I didn&amp;rsquo;t want to clutter this post with unnecessary code listings):&lt;/p&gt;</description></item><item><title>AVR micro-optimization: Losing malloc</title><link>https://blog.oddbit.com/post/2019-01-28-losing-malloc/</link><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-28-losing-malloc/</guid><description>&lt;p&gt;Pssst! Hey&amp;hellip;hey, buddy, wanna get an extra KB for cheap?&lt;/p&gt;
&lt;p&gt;When I write OO-style code in C, I usually start with something like the following, in which I use &lt;code&gt;malloc()&lt;/code&gt; to allocate memory for a variable of a particular type, perform some initialization actions, and then return it to the caller:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Button *button_new(uint8_t pin, uint8_t poll_freq) {
 Button *button = (Button *)malloc(sizeof(Button));
 // do some initialization stuff

 return button;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And when initially writing &lt;a href="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/"&gt;pipower&lt;/a&gt;, that&amp;rsquo;s exactly what I did. But while thinking about it after the fact, I realized the following:&lt;/p&gt;</description></item><item><title>Debugging attiny85 code, part 1: simavr and gdb</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/</guid><description>&lt;p&gt;In a case of awful timing, after my &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/"&gt;recent project involving some attiny85 programming&lt;/a&gt; I finally got around to learning how to use &lt;a href="https://github.com/buserror/simavr"&gt;simavr&lt;/a&gt; and &lt;code&gt;gdb&lt;/code&gt; to help debug my AVR code. It was too late for me (and I will never get the time back that I spent debugging things with an LED and lots of re-flashing), but maybe this will help someone else!&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve split this into three posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/"&gt;Part 1: Using GDB&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Debugging attiny85 code, part 2: Automating GDB with scripts</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/</guid><description>&lt;p&gt;This is the second of three posts about using &lt;code&gt;gdb&lt;/code&gt; and &lt;code&gt;simavr&lt;/code&gt; to debug AVR code. The complete series is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/"&gt;Part 1: Using GDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/"&gt;Part 2: Automating GDB with scripts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Creating GDB scripts to automatically test the behavior of our code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/"&gt;Part 3: Tracing with simavr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;simavr&lt;/code&gt; to collect information about the state of microcontroller pins while our code is running.&lt;/p&gt;</description></item><item><title>Debugging attiny85 code, part 3: Tracing with simavr</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/</guid><description>&lt;figure&gt;&lt;a href="pipower_trace.png"&gt;&lt;img src="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/pipower_trace.png" width="800"&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;This is the third of three posts about using &lt;code&gt;gdb&lt;/code&gt; and &lt;code&gt;simavr&lt;/code&gt; to debug AVR code. The complete series is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/"&gt;Part 1: Using GDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/"&gt;Part 2: Automating GDB with scripts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Creating GDB scripts to automatically test the behavior of our code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/"&gt;Part 3: Tracing with simavr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;simavr&lt;/code&gt; to collect information about the state of microcontroller pins while our code is running.&lt;/p&gt;</description></item></channel></rss>