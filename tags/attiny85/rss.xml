<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>attiny85 on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/attiny85/</link><description>Recent content in attiny85 on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Mon, 28 Jan 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/attiny85/rss.xml" rel="self" type="application/rss+xml"/><item><title>AVR micro-optimization: Avr-gcc and --short-enums</title><link>https://blog.oddbit.com/post/2019-01-28-avr-gcc-short-enums/</link><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-28-avr-gcc-short-enums/</guid><description>How big is an enum? I noticed something odd while browsing through the assembly output of some AVR C code I wrote recently. In the code, I have the following expression:
int main() { setup(); while (state != STATE_QUIT) { loop(); } } Here, state is a variable of type enum STATE, which looks something like this (not exactly like this; there are actually 19 possible values but I didn&amp;rsquo;t want to clutter this post with unnecessary code listings):</description><content>&lt;h2 id="how-big-is-an-enum">How big is an enum?&lt;/h2>
&lt;p>I noticed something odd while browsing through the assembly output of some AVR C code &lt;a href="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/">I wrote recently&lt;/a>. In the code, I have the following expression:&lt;/p>
&lt;pre>&lt;code>int main() {
setup();
while (state != STATE_QUIT) {
loop();
}
}
&lt;/code>&lt;/pre>
&lt;p>Here, &lt;code>state&lt;/code> is a variable of type &lt;code>enum STATE&lt;/code>, which looks something like this (not exactly like this; there are actually &lt;a href="https://github.com/larsks/pipower/blob/master/states.h">19 possible values&lt;/a> but I didn&amp;rsquo;t want to clutter this post with unnecessary code listings):&lt;/p>
&lt;pre>&lt;code>enum STATE {
STATE_0,
STATE_1,
STATE_QUIT
};
&lt;/code>&lt;/pre>
&lt;p>Now, if you do a little research, you&amp;rsquo;ll find that the size of an &lt;code>enum&lt;/code> is unspecified by the C standard: it is implementation dependent. You will also find &lt;a href="https://www.embedded.fm/blog/2016/6/28/how-big-is-an-enum">articles&lt;/a> that say:&lt;/p>
&lt;blockquote>
&lt;p>The GCC C compiler will allocate enough memory for an enum to hold any of the values that you have declared. So, if your code only uses values below 256, your enum should be 8 bits wide.&lt;/p>
&lt;/blockquote>
&lt;p>The boolean expression in the &lt;code>while&lt;/code> loop gets translated as:&lt;/p>
&lt;pre>&lt;code> lds r24,state
lds r25,state+1
sbiw r24,2
brne .L9
&lt;/code>&lt;/pre>
&lt;p>In other words, that statement about the GCC compiler doesn&amp;rsquo;t appear to be true: We can see that the compiler is treating the &lt;code>state&lt;/code> variable as a 16-bit integer despite the &lt;code>enum&lt;/code> have only three values, which means that (a) two &lt;code>lds&lt;/code> operations are required to load the value into registers, and (b) it&amp;rsquo;s using &lt;code>sbiw&lt;/code>, which takes 2 clock cycles, rather than the &lt;code>cpi&lt;/code> operand, which only takes a single clock cycle. We see similar behavior in a &lt;code>switch&lt;/code> statement inside the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>void loop() {
switch(state) {
case STATE_0:
state = STATE_1;
break;
case STATE_1:
state = STATE_QUIT;
break;
case STATE_QUIT:
break;
}
}
&lt;/code>&lt;/pre>
&lt;p>The generated assembly for this includes the following:&lt;/p>
&lt;pre>&lt;code> lds r24,state
lds r25,state+1
cpi r24,1
cpc r25,__zero_reg__
breq .L3
sbiw r24,1
brsh .L6
ldi r24,lo8(1)
ldi r25,0
sts state+1,r25
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>As before, this requires two &lt;code>lds&lt;/code> instructions to load a value from the &lt;code>state&lt;/code> variable:&lt;/p>
&lt;pre>&lt;code> lds r24,state
lds r25,state+1
&lt;/code>&lt;/pre>
&lt;p>And two &lt;code>ldi&lt;/code> + two &lt;code>sts&lt;/code> instructions to store a new value into the &lt;code>state&lt;/code> variable:&lt;/p>
&lt;pre>&lt;code> ldi r24,lo8(1)
ldi r25,0
sts state+1,r25
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>And either multiple instructions (&lt;code>cpi&lt;/code> + &lt;code>cpc&lt;/code>) or multi-cycle instructions (&lt;code>sbiw&lt;/code>) to compare the value in the &lt;code>state&lt;/code> variable to constant values.&lt;/p>
&lt;p>The code we&amp;rsquo;re looking at here isn&amp;rsquo;t at all performance sensitive, but I figured that there had to be a way to get &lt;code>avr-gcc&lt;/code> to use a smaller data size for this &lt;code>enum&lt;/code>. While searching for a solution I stumbled across Rafael Baptista&amp;rsquo;s &amp;ldquo;&lt;a href="https://oroboro.com/short-enum/">The trouble with GCC&amp;rsquo;s &amp;ndash;short-enums flag&lt;/a>&amp;rdquo;, which is an interesting read all by itself but also introduced me to the &lt;code>--short-enums&lt;/code> flag, which does this:&lt;/p>
&lt;blockquote>
&lt;p>Allocate to an &amp;ldquo;enum&amp;rdquo; type only as many bytes as it needs for the declared range
of possible values. Specifically, the &amp;ldquo;enum&amp;rdquo; type is equivalent to the smallest
integer type that has enough room.&lt;/p>
&lt;/blockquote>
&lt;p>That sure sounds like exactly what I want. After rebuilding the code using &lt;code>--short-enums&lt;/code>, the generated assembly for &lt;code>main()&lt;/code> becomes:&lt;/p>
&lt;pre>&lt;code> lds r24,state
cpi r24,lo8(2)
brne .L10
&lt;/code>&lt;/pre>
&lt;p>The original code required six cycles (&lt;code>lds&lt;/code> + &lt;code>lds&lt;/code> + &lt;code>sbiw&lt;/code>), but this code only takes three (&lt;code>lds&lt;/code> + &lt;code>cpi&lt;/code>). The &lt;code>loop()&lt;/code> function becomes:&lt;/p>
&lt;pre>&lt;code> lds r24,state
mov r24,r24
ldi r25,0
cpi r24,1
cpc r25,__zero_reg__
breq .L3
cpi r24,2
cpc r25,__zero_reg__
breq .L6
or r24,r25
breq .L5
rjmp .L7
.L5:
ldi r24,lo8(1)
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>While the compiler is still performing comparisons on 16 bit values&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cpi r24,1
cpc r25,__zero_reg__
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;it now only requires a single instruction to load or store values from/to the &lt;code>state&lt;/code> variable:&lt;/p>
&lt;pre>&lt;code> ldi r24,lo8(1)
sts state,r24
&lt;/code>&lt;/pre>
&lt;p>So, the tl;dr is that the &lt;code>--short-enums&lt;/code> flag makes a lot of sense when compiling code for an 8-bit device, and arguably makes the compiler generate code that is more intuitive.&lt;/p></content></item><item><title>AVR micro-optimization: Losing malloc</title><link>https://blog.oddbit.com/post/2019-01-28-losing-malloc/</link><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-28-losing-malloc/</guid><description>Pssst! Hey&amp;hellip;hey, buddy, wanna get an extra KB for cheap?
When I write OO-style code in C, I usually start with something like the following, in which I use malloc() to allocate memory for a variable of a particular type, perform some initialization actions, and then return it to the caller:
Button *button_new(uint8_t pin, uint8_t poll_freq) { Button *button = (Button *)malloc(sizeof(Button)); // do some initialization stuff return button; } And when initially writing pipower, that&amp;rsquo;s exactly what I did.</description><content>&lt;p>Pssst! Hey&amp;hellip;hey, buddy, wanna get an extra KB for cheap?&lt;/p>
&lt;p>When I write OO-style code in C, I usually start with something like the following, in which I use &lt;code>malloc()&lt;/code> to allocate memory for a variable of a particular type, perform some initialization actions, and then return it to the caller:&lt;/p>
&lt;pre>&lt;code>Button *button_new(uint8_t pin, uint8_t poll_freq) {
Button *button = (Button *)malloc(sizeof(Button));
// do some initialization stuff
return button;
}
&lt;/code>&lt;/pre>
&lt;p>And when initially writing &lt;a href="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/">pipower&lt;/a>, that&amp;rsquo;s exactly what I did. But while thinking about it after the fact, I realized the following:&lt;/p>
&lt;ul>
&lt;li>I&amp;rsquo;m designing for a fixed piece of hardware. I have a fixed number of inputs; I don&amp;rsquo;t actually need to create new &lt;code>Button&lt;/code> variables dynamically at runtime.&lt;/li>
&lt;li>The ATtiny85 only has 8KB of memory. Do I really need the overhead of &lt;code>malloc()&lt;/code>?&lt;/li>
&lt;/ul>
&lt;p>The answer, of course, is that no, I don&amp;rsquo;t, so I rewrote the code so that it only has statically allocated structures. This reduced the size of the resulting binary from this:&lt;/p>
&lt;pre>&lt;code>AVR Memory Usage
----------------
Device: attiny85
Program: 3916 bytes (47.8% Full)
(.text + .data + .bootloader)
Data: 35 bytes (6.8% Full)
(.data + .bss + .noinit)
&lt;/code>&lt;/pre>
&lt;p>To this:&lt;/p>
&lt;pre>&lt;code>AVR Memory Usage
----------------
Device: attiny85
Program: 3146 bytes (38.4% Full)
(.text + .data + .bootloader)
Data: 29 bytes (5.7% Full)
(.data + .bss + .noinit)
&lt;/code>&lt;/pre>
&lt;p>That&amp;rsquo;s a savings of just under 800 bytes, which on the one hand doesn&amp;rsquo;t seem like it a lot&amp;hellip;but on the other hand saves 10% of the available memory!&lt;/p>
&lt;h2 id="debugging-caveat">Debugging caveat&lt;/h2>
&lt;p>If you remove &lt;code>malloc()&lt;/code> from your code and then try to debug it with &lt;code>gdb&lt;/code>, you may find yourself staring at the following error:&lt;/p>
&lt;pre>&lt;code>evaluation of this expression requires the program to have a function &amp;quot;malloc&amp;quot;.
&lt;/code>&lt;/pre>
&lt;p>This will happen if you ask &lt;code>gdb&lt;/code> to do something that requires allocating memory for e.g., a string buffer. The solution is to ensure that &lt;code>malloc()&lt;/code> is linked into your code when you build for debugging. I use something like the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef DEBUG
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">__attribute__&lt;/span>((&lt;span style="color:#a6e22e">optimize&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;O0&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">_force_malloc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">malloc&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>__attribute__((optimize(&amp;quot;O0&amp;quot;)))&lt;/code> directive disables all optimizations for this function, which should prevent gcc from optimizing out the reference to &lt;code>malloc()&lt;/code>.&lt;/p></content></item><item><title>Debugging attiny85 code, part 1: simavr and gdb</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/</guid><description>In a case of awful timing, after my recent project involving some attiny85 programming I finally got around to learning how to use simavr and gdb to help debug my AVR code. It was too late for me (and I will never get the time back that I spent debugging things with an LED and lots of re-flashing), but maybe this will help someone else!
I&amp;rsquo;ve split this into three posts:</description><content>&lt;p>In a case of awful timing, after my &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/">recent project involving some attiny85 programming&lt;/a> I finally got around to learning how to use &lt;a href="https://github.com/buserror/simavr">simavr&lt;/a> and &lt;code>gdb&lt;/code> to help debug my AVR code. It was too late for me (and I will never get the time back that I spent debugging things with an LED and lots of re-flashing), but maybe this will help someone else!&lt;/p>
&lt;p>I&amp;rsquo;ve split this into three posts:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>This is part 1.&lt;/p>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in &lt;a href="https://blog.oddbit.com/2019/01/19/pipower-a-raspberry-pi-ups/">an earlier post&lt;/a>. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In this walkthrough I won&amp;rsquo;t be attempting to fix a bug, so perhaps the term &amp;ldquo;debugging&amp;rdquo; is, if not a misnomer, than at least only broadly applied. Rather, I am attempting to verify that my code behaves as expected in response to various inputs to the microcontroller pins.&lt;/p>
&lt;p>&lt;a href="https://github.com/larsks/pipower">Pipower&lt;/a> is implemented as a simple state machine. In each operational state, changes to input pins or timer expirations can cause it to transition into another state. The complete set of states look like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="pipower_states.png" />
&lt;/figure>
&lt;p>We&amp;rsquo;re going to walk through a particular set of state transitions.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>Before we start debugging, we should make sure that the code is built with debugging symbols and without optimizations. If you &lt;code>cd&lt;/code> into the &lt;code>sim&lt;/code> directory of the &lt;code>pipower&lt;/code> project and run &lt;code>make&lt;/code>, that&amp;rsquo;s exactly what you&amp;rsquo;ll get.&lt;/p>
&lt;pre>&lt;code>$ cd sim
$ make
[...]
avr-gcc -I.. -DTIMER_BOOTWAIT=1000 -DTIMER_SHUTDOWN=1000 -DTIMER_POWEROFF=1000 -Wall -g -Og -DF_CPU=1000000 -mmcu=attiny85 -c ../pipower.c -o pipower.o
[...]
&lt;/code>&lt;/pre>
&lt;p>There are several things happening here:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The &lt;code>Makefile&lt;/code> in this directory sets &lt;code>VPATH=..&lt;/code>, which means &lt;code>make&lt;/code> will look in the parent directory to find our sources. We need to tell the compiler to also look for include files in that directory; we do that with &lt;code>-I..&lt;/code>.&lt;/p>
&lt;p>A caveat to the above is that &lt;code>make&lt;/code> will also look in &lt;code>..&lt;/code> for object files to determine whether or not they need to be rebuilt. If you have previously built &lt;code>pipower&lt;/code> from the project root directory, you&amp;rsquo;ll want to run a &lt;code>make clean&lt;/code> in that directory first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We&amp;rsquo;re enabling debug symbols (with &lt;code>-g&lt;/code>) and disabling most optimizations with &lt;code>-Og&lt;/code>. From the &lt;code>gcc&lt;/code> &lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">manual&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>-Og&lt;/code> should be the optimization level of choice for the standard edit-compile-debug cycle, offering a reasonable level of optimization while maintaining fast compilation and a good debugging experience. It is a better choice than &lt;code>-O0&lt;/code> for producing debuggable code because some compiler passes that collect debug information are disabled at &lt;code>-O0&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>We are redefining several timers to be much shorter so that we don&amp;rsquo;t have to wait around when debugging (&lt;code>-DTIMER_BOOTWAIT=1000&lt;/code>, etc).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="start-simavr">Start simavr&lt;/h2>
&lt;p>We need to start &lt;code>simavr&lt;/code> before we can attach to it with &lt;code>gdb&lt;/code>. We&amp;rsquo;ll need to provide it with a path to our compiled &lt;code>pipower.elf&lt;/code> file, and we also want to make sure that we provide a clock frequency that matches the value of &lt;code>F_CPU&lt;/code> we used when building our code (&lt;code>1000000&lt;/code>):&lt;/p>
&lt;pre>&lt;code>$ simavr -m attiny85 -f 1000000 pipower.elf -g
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>-g&lt;/code> flag instructs &lt;code>simavr&lt;/code> to wait for a debugger connection before it starts to execute the code.&lt;/p>
&lt;h2 id="connect-with-gdb">Connect with gdb&lt;/h2>
&lt;p>Now that &lt;code>simavr&lt;/code> is running, we start up &lt;code>avr-gdb&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb
GNU gdb (GDB) 8.1
[...]
&lt;/code>&lt;/pre>
&lt;p>Load our binary:&lt;/p>
&lt;pre>&lt;code>(gdb) file pipower.elf
Reading symbols from pipower.elf...done.
&lt;/code>&lt;/pre>
&lt;p>Attach to the simulator (by default, &lt;code>simavr&lt;/code> listens on port &lt;code>1234&lt;/code>):&lt;/p>
&lt;pre>&lt;code>(gdb) target remote :1234
Remote debugging using :1234
0x00000000 in __vectors ()
&lt;/code>&lt;/pre>
&lt;p>And load the code into the simulator:&lt;/p>
&lt;pre>&lt;code>(gdb) load
Loading section .text, size 0xa42 lma 0x0
Loading section .data, size 0x6 lma 0xa42
Start address 0x0, load size 2632
Transfer rate: 2570 KB/sec, 175 bytes/write.
&lt;/code>&lt;/pre>
&lt;h2 id="run-the-code">Run the code&lt;/h2>
&lt;p>At this point, our &lt;code>main()&lt;/code> function has not started executing. Before we start the code, let&amp;rsquo;s set a breakpoint in the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L94">loop()&lt;/a> function:&lt;/p>
&lt;pre>&lt;code>(gdb) b loop
Breakpoint 1 at 0xaa: file pipower.c, line 98.
&lt;/code>&lt;/pre>
&lt;p>With this in place, when we start executing our code via the &lt;code>continue&lt;/code> command&amp;hellip;&lt;/p>
&lt;pre>&lt;code>(gdb) c
Continuing.
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;execution will stop as soon as it reaches the top of the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>Breakpoint 1, loop () at pipower.c:98
98 now = millis();
&lt;/code>&lt;/pre>
&lt;p>While debugging this code, I find it helpful to have the current state of the attiny85 pins displayed whenever we hit a breakpoint, as well as the current value of the &lt;code>state&lt;/code> variable. The following commands will display the current state and the binary contents of the &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> registers:&lt;/p>
&lt;pre>&lt;code>(gdb) display state
(gdb) display /t PORTB
(gdb) display /t PINB
&lt;/code>&lt;/pre>
&lt;p>Pin assignments used in this project as as follows:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Pin&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>I/O&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>&lt;code>POWER&lt;/code>&lt;/td>
&lt;td>I&lt;/td>
&lt;td>Connected to active-low power button&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>&lt;code>USB&lt;/code>&lt;/td>
&lt;td>I&lt;/td>
&lt;td>USB signal from powerboost&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>&lt;code>EN&lt;/code>&lt;/td>
&lt;td>O&lt;/td>
&lt;td>EN signal to powerboost (turns on power)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>&lt;code>SHUTDOWN&lt;/code>&lt;/td>
&lt;td>O&lt;/td>
&lt;td>Signal to Pi requesting shutdown&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>&lt;code>BOOT&lt;/code>&lt;/td>
&lt;td>I&lt;/td>
&lt;td>Signal from Pi that it has booted&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>We can see the initial value of everything by running the &lt;code>display&lt;/code> command without any arguments:&lt;/p>
&lt;pre>&lt;code>(gdb) display
1: state = STATE_START
2: /t PORTB = 10001
3: /t PINB = 10001
&lt;/code>&lt;/pre>
&lt;p>Since this is the first iteration of the loop, we&amp;rsquo;re in state &lt;code>STATE_START&lt;/code>. Looking at &lt;code>PINB&lt;/code>, we can see that the &lt;code>USB&lt;/code> signal (pin 1) is low, indicating that external power is not connected.&lt;/p>
&lt;p>Let&amp;rsquo;s run the loop for a few iterations:&lt;/p>
&lt;pre>&lt;code>(gdb) c 10
Will ignore next 9 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10001
(gdb)
&lt;/code>&lt;/pre>
&lt;p>Since there was no external power available (&lt;code>PIN_USB&lt;/code> is low), the code has entered the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L232">STATE_IDLE2&lt;/a> state, as expected. Let&amp;rsquo;s see what happens when power becomes available. We start by setting &lt;code>PIN_USB&lt;/code> high:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_USB
&lt;/code>&lt;/pre>
&lt;p>And then run the loop a few times:&lt;/p>
&lt;pre>&lt;code>(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
&lt;/code>&lt;/pre>
&lt;p>The code has entered &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L163">STATE_BOOTWAIT1&lt;/a>, which means it is waiting for an attached Raspberry Pi to set &lt;code>PIN_BOOT&lt;/code> low. You can also see the &lt;code>PIN_EN&lt;/code> has been set high, which instructs the &lt;a href="https://www.adafruit.com/product/2465">power supply&lt;/a> to provide power to the Pi.&lt;/p>
&lt;p>In practice, an attached Raspberry Pi would set &lt;code>PIN_BOOT&lt;/code> high to signal that it had successfully booted. Let&amp;rsquo;s simulate that here and run the loop for a few more iterations:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_BOOT)
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
&lt;/code>&lt;/pre>
&lt;p>This brings us to the &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L172">STATE_BOOT&lt;/a> state, which means that our Pi has successfully booted. At this point, a button press should trigger the shutdown sequence. Let&amp;rsquo;s see if that actually works! We will simulate a button press by first setting &lt;code>PIN_POWER&lt;/code> low, running the loop a few times, and then setting it high:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
(gdb) c 100
[...]
(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_POWER
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
&lt;/code>&lt;/pre>
&lt;p>The code recognized and responded to the button press, and is now in state &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L188">STATE_SHUTDOWN1&lt;/a>, waiting for the Pi to set &lt;code>PIN_BOOT&lt;/code> high. We can raise &lt;code>PIN_BOOT&lt;/code>:&lt;/p>
&lt;pre>&lt;code>(gdb) set PINB = PINB | 1&amp;lt;&amp;lt;PIN_BOOT
(gdb) c 100
Will ignore next 99 crossings of breakpoint 1. Continuing.
Breakpoint 1, loop () at pipower.c:98
98 now = millis();
1: state = STATE_POWEROFF1
2: /t PORTB = 10101
3: /t PINB = 10111
&lt;/code>&lt;/pre>
&lt;p>This brings us to &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L203">STATE_POWEROFF1&lt;/a>, during which the controller will wait some amount of time before cutting power to the Pi. Our debug build has reduced this timer to 1 second, but if you don&amp;rsquo;t have time for that we can simply run until the next state transition like this:&lt;/p>
&lt;pre>&lt;code>(gdb) disable 1
(gdb) tb loop if state != STATE_POWEROFF1
Note: breakpoint 1 (disabled) also set at pc 0xaa.
Temporary breakpoint 2 at 0xaa: file ../pipower.c, line 98.
(gdb) c
Continuing.
Temporary breakpoint 2, loop () at ../pipower.c:98
115 now = millis();
1: state = STATE_POWEROFF2
(gdb) enable1
(gdb)
&lt;/code>&lt;/pre>
&lt;p>This works by disabling the unqualified breakpoint at the top of &lt;code>loop()&lt;/code> and creating a new temporary breakpoint (meaning it will be removed once it triggers) that will only trigger when the global &lt;code>state&lt;/code> value has changed.&lt;/p>
&lt;p>From &lt;a href="https://github.com/larsks/pipower/blob/b822b91af88d8baeb4e0e69fa5e69c074b96c32f/pipower.c#L213">STATE_POWEROFF2&lt;/a>, Pipower will enter the various &lt;code>IDLE*&lt;/code> stages, during which it enters a very low power sleep mode.&lt;/p>
&lt;hr>
&lt;p>That&amp;rsquo;s it for the walk-through! Hopefully that has given you some idea of how you can use &lt;code>simavr&lt;/code> and a debugger to test your AVR code without having to flash it to a device first.&lt;/p></content></item><item><title>Debugging attiny85 code, part 2: Automating GDB with scripts</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/</guid><description>This is the second of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running.</description><content>&lt;p>This is the second of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">the first post&lt;/a> on this topic, we looked at how one can use &lt;code>gdb&lt;/code> and &lt;a href="https://github.com/buserror/simavr">simavr&lt;/a> to debug your attiny85 (or other AVR code) without flashing it to a device. In this post, I would like to extend that by looking at how we can automate some aspects of the debugging process.&lt;/p>
&lt;h2 id="sending-commands-to-gdb">Sending commands to gdb&lt;/h2>
&lt;p>In the previous post, we were entering commands into &lt;code>gdb&lt;/code> manually. It is also possible to provide &lt;code>gdb&lt;/code> with a script of commands to execute. Let&amp;rsquo;s assume we have a file that contains the following commands:&lt;/p>
&lt;pre>&lt;code>file pipower.elf
target remote :1234
load
&lt;/code>&lt;/pre>
&lt;p>There are a few different mechanisms available for passing these commands to &lt;code>gdb&lt;/code>. Naively we can simply redirect &lt;code>stdin&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb &amp;lt; commands.gdb
GNU gdb (GDB) 8.1
[...]
(gdb) Reading symbols from pipower.elf...done.
(gdb) Remote debugging using :1234
0x00000000 in __vectors ()
(gdb) Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb) quit
A debugging session is active.
Inferior 1 [Remote target] will be detached.
Quit anyway? (y or n) [answered Y; input not from terminal]
Detaching from program: /home/lars/projects/pipower/sim/pipower.elf, Remote target
&lt;/code>&lt;/pre>
&lt;p>This will work fine in situations in which you expect &lt;code>gdb&lt;/code> to run with no user interaction, but in this particular example, that makes our command file useless: while &lt;code>gdb&lt;/code> does connect to &lt;code>simavr&lt;/code>, it then exits immediately. This is where the &lt;code>--command&lt;/code> (or &lt;code>-x&lt;/code>) options comes in handy: that will read commands from a file and then return to the &lt;code>(gdb)&lt;/code> prompt:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb -x commands.gdb
GNU gdb (GDB) 8.1
[...]
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb)
&lt;/code>&lt;/pre>
&lt;p>This allows us to preload our debugging session with commands and then continue with an interactive session. You can achieve something similar using the &lt;code>source&lt;/code> command in &lt;code>gdb&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ avr-gdb
GNU gdb (GDB) 8.1
[...]
(gdb) source commands.gdb
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 431 KB/sec, 31 bytes/write.
(gdb)
&lt;/code>&lt;/pre>
&lt;h2 id="conditional-and-temporary-breakpoints">Conditional and temporary breakpoints&lt;/h2>
&lt;p>There are several different ways to set breakpoints in &lt;code>gdb&lt;/code>. The simplest is the &lt;code>b&lt;/code> command, which sets a breakpoint at the given location. This simple breakpoint will trigger whenever execution reaches the given line of code. We can influence this behavior by setting a breakpoint condition, such as:&lt;/p>
&lt;pre>&lt;code>b loop if state == STATE_POWEROFF2
&lt;/code>&lt;/pre>
&lt;p>This breakpoint will only trigger if the expression (&lt;code>state == STATE_POWEROFF2&lt;/code>) evaluates to true.&lt;/p>
&lt;p>Sometimes, we don&amp;rsquo;t want a persistent breakpoint: we want the code to stop once at a given point, and then continue executing afterwards without stopping again at the same place. We can accomplish this by setting a temporary breakpoint using the &lt;code>tb&lt;/code> command. If we were to write the previous example like this&amp;hellip;&lt;/p>
&lt;pre>&lt;code>tb loop if state == STATE_POWEROFF2
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;then the code would stop &lt;em>once&lt;/em> at the given breakpoint, but subsequently iterations of the loop would continue merrily on their way.&lt;/p>
&lt;h2 id="defining-new-commands">Defining new commands&lt;/h2>
&lt;p>The &lt;code>gdb&lt;/code> scripting language permits us to create new commands with the &lt;code>define&lt;/code> command. In the previous post, I simulated the passage of time by iterating through the main loop using a command such as &lt;code>c 100&lt;/code>. This works, but isn&amp;rsquo;t particularly accurate and may make it difficult if one wants to run for a specific amount of time (for example, to run out a timer). We can define a new &lt;code>wait_for&lt;/code> command that will let us wait for a given number of milliseconds:&lt;/p>
&lt;pre>&lt;code># wait for &amp;lt;n&amp;gt; milliseconds
define wait_for
disable 1
set $start_time = now
tb loop if now == $start_time + $arg0
c
enable 1
end
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>disable 1&lt;/code> at the beginning is disabling breakpoint 1, which we assume is the breakpoint created by running &lt;code>b loop&lt;/code> as in the &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">previous post&lt;/a>. We re-enable the breakpoint at the end of the definition.&lt;/p>
&lt;p>This takes advantage of the fact that the code in &lt;code>pipower.c&lt;/code> is explicitly updating a variable call &lt;code>now&lt;/code> with the output of the &lt;code>millis()&lt;/code> command, which counts milliseconds since the microprocessor started. We can store the current value of that variable in a &lt;code>gdb&lt;/code> variable by using the &lt;code>set&lt;/code> command:&lt;/p>
&lt;pre>&lt;code>set $start_time = now
&lt;/code>&lt;/pre>
&lt;p>This allows us to create a temporary breakpoint with a break condition that makes use of that value:&lt;/p>
&lt;pre>&lt;code>tb loop if now == $start_time + $arg0
&lt;/code>&lt;/pre>
&lt;p>This breakpoint will activate when the global &lt;code>now&lt;/code> variable is equal to the value we saved in &lt;code>$start_time&lt;/code> + whatever was passed as an argument to the &lt;code>wait_for&lt;/code> command.&lt;/p>
&lt;p>Since commands can call other commands, we can use the new &lt;code>wait_for&lt;/code> command to create a new command that simulates a button press. For our purposes, a &amp;ldquo;button press&amp;rdquo; means that &lt;code>PIN_POWER&lt;/code> goes low for 100ms and then goes high. We can simulate that like this:&lt;/p>
&lt;pre>&lt;code> define short_press
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
wait_for 100
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_POWER
c
end
&lt;/code>&lt;/pre>
&lt;p>Recall that &lt;code>c&lt;/code> means &lt;code>continue&lt;/code>, which will cause the code to continue running until it hits a breakpoint.&lt;/p>
&lt;h2 id="automated-testing-the-script">Automated testing: the script&lt;/h2>
&lt;p>Using everything discussed above, we can put together something like the &lt;a href="https://github.com/larsks/pipower/tree/master/sim/simulate.gdb">simulate.gdb&lt;/a> script included in the &lt;code>sim&lt;/code> directory of the Pipower project.&lt;/p>
&lt;p>We start by disabling pagination. This prevent &lt;code>gdb&lt;/code> from stopping and asking us to &amp;ldquo;press return to continue&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>set pagination off
&lt;/code>&lt;/pre>
&lt;p>We load our binary and connect to the simulator:&lt;/p>
&lt;pre>&lt;code>file pipower.elf
target remote :1234
load
&lt;/code>&lt;/pre>
&lt;p>Next, we define a few helper functions to avoid repetitive code in the rest of the script:&lt;/p>
&lt;pre>&lt;code>##
## Helper functions
##
# wait for &amp;lt;n&amp;gt; milliseconds
define wait_for
disable 1
set $start_time = now
tb loop if now == $start_time + $arg0
c
enable 1
end
# simulate a short press of the power button
define short_press
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_POWER)
wait_for 100
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_POWER
c
end
# log a message
define log
printf &amp;quot;\n* %s\n&amp;quot;, $arg0
end
# run until we reach the given state
define run_until_state
disable 1
tb loop if $arg0 == state
c
enable 1
end
&lt;/code>&lt;/pre>
&lt;p>Prior to running the code, we a breakpoint on the &lt;code>loop()&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>##
## Execution starts here
##
# set an initial breakpoint at the start of loop() and advance the program
# to that point
b loop
&lt;/code>&lt;/pre>
&lt;p>And then start things running. This will stop at the top of &lt;code>loop()&lt;/code>:&lt;/p>
&lt;pre>&lt;code>c
&lt;/code>&lt;/pre>
&lt;p>In order to see how things are progressing as the script runs, let&amp;rsquo;s arrange to display the current value of the global &lt;code>state&lt;/code> variable as well as the &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> registers every time we hit a breakpoint:&lt;/p>
&lt;pre>&lt;code># set up some information to display at each breakpoint
display state
display /t PORTB
display /t PINB
display
&lt;/code>&lt;/pre>
&lt;p>Now that our displays are setup, let&amp;rsquo;s run the code for a bit and then set &lt;code>PIN_USB&lt;/code> high (this would indicate that external power is available to our device):&lt;/p>
&lt;pre>&lt;code># let the code advance for 100ms
wait_for 100
# enable external power
log &amp;quot;setting PIN_USB&amp;quot;
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_USB
&lt;/code>&lt;/pre>
&lt;p>We&amp;rsquo;ll use the &lt;code>run_until_state&lt;/code> command that we defined earlier in the file to execute until we reach the &lt;code>STATE_BOOTWAIT1&lt;/code> state:&lt;/p>
&lt;pre>&lt;code>run_until_state STATE_BOOTWAIT1
wait_for 100
&lt;/code>&lt;/pre>
&lt;p>At this point, the code expects an attached Raspberry Pi to assert the &lt;code>BOOT&lt;/code> signal by bringing &lt;code>PIN_BOOT&lt;/code> low:&lt;/p>
&lt;pre>&lt;code># assert BOOT
log &amp;quot;resetting PIN_BOOT&amp;quot;
set PINB=PINB &amp;amp; ~(1&amp;lt;&amp;lt;PIN_BOOT)
run_until_state STATE_BOOT
&lt;/code>&lt;/pre>
&lt;p>Once the Pi has booted successfully and provided the &lt;code>BOOT&lt;/code> signal to our code, we enter the &lt;code>STATE_BOOT&lt;/code> state. Let&amp;rsquo;s run in this state for a second&amp;hellip;&lt;/p>
&lt;pre>&lt;code>##
## ...the pi has booted...
##
wait_for 1000
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;and then simulate a press of the power button:&lt;/p>
&lt;pre>&lt;code># request a shutdown by pressing the power button
log &amp;quot;pressing power button&amp;quot;
short_press
&lt;/code>&lt;/pre>
&lt;p>Our code sets &lt;code>PIN_SHUTDOWN&lt;/code> high, which would signal to an attached Pi that it should begin the shutdown process. The code enters the &lt;code>STATE_SHUTDOWN1&lt;/code> state in which it waits for the Pi to signal successful shutdown by de-asserting &lt;code>BOOT&lt;/code> by bringing &lt;code>PIN_BOOT&lt;/code> high:&lt;/p>
&lt;pre>&lt;code>run_until_state STATE_SHUTDOWN1
# de-assert BOOT
wait_for 100
log &amp;quot;setting PIN_BOOT&amp;quot;
set PINB=PINB | 1&amp;lt;&amp;lt;PIN_BOOT
&lt;/code>&lt;/pre>
&lt;p>Once we receive the successful shutdown signal, the code enters the poweroff phase, during which it will wait &lt;code>TIMER_POWEROFF&lt;/code> milliseconds before cutting the power. Let&amp;rsquo;s walk through the poweroff state transitions:&lt;/p>
&lt;pre>&lt;code># step through state transitions until we reach
# STATE_IDLE2
run_until_state STATE_POWEROFF0
run_until_state STATE_POWEROFF1
run_until_state STATE_POWEROFF2
log &amp;quot;entering idle mode&amp;quot;
run_until_state STATE_IDLE0
run_until_state STATE_IDLE1
run_until_state STATE_IDLE2
wait_for 100
&lt;/code>&lt;/pre>
&lt;p>And finally force the code to exit:&lt;/p>
&lt;pre>&lt;code>log &amp;quot;setting quit flag&amp;quot;
set state=STATE_QUIT
finish
disconnect
quit
&lt;/code>&lt;/pre>
&lt;h2 id="automated-testing-the-output">Automated testing: the output&lt;/h2>
&lt;p>Running that script produces the following output, which lets us see the state transitions and pin values as the code is running:&lt;/p>
&lt;pre>&lt;code>0x00000000 in __vectors ()
Loading section .text, size 0xa74 lma 0x0
Loading section .data, size 0x6 lma 0xa74
Start address 0x0, load size 2682
Transfer rate: 873 KB/sec, 31 bytes/write.
Breakpoint 1 at 0xb0: file ../pipower.c, line 116.
Breakpoint 1, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_START
2: /t PORTB = 10001
3: /t PINB = 10001
Temporary breakpoint 2 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 2, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10001
* setting PIN_USB
Temporary breakpoint 3 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 3, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 4 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 4, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
* resetting PIN_BOOT
Temporary breakpoint 5 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 5, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 6 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 6, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
* pressing power button
Temporary breakpoint 7 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 7, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 110
Breakpoint 1, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 8 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 8, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
Temporary breakpoint 9 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 9, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111
* setting PIN_BOOT
Temporary breakpoint 10 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 10, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF0
2: /t PORTB = 11101
3: /t PINB = 11111
Temporary breakpoint 11 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 11, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 12 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 12, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_POWEROFF2
2: /t PORTB = 10101
3: /t PINB = 10111
* entering idle mode
Temporary breakpoint 13 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 13, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE0
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 14 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 14, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE1
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 15 at 0xb0: file ../pipower.c, line 116.
Temporary breakpoint 15, loop () at ../pipower.c:116
116 now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10011
* setting quit flag
main () at ../pipower.c:280
280 while (state != STATE_QUIT) {
1: state = STATE_QUIT
2: /t PORTB = 10001
3: /t PINB = 10011
&lt;/code>&lt;/pre></content></item><item><title>Debugging attiny85 code, part 3: Tracing with simavr</title><link>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/</guid><description>This is the third of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running.</description><content>
&lt;figure class="left" >
&lt;img src="pipower_trace.png" />
&lt;/figure>
&lt;p>This is the third of three posts about using &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code> to debug AVR code. The complete series is:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/">Part 1: Using GDB&lt;/a>&lt;/p>
&lt;p>A walkthrough of using GDB to manually inspect the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">Part 2: Automating GDB with scripts&lt;/a>&lt;/p>
&lt;p>Creating GDB scripts to automatically test the behavior of our code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/">Part 3: Tracing with simavr&lt;/a>&lt;/p>
&lt;p>Using &lt;code>simavr&lt;/code> to collect information about the state of microcontroller pins while our code is running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>In these posts, I will be referencing the code from my &lt;a href="https://github.com/larsks/pipower">pipower&lt;/a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/larsks/pipower
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll also want to be familiar with the &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a> or a similar AVR microcontroller, since I&amp;rsquo;ll be referring to register names (like &lt;code>PORTB&lt;/code>) without additional explanation.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>In the &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">previous post&lt;/a> we looked at we can automate &lt;code>gdb&lt;/code> using scripts. In this post, we&amp;rsquo;ll combine that with the tracing facilities offered by &lt;code>simavr&lt;/code> in order to generate traces for pin values and state transitions while the code is running.&lt;/p>
&lt;h2 id="preparing-your-code">Preparing your code&lt;/h2>
&lt;p>We need to embed some metadata in our code that provides &lt;code>simavr&lt;/code> with information about what data we want to collect. We do this by adding some special code that will get embedded in the &lt;code>.mmcu&lt;/code> section of the resulting ELF binary. You can see an example of this in &lt;a href="https://github.com/larsks/pipower/blob/master/sim/simavr.c">sim/simavr.c&lt;/a> in the Pipower project:&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;simavr/avr/avr_mcu_section.h&amp;gt;
#include &amp;quot;pins.h&amp;quot;
extern uint8_t state;
/** Trace data to collect.
*
* We collect each bit of PORTB (inputs and outputs) separately. We also keep
* track of the global state variable.
*/
const struct avr_mmcu_vcd_trace_t _mytrace[] _MMCU_ = {
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_POWER&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_POWER), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_USB&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_USB), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_EN&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_EN), .what = (void*)&amp;amp;PORTB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_SHUTDOWN&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_SHUTDOWN), .what = (void*)&amp;amp;PORTB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;PIN_BOOT&amp;quot;), .mask = (1&amp;lt;&amp;lt;PIN_BOOT), .what = (void*)&amp;amp;PINB, },
{ AVR_MCU_VCD_SYMBOL(&amp;quot;STATE&amp;quot;), .what = (void*)&amp;amp;state, },
};
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>_mytrace&lt;/code> variable (the name is unimportant) is an array of &lt;code>struct avr_mmcu_vcd_trace_t&lt;/code> records (the &lt;code>_MMCU_&lt;/code> flag sets an attribute that will embed this data in the appropriate section of the ELF binary). Each record has the following fields:&lt;/p>
&lt;ul>
&lt;li>&lt;code>AVR_MCU_VCD_SYMBOL(&amp;quot;...&amp;quot;)&lt;/code> &amp;ndash; this sets the name of a data series to collect.&lt;/li>
&lt;li>&lt;code>.mask&lt;/code> (optional) &amp;ndash; use this if you only want to collect certain bits. In this example, I am masking out all but a single bit for each pin. I&amp;rsquo;m not using a mask for &lt;code>state&lt;/code> because I want the actual integer value in that case.&lt;/li>
&lt;li>&lt;code>.what&lt;/code> &amp;ndash; this is the variable to collect. It can be pretty much anything that is in scope. Here, &lt;code>PORTB&lt;/code> and &lt;code>PINB&lt;/code> are the attiny85 input/output registers, and &lt;code>state&lt;/code> is a global variable from &lt;code>pipower.c&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>You can build a version of the pipower code that includes this metadata by running, in the &lt;code>sim/&lt;/code> directory:&lt;/p>
&lt;pre>&lt;code>make TRACE=1
&lt;/code>&lt;/pre>
&lt;p>You can see the new &lt;code>.mmcu&lt;/code> section of you inspect the section headers of &lt;code>pipower.elf&lt;/code> using, e.g., &lt;code>objdump&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ objdump pipower.elf -h
pipower.elf: file format elf32-little
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 00000a74 00000000 00000000 00000094 2**1
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .mmcu 000000de 00000a74 00000a74 00000b08 2**0
CONTENTS, ALLOC, LOAD, READONLY, DATA
[...]
&lt;/code>&lt;/pre>
&lt;h2 id="gathering-trace-data">Gathering trace data&lt;/h2>
&lt;p>To gather the trace data with &lt;code>simavr&lt;/code>, we simply repeat the steps from the &lt;a href="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/">previous post&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>Start &lt;code>simavr&lt;/code>&lt;/li>
&lt;li>Run our automated testing script (&lt;code>simulate.gdb&lt;/code>)&lt;/li>
&lt;li>Stop &lt;code>simavr&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>At the end of this process, we will find a new file in our current directory, &lt;code>gtkwave_trace.vcd&lt;/code>. This is a &lt;a href="https://en.wikipedia.org/wiki/Value_change_dump">value change dump&lt;/a> file, which is a standard format for representing digital signals over time.&lt;/p>
&lt;h2 id="visualizing-the-trace-data">Visualizing the trace data&lt;/h2>
&lt;p>We can view the &lt;code>.vcd&lt;/code> file using &lt;a href="http://gtkwave.sourceforge.net/">gtkwave&lt;/a>. From the command line, you can run:&lt;/p>
&lt;pre>&lt;code>gtkwave gtkwave_trace.vcd
&lt;/code>&lt;/pre>
&lt;p>This will bring up the main &lt;code>gtkwave&lt;/code> window, which look like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-1.png" />
&lt;/figure>
&lt;p>Select &lt;code>logic&lt;/code> in the SST (&amp;ldquo;Signal Search Tree&amp;rdquo;) pane. This will display the available signals in the next pane down. Select all the signals (click on the top one, then shift-click on the last one) and select &amp;ldquo;Append&amp;rdquo;. You should end up with a display that looks like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-2.png" />
&lt;/figure>
&lt;p>The graph is displaying our collected signal data, but the initial time scale isn&amp;rsquo;t particularly useful. Select &amp;ldquo;Time -&amp;gt; Zoom -&amp;gt; Zoom Best Fit&amp;rdquo;; you should end up with something that looks like:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-3.png" />
&lt;/figure>
&lt;p>(Note that any time you resize the window you&amp;rsquo;ll need to manually adjust the zoom level. You can use the menu item, or just press &lt;code>CTRL&lt;/code>-&lt;code>ALT&lt;/code>-&lt;code>F&lt;/code>.)&lt;/p>
&lt;p>You can now see a graph of how the various pins changed over the runtime of the program. This is a useful way to verify that the code is behaving as expected. In this case, I think the section just past the 1 second mark is interesting; you can see the power button press, followed by &lt;code>PIN_SHUTDOWN&lt;/code> going high, then &lt;code>PIN_BOOT&lt;/code> going high, and finally &lt;code>PIN_EN&lt;/code> disabling power output after the 1 second timer expiry.&lt;/p>
&lt;p>You&amp;rsquo;ll note that the &lt;code>state&lt;/code> information is displayed numerically, which isn&amp;rsquo;t particularly helpful. We can fix that by setting up a &amp;ldquo;Translate Filter File&amp;rdquo;. Right click on the &lt;code>STATE[7:0]&lt;/code> label in the &amp;ldquo;Signals&amp;rdquo; pane, then select &amp;ldquo;Data Format -&amp;gt; Translate Filter File -&amp;gt; Enable and Select&amp;rdquo;. In the &amp;ldquo;Select Signal Filter&amp;rdquo; window that pops up&amp;hellip;&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-4.png" />
&lt;/figure>
&lt;p>&amp;hellip;select &amp;ldquo;Add Filter to List&amp;rdquo;. Browse to the &lt;code>sim&lt;/code> directory of the &lt;code>pipower&lt;/code> project, and select &lt;code>state_filter.txt&lt;/code>. Now select that same file in the &amp;ldquo;Filter Select&amp;rdquo; list, then click OK. You should now see state names displayed in the graph:&lt;/p>
&lt;figure class="left" >
&lt;img src="gtkwave-5.png" />
&lt;/figure>
&lt;hr>
&lt;p>That&amp;rsquo;s the end of this series of posts on debugging AVR code with &lt;code>gdb&lt;/code> and &lt;code>simavr&lt;/code>. I hope you found it useful!&lt;/p></content></item><item><title>PiPower: A Raspberry Pi UPS</title><link>https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/</guid><description>I have a Raspberry Pi running RetroPie hooked up to a television. It&amp;rsquo;s powered from a USB port on the TV, which is convenient, but it means that whenever we shut off the TV we&amp;rsquo;re pulling the plug on the Pi. While there haven&amp;rsquo;t been any problems so far, this is a classic recipe for filesystem problems or data loss at some point. I started looking into UPS options to alleviate this issue.</description><content>
&lt;figure class="left" >
&lt;img src="pipower-top.jpg" />
&lt;/figure>
&lt;p>I have a Raspberry Pi running &lt;a href="https://retropie.org.uk/">RetroPie&lt;/a> hooked up to a television. It&amp;rsquo;s powered from a USB port on the TV, which is convenient, but it means that whenever we shut off the TV we&amp;rsquo;re pulling the plug on the Pi. While there haven&amp;rsquo;t been any problems so far, this is a classic recipe for filesystem problems or data loss at some point. I started looking into UPS options to alleviate this issue. I wanted something with the following features:&lt;/p>
&lt;ul>
&lt;li>Notify the Pi when external power is removed so that the Pi can shut down cleanly.&lt;/li>
&lt;li>Power off the Pi after the Pi has shut down.&lt;/li>
&lt;li>Boot the Pi when external power is restored.&lt;/li>
&lt;/ul>
&lt;p>There are several Pi UPS solutions out there, but most of them are designed for a different purpose: they will run your Pi from battery for as long as possible, and will notify your Pi when the battery level goes low. That&amp;rsquo;s great if you want a portable device, but isn&amp;rsquo;t the right solution for my situation. One notable exception is the &lt;a href="https://juice4halt.com/">juice4halt&lt;/a> product, which is a super-capacitor based unit that does pretty much exactly when I want. Unfortunately, it is somewhat pricey.&lt;/p>
&lt;p>While looking at various solutions, I found the Adafruit &lt;a href="https://www.adafruit.com/product/2465">PowerBoost 1000c&lt;/a>. When external power is available, this device will charge a LIPO battery and provide power to your Pi at the same time. When external power is removed, this device will power your Pi from the battery. By itself it doesn&amp;rsquo;t have any facilities for communicating with your Pi, but it does provide several control lines which suggested some interesting possibilities.&lt;/p>
&lt;figure class="left" >
&lt;img src="powerboost1000c.png" />
&lt;/figure>
&lt;p>Getting the Powerboost talking to the Pi seemed like a good job for a small microcontroller. I happen to have a few &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny85">attiny85&lt;/a>s kicking about, so I decided to use one of those.&lt;/p>
&lt;h2 id="code">Code&lt;/h2>
&lt;p>You can find all the code used in this project in &lt;a href="https://github.com/larsks/pipower">the GitHub repository&lt;/a>. The code is written in C, and can be compiled using &lt;code>avr-gcc&lt;/code>. It requires &lt;a href="https://www.nongnu.org/avr-libc/">avr-libc&lt;/a>.&lt;/p>
&lt;h2 id="theory-of-operation">Theory of operation&lt;/h2>
&lt;p>When everything first boots up, the microcontroller checks the &lt;code>USB&lt;/code> signal from the PowerBoost to see if external power is available. The &lt;code>USB&lt;/code> line must remain high for 1 second before it is considered valid (it turns out that the &lt;code>USB&lt;/code> can go high momentarily when things first come on, so this avoids erroneously powering up the Pi when external power isn&amp;rsquo;t available).&lt;/p>
&lt;p>If power is available, the controller brings the &lt;code>EN&lt;/code> line high, which causes the PowerBoost to start supplying power to the Pi. The controller will wait for up to 30 seconds for the &lt;code>BOOT&lt;/code> line to go low. The Pi boots up, and the &lt;code>pipower-up&lt;/code> service (see below) brings the &lt;code>BOOT&lt;/code> line low to indicate that it has successfully booted. If the &lt;code>BOOT&lt;/code> line does not go low within 30 seconds, the controller assumes the Pi has failed to boot and disconnects the power, then enters the lower-power idle mode.&lt;/p>
&lt;p>If you shut down the Pi manually, the &lt;code>pipower-up&lt;/code> service will set the &lt;code>BOOT&lt;/code> line high late in the shutdown sequence to indicate that the Pi is shutting down. The microcontroller will wait an additional 30 seconds and will then turn off power to the Pi. If the &lt;code>BOOT&lt;/code> line goes low again during this time (e.g, if you rebooted the Pi instead of shutting it down), the microcontroller will cancel the shutdown.&lt;/p>
&lt;p>If while the Pi is running you press the power button on the board, this will set the &lt;code>SHUTDOWN&lt;/code> line high. The &lt;code>pipower-down&lt;/code> service will respond to this signal by starting a clean shut down. The controller will wait up to 30 seconds for the Pi to set the &lt;code>BOOT&lt;/code> line high, at which point it will wait another 30 seconds before removing power.&lt;/p>
&lt;p>If while the Pi is running external power is removed, the microcontroller will set the &lt;code>SHUTDOWN&lt;/code> line high, and will follow the same logic as if you had pressed the power button.&lt;/p>
&lt;p>If the microcontroller is in the idle state and external power is available, you can press the power button to boot the Pi. If external power is not available, then applying external power will cause the Pi to boot.&lt;/p>
&lt;p>At any point, a long press (two seconds ore more) of the power button will immediately remove power from the Pi and place the controller in the idle state.&lt;/p>
&lt;h2 id="notes-on-the-code">Notes on the code&lt;/h2>
&lt;p>I initially started writing the code using the Arduino IDE, but I decided to switch to &lt;code>avr-gcc&lt;/code> early on because I found that easier to work with. Since various aspects of the code require tracking the passage of time, the first thing I had to do was implement a version of the &lt;code>millis()&lt;/code> function. You can see my implementation in &lt;a href="https://github.com/larsks/pipower/blob/master/millis.c">millis.c&lt;/a>. This uses &lt;code>TIMER0&lt;/code> on the attiny85 with a divider of 64 (&lt;code>TCCR0B = 3&amp;lt;&amp;lt;CS00&lt;/code>), since that should allow the code to work with processor running at 16Mhz.&lt;/p>
&lt;p>I wrote debouncing code for the power button using the mechanism described by Elliot Williams in &amp;ldquo;&lt;a href="https://hackaday.com/2015/12/10/embed-with-elliot-debounce-your-noisy-buttons-part-ii/">Debounce your Noisy Buttons, Part II&lt;/a>&amp;rdquo;. I wrote an object-oriented implementation that you can find in &lt;a href="https://github.com/larsks/pipower/blob/master/button.c">button.c&lt;/a>.&lt;/p>
&lt;p>Most of the implementation logic can be found in the state machine implemented as a &lt;code>switch&lt;/code> statement in &lt;a href="https://github.com/larsks/pipower/blob/master/pipower.c#L125-L245">lines 125-254 of pipower.c&lt;/a>.&lt;/p>
&lt;p>I have documented the code using &lt;a href="http://www.doxygen.nl/">Doxygen&lt;/a>. If you have Doxygen installed, you can &lt;code>cd docs&lt;/code> and run &lt;code>make&lt;/code> to create the code documentation.&lt;/p>
&lt;h2 id="pins">pins&lt;/h2>
&lt;p>The attiny85 only has 5 available pins (6, if you&amp;rsquo;re either very confident or have a high voltage programmer available). I ended up setting things up like this:&lt;/p>
&lt;ul>
&lt;li>&lt;code>PB0&lt;/code> - connected to a momentary-contact switch&lt;/li>
&lt;li>&lt;code>PB1&lt;/code> - connected to &lt;code>USB&lt;/code> signal from the powerboost&lt;/li>
&lt;li>&lt;code>PB2&lt;/code> - connected to the &lt;code>EN&lt;/code> signal to the powerboost&lt;/li>
&lt;li>&lt;code>PB3&lt;/code> - connected to the &lt;code>SHUTDOWN&lt;/code> signal to the Pi&lt;/li>
&lt;li>&lt;code>PB4&lt;/code> - connected to the &lt;code>BOOT&lt;/code> signal from the Pi&lt;/li>
&lt;li>&lt;code>VCC&lt;/code> - connected to the &lt;code>Vs&lt;/code> output from the powerboost&lt;/li>
&lt;/ul>
&lt;p>I am intentionally not using the low battery (&lt;code>LBO&lt;/code>) signal, since I&amp;rsquo;m not trying to run the Pi off the battery for an extended period of time. If I build or acquire a high voltage programmer, I might wire &lt;code>LBO&lt;/code> to &lt;code>PB5&lt;/code>, or just connect the &lt;code>BAT&lt;/code> signal and use &lt;code>PB5&lt;/code> as an analog Pin, and trigger a shutdown on a low-battery condition as well.&lt;/p>
&lt;h2 id="systemd-units">systemd units&lt;/h2>
&lt;p>The only software required on the Raspberry Pi is &lt;a href="http://wiringpi.com/">wiringPi&lt;/a>, a library and toolset for manipulating GPIO on your Raspberry Pi, and the following &lt;a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd&lt;/a> &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">units&lt;/a>. If you are building this yourself and disagree with my pin selections, you can create the file &lt;code>/etc/default/pipower&lt;/code> and set one or both of &lt;code>PIN_SHUTDOWN&lt;/code> and &lt;code>PIN_BOOT&lt;/code> to BCM GPIO pins of your choice.&lt;/p>
&lt;h3 id="pipower-up">pipower-up&lt;/h3>
&lt;p>At boot, the &lt;code>pipower-up&lt;/code> service configures &lt;code>PIN_BOOT&lt;/code> (defaults to BCM GPIO 4) as an output and then brings it low. This notifies the code running on the attiny85 that the Pi has successfully booted. When the Pi shuts down, the unit sets &lt;code>PIN_BOOT&lt;/code> high, which notifies the controller that the Pi is about to shut down.&lt;/p>
&lt;p>This service is designed to run early in the boot process and late in the shutdown process.&lt;/p>
&lt;pre>&lt;code>[Unit]
Description=[pipower] Assert BOOT signal
DefaultDependencies=no
After=final.target systemd-journald.service
[Service]
Type=oneshot
Environment=PIN_BOOT=4
EnvironmentFile=-/etc/default/pipower
RemainAfterExit=true
ExecStartPre=/usr/bin/gpio -g mode $PIN_BOOT output
ExecStart=/usr/bin/gpio -g write $PIN_BOOT 0
ExecStopPost=/bin/sh -c &amp;quot;test -f /run/pipower/inhibit || /usr/bin/gpio -g write $PIN_BOOT 1&amp;quot;
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>
&lt;h3 id="pipower-down">pipower-down&lt;/h3>
&lt;p>At boot, the &lt;code>pipower-down&lt;/code> service configures &lt;code>PIN_SHUTDOWN&lt;/code> (defaults to BCM GPIO 17) as an input w/ the pulldown resistor enabled. It then uses the &lt;code>gpio&lt;/code> command to wait for a rising interrupt on &lt;code>PIN_SHUTDOWN&lt;/code>; when it receives one, it calls &lt;code>systemctl poweroff&lt;/code> to cleanly shut down the system.&lt;/p>
&lt;pre>&lt;code>[Unit]
Description=[pipower] Monitor SHUTDOWN signal
[Service]
Type=simple
Environment=PIN_SHUTDOWN=17
EnvironmentFile=-/etc/default/pipower
ExecStartPre=/usr/bin/gpio -g mode $PIN_SHUTDOWN input
ExecStartPre=/usr/bin/gpio -g mode $PIN_SHUTDOWN down
ExecStart=/usr/bin/gpio -g wfi $PIN_SHUTDOWN rising
ExecStopPost=/bin/sh -c &amp;quot;test -f /run/pipower/inhibit || /bin/systemctl poweroff&amp;quot;
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>
&lt;h2 id="caveats">Caveats&lt;/h2>
&lt;p>The PowerBoost 1000c does not provide adequate power for a Raspberry Pi 3B+. It seems to be just adequate for a Pi 2B.&lt;/p>
&lt;p>If you stop either of the systemd units, your Pi will either shutdown (if you &lt;code>systemctl stop pipower-down&lt;/code>) or will simply lose power (if you &lt;code>systemctl stop pipower-up&lt;/code>). You can inhibit the &lt;code>ExecStop*&lt;/code> actions of both units by creating the file &lt;code>/run/pipower/inhibit&lt;/code>.&lt;/p>
&lt;h2 id="todo">TODO&lt;/h2>
&lt;p>With a few more pins available &amp;ndash; maybe an &lt;a href="https://www.microchip.com/wwwproducts/en/ATtiny84">attiny84&lt;/a> &amp;ndash; it might be fun to provide battery voltage and current measurements to the Pi via an i2c interface. I would probably also add a status LED to show the current state of the controller code.&lt;/p>
&lt;figure class="left" >
&lt;img src="pipower-eth-left.jpg" />
&lt;/figure>
&lt;figure class="left" >
&lt;img src="pipower-eth-right.jpg" />
&lt;/figure></content></item></channel></rss>