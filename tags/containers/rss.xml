<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Containers on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/containers/</link><description>Recent content in Containers on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Fri, 17 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/containers/rss.xml" rel="self" type="application/rss+xml"/><item><title>Applying custom configuration to Nginx Gateway Fabric</title><link>https://blog.oddbit.com/post/2023-11-17-nginx-gateway-configuration/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-11-17-nginx-gateway-configuration/</guid><description>&lt;p>In this post, we take a look at how to apply custom Nginx configuration directives when you&amp;rsquo;re using the &lt;a href="https://github.com/nginxinc/nginx-gateway-fabric">NGINX Gateway Fabric&lt;/a>.&lt;/p>
&lt;h2 id="whats-the-nginx-gateway-fabric">What&amp;rsquo;s the NGINX Gateway Fabric?&lt;/h2>
&lt;p>The NGINX Gateway Fabric is an implementation of the Kubernetes &lt;a href="https://gateway-api.sigs.k8s.io/">Gateway API&lt;/a>.&lt;/p>
&lt;h2 id="whats-the-gateway-api">What&amp;rsquo;s the Gateway API?&lt;/h2>
&lt;p>The Gateway API is an evolution of the &lt;a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress&lt;/a> API; it aims to provide a flexible mechanism for managing north/south network traffic (that is, traffic entering or exiting your Kubernetes cluster), with additional work to support east/west traffic (traffic between pods in your cluster).&lt;/p></description><content>&lt;p>In this post, we take a look at how to apply custom Nginx configuration directives when you&amp;rsquo;re using the &lt;a href="https://github.com/nginxinc/nginx-gateway-fabric">NGINX Gateway Fabric&lt;/a>.&lt;/p>
&lt;h2 id="whats-the-nginx-gateway-fabric">What&amp;rsquo;s the NGINX Gateway Fabric?&lt;/h2>
&lt;p>The NGINX Gateway Fabric is an implementation of the Kubernetes &lt;a href="https://gateway-api.sigs.k8s.io/">Gateway API&lt;/a>.&lt;/p>
&lt;h2 id="whats-the-gateway-api">What&amp;rsquo;s the Gateway API?&lt;/h2>
&lt;p>The Gateway API is an evolution of the &lt;a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress&lt;/a> API; it aims to provide a flexible mechanism for managing north/south network traffic (that is, traffic entering or exiting your Kubernetes cluster), with additional work to support east/west traffic (traffic between pods in your cluster).&lt;/p>
&lt;h2 id="whats-this-about-custom-configuration">What&amp;rsquo;s this about custom configuration?&lt;/h2>
&lt;p>I&amp;rsquo;ve deployed a local development cluster, and I wanted to be able to push images into an image registry hosted on the cluster. This requires (a) running a registry, which is easy, and (b) somehow exposing that registry outside the cluster, which is also easy unless you decide to make it more complex.&lt;/p>
&lt;p>In this case, I decided that rather than running an Ingress provider I was going to start familiarizing myself with the Gateway API, so I deployed NGINX Gateway Fabric. My first attempt at pushing an image into the registry looked like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ podman push --tls-verify=false example registry.apps.cluster1.house/example:latest
Getting image source signatures
Copying blob b9fe5313d237 done |
Copying blob cc2447e1835a done |
Copying blob cb8b0886acfb done |
Copying blob c4219a5645ea [===&amp;gt;----------------------------------] 9.3MiB / 80.2MiB | 372.7 MiB/s
Copying blob c6e5c62d1726 done |
Copying blob 9ee7eb11f876 done |
Copying blob f064c46326cb done |
Copying blob 9c45ffa2a02a done |
Copying blob 9a6c9897f309 done |
Copying blob 27a0dbb2828e done |
Error: writing blob: uploading layer chunked: StatusCode: 413, &amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;413 Request Entity Too Large&amp;lt;...
&lt;/code>&lt;/pre>&lt;p>Nginx, by default, restricts the maximum size of a request body to &lt;code>1m&lt;/code>, which is to say, 1 megabyte. You can increase (or remove) this limit by setting the &lt;a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">&lt;code>client_max_body_size&lt;/code>&lt;/a> parameter&amp;hellip;but how do you do this in the context of a managed deployment like the NGINX Gateway Fabric?&lt;/p>
&lt;h2 id="via-the-api">Via the API?&lt;/h2>
&lt;p>As of this writing, there is no mechanism to apply custom configuration options via the API (although there is ongoing work to provide this, see issue &lt;a href="https://github.com/nginxinc/nginx-gateway-fabric/issues/1258">#1258&lt;/a>).&lt;/p>
&lt;h2 id="what-about-dropping-a-config-file-into-confd">What about dropping a config file into conf.d?&lt;/h2>
&lt;p>My first thought was that I could mount a custom configuration file into &lt;code>/etc/nginx/conf.d&lt;/code>, along the lines of:&lt;/p>
&lt;pre tabindex="0">&lt;code>...
containers:
- name: nginx
volumeMounts:
- name: nginx-extra-conf
mountPath: /etc/nginx/conf.d/client_max_body_size.conf
subPath: client_max_body_size
...
volumes:
- name: nginx-extra-conf
configMap:
name: nginx-extra-conf
&lt;/code>&lt;/pre>&lt;p>&amp;hellip;but this fails because the Nginx controller &lt;a href="https://github.com/nginxinc/nginx-gateway-fabric/blob/7de105c7dd09ccfca5823d6941ac12c520257221/internal/mode/static/manager.go#L123-L129">explicitly cleans out that directory on startup&lt;/a> and is unhappy if it is unable to delete a file.&lt;/p>
&lt;h2 id="replacing-nginxconf">Replacing nginx.conf&lt;/h2>
&lt;p>Right now, the solution is to replace &lt;code>/etc/nginx/nginx.conf&lt;/code>. This is a relatively simple operation using &lt;a href="https://kustomize.io">kustomize&lt;/a> to apply a patch to the deployment manifests.&lt;/p>
&lt;h3 id="grab-the-original-configuration">Grab the original configuration&lt;/h3>
&lt;p>First, we need to retrieve the &lt;em>original&lt;/em> &lt;code>nginx.conf&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir configs
podman run --rm --entrypoint cat \
ghcr.io/nginxinc/nginx-gateway-fabric/nginx:1.0.0 /etc/nginx/nginx.conf &amp;gt; configs/nginx.conf
&lt;/code>&lt;/pre>&lt;p>Modify &lt;code>configs/nginx.conf&lt;/code> as necessary; in my case, I added the following line to the &lt;code>http&lt;/code> section:&lt;/p>
&lt;pre tabindex="0">&lt;code>client_max_body_size 0;
&lt;/code>&lt;/pre>&lt;h3 id="patch-the-deployment">Patch the deployment&lt;/h3>
&lt;p>We can deploy the stock NGINX Gateway Fabric with a &lt;code>kustomization.yaml&lt;/code> file like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
commonLabels:
nginxGatewayVersion: v1.0.0
resources:
- https://github.com/nginxinc/nginx-gateway-fabric/releases/download/v1.0.0/crds.yaml
- https://github.com/nginxinc/nginx-gateway-fabric/releases/download/v1.0.0/nginx-gateway.yaml
- https://raw.githubusercontent.com/nginxinc/nginx-gateway-fabric/v1.0.0/deploy/manifests/service/nodeport.yaml
&lt;/code>&lt;/pre>&lt;p>To patch the Deployment resource, we extend the &lt;code>kustomization.yaml&lt;/code> with the following patch:&lt;/p>
&lt;pre tabindex="0">&lt;code>patches:
- patch: |
apiVersion: apps/v1
kind: Deployment
metadata:
name: nginx-gateway
namespace: nginx-gateway
spec:
template:
spec:
containers:
- name: nginx
volumeMounts:
- mountPath: /etc/nginx/nginx.conf
name: nginx-conf-override
subPath: nginx.conf
volumes:
- name: nginx-conf-override
configMap:
name: nginx-conf-override
&lt;/code>&lt;/pre>&lt;p>And then we add a &lt;code>confdigMapGenerator&lt;/code> to generate the &lt;code>nginx-conf-override&lt;/code> ConfigMap:&lt;/p>
&lt;pre tabindex="0">&lt;code>configMapGenerator:
- name: nginx-conf-override
namespace: nginx-gateway
options:
disableNameSuffixHash: true
files:
- configs/nginx.conf
&lt;/code>&lt;/pre>&lt;p>Now when we deploy from this directory&amp;hellip;&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl apply -k . --server-side
&lt;/code>&lt;/pre>&lt;p>&amp;hellip;the deployment includes our patched &lt;code>nginx.conf&lt;/code> and we are able to successfully push images into the cluster registry.&lt;/p>
&lt;hr>
&lt;p>I&amp;rsquo;ve included the complete &lt;a href="https://blog.oddbit.com/post/2023-11-17-nginx-gateway-configuration/kustomization.yaml">&lt;code>kustomization.yaml&lt;/code>&lt;/a> alongside this post.&lt;/p></content></item><item><title>Managing containers with Pytest fixtures</title><link>https://blog.oddbit.com/post/2023-07-15-pytest-and-containers/</link><pubDate>Sat, 15 Jul 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-07-15-pytest-and-containers/</guid><description>&lt;p>A &lt;a href="https://en.wikipedia.org/wiki/Test_fixture#Software">software fixture&lt;/a> &amp;ldquo;sets up a system for the software testing process by initializing it, thereby satisfying any preconditions the system may have&amp;rdquo;. They allow us to perform setup and teardown tasks, provide state or set up services required for our tests, and perform other initialization tasks. In this article, we&amp;rsquo;re going to explore how to use fixtures in &lt;a href="https://docs.pytest.org/en/7.4.x/">Pytest&lt;/a> to create and tear down containers as part of a test run.&lt;/p></description><content>&lt;p>A &lt;a href="https://en.wikipedia.org/wiki/Test_fixture#Software">software fixture&lt;/a> &amp;ldquo;sets up a system for the software testing process by initializing it, thereby satisfying any preconditions the system may have&amp;rdquo;. They allow us to perform setup and teardown tasks, provide state or set up services required for our tests, and perform other initialization tasks. In this article, we&amp;rsquo;re going to explore how to use fixtures in &lt;a href="https://docs.pytest.org/en/7.4.x/">Pytest&lt;/a> to create and tear down containers as part of a test run.&lt;/p>
&lt;h2 id="pytest-fixtures">Pytest Fixtures&lt;/h2>
&lt;p>Pytest &lt;a href="https://docs.pytest.org/en/6.2.x/fixture.html">fixtures&lt;/a> are created through the use of the &lt;code>fixture&lt;/code> decorator. A fixture is accessed by including a function parameter with the fixture name in our test functions. For example, if we define an &lt;code>example&lt;/code> fixture:&lt;/p>
&lt;pre tabindex="0">&lt;code>@pytest.fixture
def example():
return &amp;#34;hello world&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Then we can write a test function like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>def test_something(example):
...
&lt;/code>&lt;/pre>&lt;p>And it will receive the string &amp;ldquo;hello world&amp;rdquo; as the value of the &lt;code>example&lt;/code> parameter.&lt;/p>
&lt;p>There are a number of built-in fixtures available; for example, the &lt;code>tmp_path&lt;/code> fixture provides access to a temporary directory that is unique to each test function. The following function would create a file named &lt;code>myfile&lt;/code> in the temporary directory; the file (in fact, the entire directory) will be removed automatically when the function completes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">test_something&lt;/span>(tmp_path):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> (tmp_path &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;myfile&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>open() &lt;span style="color:#66d9ef">as&lt;/span> fd:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fd&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A fixture can declare a &lt;a href="https://docs.pytest.org/en/6.2.x/fixture.html#scope-sharing-fixtures-across-classes-modules-packages-or-session">scope&lt;/a>; the default is the &lt;code>function&lt;/code> scope &amp;ndash; a new value will be generated for each function. A fixture can also be declared with a scope of &lt;code>class&lt;/code>, &lt;code>module&lt;/code>, &lt;code>package&lt;/code>, or &lt;code>session&lt;/code> (where &amp;ldquo;session&amp;rdquo; means, effectively, a distinct run of &lt;code>pytest&lt;/code>).&lt;/p>
&lt;p>Fixtures can be located in the same files as your tests, or they can be placed in a &lt;a href="https://docs.pytest.org/en/6.2.x/fixture.html#scope-sharing-fixtures-across-classes-modules-packages-or-session">&lt;code>conftest.py&lt;/code>&lt;/a> file where they can be shared between multiple sets of tests.&lt;/p>
&lt;h2 id="communicating-with-docker">Communicating with Docker&lt;/h2>
&lt;p>In order to manage containers as part of the test process we&amp;rsquo;re going to need to interact with Docker. While we could call out to the &lt;code>docker&lt;/code> CLI from our tests, a more graceful solution is to use the &lt;a href="https://docker-py.readthedocs.io/en/stable/">Docker client for Python&lt;/a>. That means we&amp;rsquo;ll need a Docker client instance, so we start with a very simple fixture:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> docker
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>(scope&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;session&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">docker_client&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;Return a Docker client&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> docker&lt;span style="color:#f92672">.&lt;/span>from_env()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This returns a Docker client initialized using values from the environment (in other words, it behaves very much like the &lt;code>docker&lt;/code> cli).&lt;/p>
&lt;p>I&amp;rsquo;ve made this a &lt;code>session&lt;/code> scoped fixture (which means we create one Docker client object at per pytest run, and every test using this fixture will receive the same object). This makes sense in general because a Docker client is stateless; there isn&amp;rsquo;t any data we need to reset between tests.&lt;/p>
&lt;h2 id="starting-a-container-version-1">Starting a container, version 1&lt;/h2>
&lt;p>For the purposes of this article, let&amp;rsquo;s assume we want to spin up a MariaDB server in a container. From the command line we might run something like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>docker run -d \
-e MARIADB_ROOT_PASSWORD=secret \
-e MARIADB_USER=testuser \
-e MARIADB_DATABASE=testdb \
mariadb:10
&lt;/code>&lt;/pre>&lt;p>Looking through the Docker &lt;a href="https://docker-py.readthedocs.io/en/stable/">python API documentation&lt;/a>, a naïve Python equivalent might look like this:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="976453182" type="checkbox" />
&lt;label for="976453182">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import docker
import pytest
@pytest.fixture
def mariadb_container(
docker_client,
):
&amp;#34;&amp;#34;&amp;#34;Create a MariaDB container&amp;#34;&amp;#34;&amp;#34;
container = docker_client.containers.run(
&amp;#34;docker.io/mariadb:11&amp;#34;,
detach=True,
environment={
&amp;#34;MARIADB_ROOT_PASSWORD&amp;#34;: &amp;#34;secret&amp;#34;,
&amp;#34;MYSQL_PWD&amp;#34;: &amp;#34;secret&amp;#34;,
&amp;#34;MARIADB_DATABASE&amp;#34;: &amp;#34;testdb&amp;#34;,
},
)
return container
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>This works, but it&amp;rsquo;s not great. In particular, the container we create will hang around until we remove it manually, since we didn&amp;rsquo;t arrange to remove the container on completion. Since this is a &lt;code>function&lt;/code> scoped fixture, we would end up with one container per test (potentially leading to hundreds of containers running for a large test suite).&lt;/p>
&lt;h2 id="starting-a-container-version-2">Starting a container, version 2&lt;/h2>
&lt;p>Let&amp;rsquo;s take care of the biggest problem with the previous implementation and ensure that our containers get cleaned up. We can add cleanup code to a fixture by using a &lt;a href="https://docs.pytest.org/en/6.2.x/fixture.html#yield-fixtures-recommended">yield fixture&lt;/a>; instead of &lt;code>return&lt;/code>-ing a value, we &lt;a href="https://docs.python.org/3/reference/expressions.html#yield-expressions">&lt;code>yield&lt;/code>&lt;/a> a value, and any cleanup code after the &lt;code>yield&lt;/code> statement runs when the fixture is no longer in scope.&lt;/p>
&lt;p>That might look like:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="283674915" type="checkbox" />
&lt;label for="283674915">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import docker
import pytest
@pytest.fixture
def mariadb_container(
docker_client,
):
&amp;#34;&amp;#34;&amp;#34;Create a MariaDB container&amp;#34;&amp;#34;&amp;#34;
container = docker_client.containers.run(
&amp;#34;docker.io/mariadb:11&amp;#34;,
detach=True,
environment={
&amp;#34;MARIADB_ROOT_PASSWORD&amp;#34;: &amp;#34;secret&amp;#34;,
&amp;#34;MYSQL_PWD&amp;#34;: &amp;#34;secret&amp;#34;,
&amp;#34;MARIADB_DATABASE&amp;#34;: &amp;#34;testdb&amp;#34;,
},
)
yield container
container.remove(force=True)
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>That&amp;rsquo;s better, but we&amp;rsquo;re not out of the woods yet. How would we use this fixture in a test? Maybe we would try something like this:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="432689517" type="checkbox" />
&lt;label for="432689517">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import mysql.connector
def test_simple_select(mariadb_container):
# get the address of the mariadb container
mariadb_container.reload()
addr = mariadb_container.attrs[&amp;#34;NetworkSettings&amp;#34;][&amp;#34;Networks&amp;#34;][&amp;#34;bridge&amp;#34;][&amp;#34;IPAddress&amp;#34;]
# create a connection objects
conn = mysql.connector.connect(
host=addr, user=&amp;#34;root&amp;#34;, password=&amp;#34;secret&amp;#34;, database=&amp;#34;testdb&amp;#34;
)
# try a simple select statement
curs = conn.cursor()
curs.execute(&amp;#34;select 1&amp;#34;)
res = curs.fetchone()
assert res[0] == 1
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>First of all, that&amp;rsquo;s not a great test; there&amp;rsquo;s too much setup happening in the test that we would have to repeat before every additional test. And more importantly, if you were to try to run that test it would probably fail with:&lt;/p>
&lt;pre tabindex="0">&lt;code>E mysql.connector.errors.InterfaceError: 2003: Can&amp;#39;t connect to MySQL
server on &amp;#39;172.17.0.2:3306&amp;#39; (111 Connection refused)
&lt;/code>&lt;/pre>&lt;p>The problem is that when we start the MariaDB container, MariaDB isn&amp;rsquo;t ready to handle connections immediately. It takes a couple of seconds after starting the container before the server is ready. Because we haven&amp;rsquo;t accounted for that in our test, there&amp;rsquo;s nothing listening when we try to connect.&lt;/p>
&lt;h2 id="a-step-back-and-a-moving-forward">A step back and a moving forward&lt;/h2>
&lt;p>To resolve the issues in the previous example, let&amp;rsquo;s first take a step back. For our test, we don&amp;rsquo;t actually &lt;em>want&lt;/em> a container; what we want is the ability to perform SQL queries in our test with a minimal amount of boilerplate. Ideally, our test would look more like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">test_simple_select&lt;/span>(mariadb_cursor):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curs&lt;span style="color:#f92672">.&lt;/span>execute(&lt;span style="color:#e6db74">&amp;#39;select 1&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> curs&lt;span style="color:#f92672">.&lt;/span>fetchone()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">assert&lt;/span> res[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>How do we get there?&lt;/p>
&lt;p>Working backwards, we would need a &lt;code>mariadb_cursor&lt;/code> fixture:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_cursor&lt;/span>(&lt;span style="color:#f92672">...&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But to get a database cursor, we need a database connection:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_connection&lt;/span>(&lt;span style="color:#f92672">...&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And to create a database connection, we need to know the address of the database server:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_host&lt;/span>(&lt;span style="color:#f92672">...&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s start filling in all those ellipses.&lt;/p>
&lt;p>What would the &lt;code>mariadb_host&lt;/code> fixture look like? We saw in our earlier test code how to get the address of a Docker container. Much like the situation with the database server, we want to account for the fact that it might take a nonzero amount of time for the container network setup to complete, so we can use a simple loop in which we check for the address and return it if it&amp;rsquo;s available, otherwise sleep a bit and try again:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_host&lt;/span>(mariadb_container):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mariadb_container&lt;span style="color:#f92672">.&lt;/span>reload()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networks &lt;span style="color:#f92672">=&lt;/span> list(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mariadb_container&lt;span style="color:#f92672">.&lt;/span>attrs[&lt;span style="color:#e6db74">&amp;#34;NetworkSettings&amp;#34;&lt;/span>][&lt;span style="color:#e6db74">&amp;#34;Networks&amp;#34;&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>values()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addr &lt;span style="color:#f92672">=&lt;/span> networks[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#e6db74">&amp;#34;IPAddress&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> addr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span> &lt;span style="color:#a6e22e">KeyError&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time&lt;span style="color:#f92672">.&lt;/span>sleep(&lt;span style="color:#ae81ff">0.5&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This works by repeatedly refreshing information about the container until we can find an ip address.&lt;/p>
&lt;p>Now that we have the address of the database server, we can create a connection:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_connection&lt;/span>(mariadb_host):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conn &lt;span style="color:#f92672">=&lt;/span> mysql&lt;span style="color:#f92672">.&lt;/span>connector&lt;span style="color:#f92672">.&lt;/span>connect(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> host&lt;span style="color:#f92672">=&lt;/span>mariadb_host, user&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>, password&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;secret&amp;#34;&lt;/span>, database&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;testdb&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> conn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span> mysql&lt;span style="color:#f92672">.&lt;/span>connector&lt;span style="color:#f92672">.&lt;/span>errors&lt;span style="color:#f92672">.&lt;/span>InterfaceError:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time&lt;span style="color:#f92672">.&lt;/span>sleep(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The logic here is very similar; we keep attempting to establish a connection until we&amp;rsquo;re successful, at which point we return the connection object.&lt;/p>
&lt;p>Now that we have a fixture that gives us a functioning database connection, we can use that to acquire a cursor:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> contextlib &lt;span style="color:#f92672">import&lt;/span> closing
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_cursor&lt;/span>(mariadb_connection):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> closing(mariadb_connection&lt;span style="color:#f92672">.&lt;/span>cursor()) &lt;span style="color:#66d9ef">as&lt;/span> cursor:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> cursor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing">&lt;code>closing&lt;/code>&lt;/a> method from the &lt;code>contextlib&lt;/code> module returns a &lt;a href="https://docs.python.org/3/library/stdtypes.html#context-manager-types">context manager&lt;/a> that calls the &lt;code>close&lt;/code> method on the given object when leaving the &lt;code>with&lt;/code> context; this ensures that the cursor is closed when we&amp;rsquo;re done with it. We could have accomplished the same thing by writing this instead:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_cursor&lt;/span>(mariadb_connection):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor &lt;span style="color:#f92672">=&lt;/span> mariadb_connection&lt;span style="color:#f92672">.&lt;/span>cursor()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> cursor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Putting all of this together gets us a &lt;code>conftest.py&lt;/code> that looks something like:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="872693541" type="checkbox" />
&lt;label for="872693541">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import pytest
import docker
import time
import mysql.connector
from contextlib import closing
@pytest.fixture(scope=&amp;#34;session&amp;#34;)
def docker_client():
&amp;#34;&amp;#34;&amp;#34;Return a Docker client&amp;#34;&amp;#34;&amp;#34;
return docker.from_env()
@pytest.fixture
def mariadb_container(
docker_client,
):
&amp;#34;&amp;#34;&amp;#34;Create a MariaDB container&amp;#34;&amp;#34;&amp;#34;
container = docker_client.containers.run(
&amp;#34;docker.io/mariadb:11&amp;#34;,
detach=True,
environment={
&amp;#34;MARIADB_ROOT_PASSWORD&amp;#34;: &amp;#34;secret&amp;#34;,
&amp;#34;MYSQL_PWD&amp;#34;: &amp;#34;secret&amp;#34;,
&amp;#34;MARIADB_DATABASE&amp;#34;: &amp;#34;testdb&amp;#34;,
},
)
yield container
container.remove(force=True)
@pytest.fixture
def mariadb_host(mariadb_container):
while True:
mariadb_container.reload()
try:
networks = list(
mariadb_container.attrs[&amp;#34;NetworkSettings&amp;#34;][&amp;#34;Networks&amp;#34;].values()
)
addr = networks[0][&amp;#34;IPAddress&amp;#34;]
return addr
except KeyError:
time.sleep(0.5)
@pytest.fixture
def mariadb_connection(mariadb_host):
while True:
try:
conn = mysql.connector.connect(
host=mariadb_host, user=&amp;#34;root&amp;#34;, password=&amp;#34;secret&amp;#34;, database=&amp;#34;testdb&amp;#34;
)
return conn
except mysql.connector.errors.InterfaceError:
time.sleep(1)
@pytest.fixture
def mariadb_cursor(mariadb_connection):
with closing(mariadb_connection.cursor()) as cursor:
yield cursor
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>And &lt;em>that&lt;/em> allows us to dramatically simplify our test:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="631258794" type="checkbox" />
&lt;label for="631258794">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
def test_simple_select(mariadb_cursor):
mariadb_cursor.execute(&amp;#34;select 1&amp;#34;)
res = mariadb_cursor.fetchone()
assert res[0] == 1
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>So we&amp;rsquo;ve accomplished our goal.&lt;/p>
&lt;h2 id="additional-improvements">Additional improvements&lt;/h2>
&lt;h3 id="things-were-ignoring">Things we&amp;rsquo;re ignoring&lt;/h3>
&lt;p>In order to keep this post to a reasonable size, we haven&amp;rsquo;t bothered to create an actual application, which means we haven&amp;rsquo;t had to worry about things like initializing the database schema. In reality, we would probably handle that in a new or existing fixture.&lt;/p>
&lt;h3 id="replaced-hardcoded-values">Replaced hardcoded values&lt;/h3>
&lt;p>While our fixture does the job, we&amp;rsquo;re using a number of hardcoded values (for the username, the database name, the password, etc). This isn&amp;rsquo;t inherently bad for a test environment, but it can sometimes mask errors in our code (for example, if we pick values that match default values in our code, we might miss errors that crop up when using non-default values).&lt;/p>
&lt;p>We can replace fixed strings with fixtures that produce random values (or values with a random component, if we want something a little more human readable). In the following example, we have a &lt;code>random_string&lt;/code> fixture that produces an 8 character random string, and then we use that to produce a password and a database name:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> random
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">random_string&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(random&lt;span style="color:#f92672">.&lt;/span>choices(string&lt;span style="color:#f92672">.&lt;/span>ascii_letters &lt;span style="color:#f92672">+&lt;/span> string&lt;span style="color:#f92672">.&lt;/span>digits, k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_dbpass&lt;/span>(random_string):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;secret-&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>random_string&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_dbname&lt;/span>(random_string):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;testdb-&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>random_string&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We would incorporate these into our existing fixtures wherever we need the database password or name:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@pytest.fixture&lt;/span>(scope&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;session&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mariadb_container&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> docker_client,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> random_string,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mariadb_dbpass,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mariadb_dbname,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;Create a MariaDB container&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> container &lt;span style="color:#f92672">=&lt;/span> docker_client&lt;span style="color:#f92672">.&lt;/span>containers&lt;span style="color:#f92672">.&lt;/span>run(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;docker.io/mariadb:11&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;mariadb-test-&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>random_string&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> detach&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment&lt;span style="color:#f92672">=&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;MARIADB_ROOT_PASSWORD&amp;#34;&lt;/span>: mariadb_dbpass,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;MYSQL_PWD&amp;#34;&lt;/span>: mariadb_dbpass,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;MARIADB_DATABASE&amp;#34;&lt;/span>: mariadb_dbname,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> container
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> container&lt;span style="color:#f92672">.&lt;/span>remove(force&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(and so forth)&lt;/p>
&lt;h3 id="consider-a-session-scoped-container">Consider a session scoped container&lt;/h3>
&lt;p>The fixtures we&amp;rsquo;ve developed in this post have all been &lt;code>function&lt;/code> scoped, which means that we&amp;rsquo;re creating and tearing down a container for every single function. This will substantially increase the runtime of our tests. We may want to consider using &lt;code>session&lt;/code> scoped fixtures instead; this would bring up a container and it use it for all our tests, only cleaning it up at the end of the test run.&lt;/p>
&lt;p>The advantage here is that the impact on the test run time is minimal. The disadvantage is that we have to be very careful about the interaction between tests, since we would no longer be starting each test with a clean version of the database.&lt;/p>
&lt;p>Keep in mind that in Pytest, a fixture can only reference other fixtures that come from the same or &amp;ldquo;broader&amp;rdquo; scope (so, a &lt;code>function&lt;/code> scoped fixture can use a &lt;code>session&lt;/code> scoped fixture, but the opposite is not true). In particular, that means if we were to make our &lt;code>mariadb_container&lt;/code> fixture &lt;code>session&lt;/code>-scoped, we would need to make the same change to its dependencies (&lt;code>mariadb_dbname&lt;/code>, &lt;code>mariadb_dbpass&lt;/code>, etc).&lt;/p>
&lt;hr>
&lt;p>You can find a version of &lt;code>conftest.py&lt;/code> with these changes &lt;a href="https://blog.oddbit.com/post/2023-07-15-pytest-and-containers/ex3/conftest.py">here&lt;/a>.&lt;/p></content></item><item><title>Directing different ports to different containers with Traefik</title><link>https://blog.oddbit.com/post/2022-06-20-traefik-multiple-listeners/</link><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2022-06-20-traefik-multiple-listeners/</guid><description>&lt;p>This post is mostly for myself: I find the &lt;a href="https://traefik.io">Traefik&lt;/a> documentation hard to navigate, so having figured this out in response to &lt;a href="https://stackoverflow.com/a/72694677/147356">a question on Stack Overflow&lt;/a>, I&amp;rsquo;m putting it here to help it stick in my head.&lt;/p>
&lt;p>The question asks essentially how to perform port-based routing of requests to containers, so that a request for &lt;code>http://example.com&lt;/code> goes to one container while a request for &lt;code>http://example.com:9090&lt;/code> goes to a different container.&lt;/p>
&lt;h2 id="creating-entrypoints">Creating entrypoints&lt;/h2>
&lt;p>A default Traefik configuration will already have a listener on port 80, but if we want to accept connections on port 9090 we need to create a new listener: what Traefik calls an &lt;a href="https://doc.traefik.io/traefik/routing/entrypoints/">entrypoint&lt;/a>. We do this using the &lt;code>--entrypoints.&amp;lt;name&amp;gt;.address&lt;/code> option. For example, &lt;code>--entrypoints.ep1.address=80&lt;/code> creates an entrypoint named &lt;code>ep1&lt;/code> on port 80, while &lt;code>--entrypoints.ep2.address=9090&lt;/code> creates an entrypoint named &lt;code>ep2&lt;/code> on port 9090. Those names are important because we&amp;rsquo;ll use them for mapping containers to the appropriate listener later on.&lt;/p></description><content>&lt;p>This post is mostly for myself: I find the &lt;a href="https://traefik.io">Traefik&lt;/a> documentation hard to navigate, so having figured this out in response to &lt;a href="https://stackoverflow.com/a/72694677/147356">a question on Stack Overflow&lt;/a>, I&amp;rsquo;m putting it here to help it stick in my head.&lt;/p>
&lt;p>The question asks essentially how to perform port-based routing of requests to containers, so that a request for &lt;code>http://example.com&lt;/code> goes to one container while a request for &lt;code>http://example.com:9090&lt;/code> goes to a different container.&lt;/p>
&lt;h2 id="creating-entrypoints">Creating entrypoints&lt;/h2>
&lt;p>A default Traefik configuration will already have a listener on port 80, but if we want to accept connections on port 9090 we need to create a new listener: what Traefik calls an &lt;a href="https://doc.traefik.io/traefik/routing/entrypoints/">entrypoint&lt;/a>. We do this using the &lt;code>--entrypoints.&amp;lt;name&amp;gt;.address&lt;/code> option. For example, &lt;code>--entrypoints.ep1.address=80&lt;/code> creates an entrypoint named &lt;code>ep1&lt;/code> on port 80, while &lt;code>--entrypoints.ep2.address=9090&lt;/code> creates an entrypoint named &lt;code>ep2&lt;/code> on port 9090. Those names are important because we&amp;rsquo;ll use them for mapping containers to the appropriate listener later on.&lt;/p>
&lt;p>This gives us a Traefik configuration that looks something like:&lt;/p>
&lt;pre tabindex="0">&lt;code> proxy:
image: traefik:latest
command:
- --api.insecure=true
- --providers.docker
- --entrypoints.ep1.address=:80
- --entrypoints.ep2.address=:9090
ports:
- &amp;#34;80:80&amp;#34;
- &amp;#34;127.0.0.1:8080:8080&amp;#34;
- &amp;#34;9090:9090&amp;#34;
volumes:
- /var/run/docker.sock:/var/run/docker.sock
&lt;/code>&lt;/pre>&lt;p>We need to publish ports &lt;code>80&lt;/code> and &lt;code>9090&lt;/code> on the host in order to accept connections. Port 8080 is by default the Traefik dashboard; in this configuration I have it bound to &lt;code>localhost&lt;/code> because I don&amp;rsquo;t want to provide external access to the dashboard.&lt;/p>
&lt;h2 id="routing-services">Routing services&lt;/h2>
&lt;p>Now we need to configure our services so that connections on ports 80 and 9090 will get routed to the appropriate containers. We do this using the &lt;code>traefik.http.routers.&amp;lt;name&amp;gt;.entrypoints&lt;/code> label. Here&amp;rsquo;s a simple example:&lt;/p>
&lt;pre tabindex="0">&lt;code>app1:
image: docker.io/alpinelinux/darkhttpd:latest
labels:
- traefik.http.routers.app1.entrypoints=ep1
- traefik.http.routers.app1.rule=Host(`example.com`)
&lt;/code>&lt;/pre>&lt;p>In the above configuration, we&amp;rsquo;re using the following labels:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>traefik.http.routers.app1.entrypoints=ep1&lt;/code>&lt;/p>
&lt;p>This binds our &lt;code>app1&lt;/code> container to the &lt;code>ep1&lt;/code> entrypoint.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>traefik.http.routers.app1.rule=Host(`example.com`)&lt;/code>&lt;/p>
&lt;p>This matches requests with &lt;code>Host: example.com&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>So in combination, these two rules say that any request on port 80 for &lt;code>Host: example.com&lt;/code> will be routed to the &lt;code>app1&lt;/code> container.&lt;/p>
&lt;p>To get port &lt;code>9090&lt;/code> routed to a second container, we add:&lt;/p>
&lt;pre tabindex="0">&lt;code>app2:
image: docker.io/alpinelinux/darkhttpd:latest
labels:
- traefik.http.routers.app2.rule=Host(`example.com`)
- traefik.http.routers.app2.entrypoints=ep2
&lt;/code>&lt;/pre>&lt;p>This is the same thing, except we use entrypoint &lt;code>ep2&lt;/code>.&lt;/p>
&lt;p>With everything running, we can watch the logs from &lt;code>docker-compose up&lt;/code> and see that a request on port 80:&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -H &amp;#39;host: example.com&amp;#39; localhost
&lt;/code>&lt;/pre>&lt;p>Is serviced by &lt;code>app1&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>app1_1 | 172.20.0.2 - - [21/Jun/2022:02:44:11 +0000] &amp;#34;GET / HTTP/1.1&amp;#34; 200 354 &amp;#34;&amp;#34; &amp;#34;curl/7.76.1&amp;#34;
&lt;/code>&lt;/pre>&lt;p>And that request on port 9090:&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -H &amp;#39;host: example.com&amp;#39; localhost:9090
&lt;/code>&lt;/pre>&lt;p>Is serviced by &lt;code>app2&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>app2_1 | 172.20.0.2 - - [21/Jun/2022:02:44:39 +0000] &amp;#34;GET / HTTP/1.1&amp;#34; 200 354 &amp;#34;&amp;#34; &amp;#34;curl/7.76.1&amp;#34;
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>The complete &lt;code>docker-compose.yaml&lt;/code> file from this post looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>version: &amp;#34;3&amp;#34;
services:
proxy:
image: traefik:latest
command:
- --api.insecure=true
- --providers.docker
- --entrypoints.ep1.address=:80
- --entrypoints.ep2.address=:9090
ports:
- &amp;#34;80:80&amp;#34;
- &amp;#34;8080:8080&amp;#34;
- &amp;#34;9090:9090&amp;#34;
volumes:
- /var/run/docker.sock:/var/run/docker.sock
app1:
image: docker.io/alpinelinux/darkhttpd:latest
labels:
- traefik.http.routers.app1.rule=Host(`example.com`)
- traefik.http.routers.app1.entrypoints=ep1
app2:
image: docker.io/alpinelinux/darkhttpd:latest
labels:
- traefik.http.routers.app2.rule=Host(`example.com`)
- traefik.http.routers.app2.entrypoints=ep2
&lt;/code>&lt;/pre></content></item><item><title>Systemd-nspawn for fun and...well, mostly for fun</title><link>https://blog.oddbit.com/post/2016-02-07-systemd-nspawn-for-fun-and-wel/</link><pubDate>Sun, 07 Feb 2016 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2016-02-07-systemd-nspawn-for-fun-and-wel/</guid><description>&lt;p>&lt;code>systemd-nspawn&lt;/code> has been called &lt;a href="https://wiki.archlinux.org/index.php/Systemd-nspawn">&amp;ldquo;chroot on steroids&amp;rdquo;&lt;/a>,
but if you think of it as &lt;a href="http://docker.com">Docker&lt;/a> with a slightly different target
you wouldn&amp;rsquo;t be far wrong, either. It can be used to spawn containers
on your host, and has a variety of options for configuring the
containerized environment through the use of private networking, bind
mounts, capability controls, and a variety of other facilities that
give you flexible container management.&lt;/p>
&lt;p>There are many different ways in which it can be used. I&amp;rsquo;m going to
focus on one that&amp;rsquo;s a bit of a corner use case that I find
particularly interesting. In this article we&amp;rsquo;re going to explore how
we can use &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html">systemd-nspawn&lt;/a> to spawn lightweight containers for
architectures other than that of our host system.&lt;/p></description><content>&lt;p>&lt;code>systemd-nspawn&lt;/code> has been called &lt;a href="https://wiki.archlinux.org/index.php/Systemd-nspawn">&amp;ldquo;chroot on steroids&amp;rdquo;&lt;/a>,
but if you think of it as &lt;a href="http://docker.com">Docker&lt;/a> with a slightly different target
you wouldn&amp;rsquo;t be far wrong, either. It can be used to spawn containers
on your host, and has a variety of options for configuring the
containerized environment through the use of private networking, bind
mounts, capability controls, and a variety of other facilities that
give you flexible container management.&lt;/p>
&lt;p>There are many different ways in which it can be used. I&amp;rsquo;m going to
focus on one that&amp;rsquo;s a bit of a corner use case that I find
particularly interesting. In this article we&amp;rsquo;re going to explore how
we can use &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html">systemd-nspawn&lt;/a> to spawn lightweight containers for
architectures other than that of our host system.&lt;/p>
&lt;h2 id="why-systemd-nspawn">Why systemd-nspawn?&lt;/h2>
&lt;p>While everything described in this article could be accomplished
through the use of &lt;code>chroot&lt;/code> and a chunk of additional configuration,
using &lt;code>systemd-nspawn&lt;/code> makes it much easier. For example,
&lt;code>systemd-nspawn&lt;/code> takes care of making virtual filesystems like
&lt;code>/proc&lt;/code>, &lt;code>/sys&lt;/code>, and a minimal &lt;code>/dev&lt;/code> available inside the container
(without which some programs simply won&amp;rsquo;t work). And of course
&lt;code>systemd-nspawn&lt;/code> takes care of cleaning up these mounts when the
container exits. For a simple container, this:&lt;/p>
&lt;pre>&lt;code># systemd-nspawn -D /mnt /some/command
&lt;/code>&lt;/pre>
&lt;p>Is roughly equivalent to:&lt;/p>
&lt;pre>&lt;code># mount -o bind /proc /mnt/proc
# mount -o bind /sys /mnt/sys
# mount -t tmpfs tmpfs /mnt/run
# mount -t tmpfs tmpfs /mnt/dev
# ...populate /mnt/dev here...
# chroot /mnt /some/command
# umount /mnt/dev
# umount /mnt/run
# umount /mnt/sys
# umount /mnt/proc
&lt;/code>&lt;/pre>
&lt;p>&lt;code>systemd-nspawn&lt;/code> does all of this for us, and does much of it via
private mount namespaces so that the temporary filesystems aren&amp;rsquo;t
visible from the host.&lt;/p>
&lt;h2 id="in-which-we-perform-magic">In which we perform magic&lt;/h2>
&lt;p>Linux allows you to run binaries intended for other architectures
via the &lt;a href="https://www.kernel.org/doc/Documentation/binfmt_misc.txt">binfmt-misc&lt;/a> subsystem, which allows you to use bits at the
beginning of a file to match against an appropriate interpreter. This
can be used, for example, to make Java binaries directly executable.
We&amp;rsquo;re going to use this technique to accomplish the following:&lt;/p>
&lt;ul>
&lt;li>Teach our system how to run Raspberry Pi ARM binaries, and&lt;/li>
&lt;li>Allow us to spawn a &lt;code>systemd-nspawn&lt;/code> container into a Raspberry Pi
filesystem.&lt;/li>
&lt;/ul>
&lt;p>When a &lt;code>systemd&lt;/code>-based system boots, the &lt;a href="https://www.freedesktop.org/software/systemd/man/binfmt.d.html">systemd-binfmt&lt;/a> service
(if it&amp;rsquo;s enabled) will automatically register configurations found in
&lt;code>/etc/binfmt.d&lt;/code> or &lt;code>/usr/lib/binfmt.d&lt;/code>. You can set these up by hand,
of course, but we&amp;rsquo;re going to take the easy route and install the
&lt;code>qemu-user-static&lt;/code> package, which includes both the necessary &lt;code>binfmt.d&lt;/code>
configuration files as well as the associated emulators:&lt;/p>
&lt;pre>&lt;code># dnf -y install qemu-user-static
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>qemu-user-static&lt;/code> package on my system has installed, among other files,
&lt;code>/usr/lib/binfmt.d/qemu-arm.conf&lt;/code>, which looks like this:&lt;/p>
&lt;pre>&lt;code>:qemu-arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-arm-static:
&lt;/code>&lt;/pre>
&lt;p>This gets registered with &lt;code>/proc/sys/fs/binfmt_misc/register&lt;/code> and
informs the kernel that there is a new binfmt called &lt;code>qemu-arm&lt;/code>, and
that files that contain the specified byte pattern in the header
should be handled with &lt;code>/usr/bin/qemu-arm-static&lt;/code>.&lt;/p>
&lt;p>With all this set up, we can mount a Raspberry Pi filesystem (I&amp;rsquo;m
starting with &lt;a href="https://minibianpi.wordpress.com/">minibian&lt;/a>)&amp;hellip;&lt;/p>
&lt;pre>&lt;code># tar xf 2015-11-12-jessie-minibian.tar.gz
# losetup -fP --show 2015-11-12-jessie-minibian.img
/dev/loop1
# mount /dev/loop1p2 /mnt
# mount /dev/loop1p1 /mnt/boot
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;and then start up a process in it:&lt;/p>
&lt;pre>&lt;code># systemd-nspawn -D /mnt
Spawning container mnt on /mnt.
Press ^] three times within 1s to kill container.
root@mnt:~#
&lt;/code>&lt;/pre>
&lt;p>And there we are! We&amp;rsquo;re now running a shell inside a container
running an ARM userspace. We can modify the image by installing or
udpating packages or making any other necessary configuration changes:&lt;/p>
&lt;pre>&lt;code>root@mnt:/# apt-get install raspberrypi-bootloader
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following extra packages will be installed:
libraspberrypi-bin libraspberrypi0
The following packages will be upgraded:
libraspberrypi-bin libraspberrypi0 raspberrypi-bootloader
3 upgraded, 0 newly installed, 0 to remove and 34 not upgraded.
Need to get 32.5 MB of archives.
After this operation, 827 kB of additional disk space will be used.
Do you want to continue? [Y/n]
&lt;/code>&lt;/pre>
&lt;p>When we&amp;rsquo;re done, we exit our container:&lt;/p>
&lt;pre>&lt;code>root#mnt:/# exit
&lt;/code>&lt;/pre>
&lt;p>Unmount the directory:o&lt;/p>
&lt;pre>&lt;code># umount /mnt
&lt;/code>&lt;/pre>
&lt;p>And finally clean up the loopback device:&lt;/p>
&lt;pre>&lt;code># losetup -d /dev/loop1
&lt;/code>&lt;/pre>
&lt;p>Now we have an updated image file that we can write to an SD card and
use to boot our Raspberry Pi.&lt;/p>
&lt;p>&lt;strong>NB&lt;/strong> You&amp;rsquo;ll note that in this document I&amp;rsquo;m mounting &lt;code>loop1p2&lt;/code> on &lt;code>/&lt;/code>
and &lt;code>loop1p1&lt;/code> on &lt;code>/boot&lt;/code>. You obviously don&amp;rsquo;t need &lt;code>/boot&lt;/code> in your
container in order for things to run, but you will regret not mounting
it if you happen to install an updated kernel package, which needs to
populate &lt;code>/boot&lt;/code> with the new kernel image.&lt;/p>
&lt;h2 id="bonus-growing-the-image">Bonus: growing the image&lt;/h2>
&lt;p>The stock &lt;a href="https://minibianpi.wordpress.com/">minibian&lt;/a> image doesn&amp;rsquo;t have much free space on it; this
is intentional, and in general you&amp;rsquo;re expected to grow the root
partition and resize the filesystem after booting on your Pi.
However, if we&amp;rsquo;re going to use the above process to pre-configure our
image, there&amp;rsquo;s a good chance we&amp;rsquo;ll need more space immediately. We
start by growing the size of the image file itself; you can that with
&lt;code>qemu-img&lt;/code>, like this:&lt;/p>
&lt;pre>&lt;code># qemu-img resize 2015-11-12-jessie-minibian.img 2G
&lt;/code>&lt;/pre>
&lt;p>Or by using &lt;code>truncate&lt;/code>:&lt;/p>
&lt;pre>&lt;code># truncate -s 2G 2015-11-12-jessie-minibian.img
&lt;/code>&lt;/pre>
&lt;p>Or by using &lt;code>dd&lt;/code>:&lt;/p>
&lt;pre>&lt;code># dd of=2015-11-12-jessie-minibian.img if=/dev/zero \
count=0 bs=1G seek=2
&lt;/code>&lt;/pre>
&lt;p>Once the file has been extended, we need to grow the corresponding
partition. Assuming that you have a recent version of &lt;code>util-linux&lt;/code>
(where &amp;ldquo;recent&amp;rdquo; means &amp;ldquo;at least &lt;a href="http://karelzak.blogspot.com/2015/05/resize-by-sfdisk.html">v2.26.2&lt;/a>) installed, this is easy:&lt;/p>
&lt;pre>&lt;code># echo &amp;quot;, +&amp;quot; | sfdisk -N 2 2015-11-12-jessie-minibian.img
&lt;/code>&lt;/pre>
&lt;p>And lastly, we need to grow the filesystem. This requires
attaching the image to a loop device:&lt;/p>
&lt;pre>&lt;code># losetup -fP --show 2015-11-12-jessie-minibian.img
/dev/loop1
&lt;/code>&lt;/pre>
&lt;p>And then:&lt;/p>
&lt;pre>&lt;code># e2fsck -f /dev/loop1p2
# resize2fs /dev/loop1p2
&lt;/code>&lt;/pre>
&lt;p>Now when we mount the filesystem:&lt;/p>
&lt;pre>&lt;code># mount /dev/loop1p2 /mnt
# mount /dev/loop1p1 /mnt/boot
&lt;/code>&lt;/pre>
&lt;p>We see that there is more space available:&lt;/p>
&lt;pre>&lt;code># df -h /mnt
Filesystem Size Used Avail Use% Mounted on
/dev/loop1p2 1.9G 432M 1.4G 24% /mnt
&lt;/code>&lt;/pre>
&lt;h2 id="bonus-static-qemu-arm-binaries">Bonus: Static qemu-arm binaries&lt;/h2>
&lt;p>Earlier we saw that it was necessary to mount &lt;code>/lib64&lt;/code> into my
Raspberry Pi container because the &lt;code>qemu-arm&lt;/code> binary was dynamically
linked. You can acquire statically built versions of the QEMU
binaries from the Debian project, e.g., &lt;a href="https://packages.debian.org/sid/amd64/qemu-user-static/download">here&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://packages.debian.org/sid/amd64/qemu-user-static/download">https://packages.debian.org/sid/amd64/qemu-user-static/download&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Then unpack the &lt;code>.deb&lt;/code> file and extract the &lt;code>qemu-arm-static&lt;/code> binary:&lt;/p>
&lt;pre>&lt;code>$ ar xv qemu-user-static_2.5+dfsg-5_amd64.deb
x - debian-binary
x - control.tar.gz
x - data.tar.xz
$ tar xf data.tar.xz ./usr/bin/qemu-arm-static
&lt;/code>&lt;/pre>
&lt;p>And copy it into place:&lt;/p>
&lt;pre>&lt;code># cp qemu-arm-static /usr/bin/qemu-arm
&lt;/code>&lt;/pre>
&lt;p>And now our earlier command will work without further modification:&lt;/p>
&lt;pre>&lt;code># systemd-nspawn -q --bind /usr/bin/qemu-arm -D /mnt /bin/bash
root@mnt:/#
&lt;/code>&lt;/pre></content></item></channel></rss>