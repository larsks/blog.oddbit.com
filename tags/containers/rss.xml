<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Containers on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/containers/</link><description>Recent content in Containers on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Fri, 17 Nov 2023 23:20:19 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/containers/rss.xml" rel="self" type="application/rss+xml"/><item><title>Applying custom configuration to Nginx Gateway Fabric</title><link>https://blog.oddbit.com/post/2023-11-17-nginx-gateway-configuration/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-11-17-nginx-gateway-configuration/</guid><description>&lt;p&gt;In this post, we take a look at how to apply custom Nginx configuration directives when you&amp;rsquo;re using the &lt;a href="https://github.com/nginxinc/nginx-gateway-fabric"&gt;NGINX Gateway Fabric&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="whats-the-nginx-gateway-fabric"&gt;What&amp;rsquo;s the NGINX Gateway Fabric?&lt;/h2&gt;
&lt;p&gt;The NGINX Gateway Fabric is an implementation of the Kubernetes &lt;a href="https://gateway-api.sigs.k8s.io/"&gt;Gateway API&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="whats-the-gateway-api"&gt;What&amp;rsquo;s the Gateway API?&lt;/h2&gt;
&lt;p&gt;The Gateway API is an evolution of the &lt;a href="https://kubernetes.io/docs/concepts/services-networking/ingress/"&gt;Ingress&lt;/a&gt; API; it aims to provide a flexible mechanism for managing north/south network traffic (that is, traffic entering or exiting your Kubernetes cluster), with additional work to support east/west traffic (traffic between pods in your cluster).&lt;/p&gt;</description></item><item><title>Managing containers with Pytest fixtures</title><link>https://blog.oddbit.com/post/2023-07-15-pytest-and-containers/</link><pubDate>Sat, 15 Jul 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-07-15-pytest-and-containers/</guid><description>&lt;p&gt;A &lt;a href="https://en.wikipedia.org/wiki/Test_fixture#Software"&gt;software fixture&lt;/a&gt; &amp;ldquo;sets up a system for the software testing process by initializing it, thereby satisfying any preconditions the system may have&amp;rdquo;. They allow us to perform setup and teardown tasks, provide state or set up services required for our tests, and perform other initialization tasks. In this article, we&amp;rsquo;re going to explore how to use fixtures in &lt;a href="https://docs.pytest.org/en/7.4.x/"&gt;Pytest&lt;/a&gt; to create and tear down containers as part of a test run.&lt;/p&gt;</description></item><item><title>Directing different ports to different containers with Traefik</title><link>https://blog.oddbit.com/post/2022-06-20-traefik-multiple-listeners/</link><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2022-06-20-traefik-multiple-listeners/</guid><description>&lt;p&gt;This post is mostly for myself: I find the &lt;a href="https://traefik.io"&gt;Traefik&lt;/a&gt; documentation hard to navigate, so having figured this out in response to &lt;a href="https://stackoverflow.com/a/72694677/147356"&gt;a question on Stack Overflow&lt;/a&gt;, I&amp;rsquo;m putting it here to help it stick in my head.&lt;/p&gt;
&lt;p&gt;The question asks essentially how to perform port-based routing of requests to containers, so that a request for &lt;code&gt;http://example.com&lt;/code&gt; goes to one container while a request for &lt;code&gt;http://example.com:9090&lt;/code&gt; goes to a different container.&lt;/p&gt;
&lt;h2 id="creating-entrypoints"&gt;Creating entrypoints&lt;/h2&gt;
&lt;p&gt;A default Traefik configuration will already have a listener on port 80, but if we want to accept connections on port 9090 we need to create a new listener: what Traefik calls an &lt;a href="https://doc.traefik.io/traefik/routing/entrypoints/"&gt;entrypoint&lt;/a&gt;. We do this using the &lt;code&gt;--entrypoints.&amp;lt;name&amp;gt;.address&lt;/code&gt; option. For example, &lt;code&gt;--entrypoints.ep1.address=80&lt;/code&gt; creates an entrypoint named &lt;code&gt;ep1&lt;/code&gt; on port 80, while &lt;code&gt;--entrypoints.ep2.address=9090&lt;/code&gt; creates an entrypoint named &lt;code&gt;ep2&lt;/code&gt; on port 9090. Those names are important because we&amp;rsquo;ll use them for mapping containers to the appropriate listener later on.&lt;/p&gt;</description></item><item><title>Systemd-nspawn for fun and...well, mostly for fun</title><link>https://blog.oddbit.com/post/2016-02-07-systemd-nspawn-for-fun-and-wel/</link><pubDate>Sun, 07 Feb 2016 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2016-02-07-systemd-nspawn-for-fun-and-wel/</guid><description>&lt;p&gt;&lt;code&gt;systemd-nspawn&lt;/code&gt; has been called &lt;a href="https://wiki.archlinux.org/index.php/Systemd-nspawn"&gt;&amp;ldquo;chroot on steroids&amp;rdquo;&lt;/a&gt;,
but if you think of it as &lt;a href="http://docker.com"&gt;Docker&lt;/a&gt; with a slightly different target
you wouldn&amp;rsquo;t be far wrong, either. It can be used to spawn containers
on your host, and has a variety of options for configuring the
containerized environment through the use of private networking, bind
mounts, capability controls, and a variety of other facilities that
give you flexible container management.&lt;/p&gt;
&lt;p&gt;There are many different ways in which it can be used. I&amp;rsquo;m going to
focus on one that&amp;rsquo;s a bit of a corner use case that I find
particularly interesting. In this article we&amp;rsquo;re going to explore how
we can use &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html"&gt;systemd-nspawn&lt;/a&gt; to spawn lightweight containers for
architectures other than that of our host system.&lt;/p&gt;</description></item></channel></rss>