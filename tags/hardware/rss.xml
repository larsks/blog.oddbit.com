<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hardware on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/hardware/</link><description>Recent content in Hardware on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 12:29:07 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/hardware/rss.xml" rel="self" type="application/rss+xml"/><item><title>Vortex Core Keyboard Review</title><link>https://blog.oddbit.com/post/2020-09-26-vortex-core-keyboard-review/</link><pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-09-26-vortex-core-keyboard-review/</guid><description>&lt;p&gt;I&amp;rsquo;ve had my eye on the &lt;a href="http://www.vortexgear.tw/vortex2_2.asp?kind=47&amp;amp;kind2=224&amp;amp;kind3=&amp;amp;kind4=1033"&gt;Vortex Core&lt;/a&gt; keyboard for a few months now, and this
past week I finally broke down and bought one (with Cherry MX Brown switches).
The Vortex Core is a 40% keyboard, which means it consists primarily of letter
keys, a few lonely bits of punctuation, and several modifier keys to activate
different layers on the keyboard.&lt;/p&gt;
&lt;h2 id="physical-impressions"&gt;Physical impressions&lt;/h2&gt;
&lt;p&gt;It&amp;rsquo;s a really cute keyboard. I&amp;rsquo;m a big fan of MX brown switches, and this
keyboard is really a joy to type on, at least when you&amp;rsquo;re working primarily
with the alpha keys. I&amp;rsquo;m still figuring out where some of the punctuation
is, and with a few exceptions I haven&amp;rsquo;t yet spent time trying to remap
things into more convenient positions.&lt;/p&gt;</description></item><item><title>Multiple 1-Wire Buses on the Raspberry Pi</title><link>https://blog.oddbit.com/post/2018-03-27-multiple-1-wire-buses-on-the-/</link><pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-03-27-multiple-1-wire-buses-on-the-/</guid><description>&lt;p&gt;The DS18B20 is a popular temperature sensor that uses the &lt;a href="https://en.wikipedia.org/wiki/1-Wire"&gt;1-Wire&lt;/a&gt;
protocol for communication. Recent versions of the Linux kernel
include a kernel driver for this protocol, making it relatively
convenient to connect one or more of these devices to a Raspberry Pi
or similar device. 1-Wire devices can be daisy chained, so it is
possible to connect several devices to your Pi using only a single
GPIO pin, and you&amp;rsquo;ll find many articles out there that describe how to
do so.&lt;/p&gt;</description></item><item><title>I2C on the Raspberry Pi</title><link>https://blog.oddbit.com/post/2013-03-12-i2c-on-the-raspberry/</link><pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-12-i2c-on-the-raspberry/</guid><description>&lt;p&gt;I&amp;rsquo;ve set up my &lt;a href="http://www.raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; to communicate with my &lt;a href="http://www.arduino.cc/"&gt;Arduino&lt;/a&gt; via
&lt;a href="http://en.wikipedia.org/wiki/I%C2%B2C"&gt;I2C&lt;/a&gt;. The Raspberry Pi is a 3.3v device and the Arduino is a 5v
device. While in general this means that you need to use a level
converter when connecting the two devices, &lt;strong&gt;you don&amp;rsquo;t need to use a
level converter when connecting the Arduino to the Raspberry Pi via
I2C.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The design of the I2C bus is such that the only device driving a
voltage on the bus is the master (in this case, the Raspberry Pi), via
pull-up resistors. So when &amp;ldquo;idle&amp;rdquo;, the bus is pulled to 3.3v volts by
the Pi, which is perfectly safe for the Arduino (and compatible with
it&amp;rsquo;s 5v signaling). To transmit data on the bus, a device brings the
bus low by connecting it to ground. In other words, slave devices
&lt;em&gt;never&lt;/em&gt; drive the bus high. This means that the Raspberry Pi will
never see a 5v signal from the Arduino&amp;hellip;unless, of course, you make a
mistake and accidentally &lt;code&gt;digitalWrite&lt;/code&gt; a &lt;code&gt;HIGH&lt;/code&gt; value on one of the
Arduino&amp;rsquo;s &lt;code&gt;I2C&lt;/code&gt; pins. So don&amp;rsquo;t do that.&lt;/p&gt;</description></item><item><title>Interrupt driven GPIO with Python</title><link>https://blog.oddbit.com/post/2013-03-08-interrupt-driven-gpi/</link><pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-08-interrupt-driven-gpi/</guid><description>&lt;p&gt;There are several Python libraries out there for interacting with the
&lt;a href="https://en.wikipedia.org/wiki/General_Purpose_Input/Output"&gt;GPIO&lt;/a&gt; pins on a Raspberry Pi:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/RPi.GPIO"&gt;RPi.GPIO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/WiringPi/WiringPi-Python"&gt;WiringPi&lt;/a&gt; bindings for Python, and&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/quick2wire/quick2wire-python-api"&gt;Quick2Wire&lt;/a&gt; Python API (which depends on Python 3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of them are reasonably easy to use, but the Quick2Wire API
provides a uniquely useful feature: &lt;code&gt;epoll&lt;/code&gt;-enabled GPIO interrupts.
This makes it trivial to write code that efficiently waits for and
responds to things like button presses.&lt;/p&gt;
&lt;p&gt;The following simple example waits for a button press attached to
&lt;code&gt;GPIO1&lt;/code&gt; (but refer to the chart in &lt;a href="https://projects.drogon.net/raspberry-pi/wiringpi/pins/"&gt;this document&lt;/a&gt; to see
exactly what that means; this is pin 12 on a Raspberry Pi v2 board)
and lights an LED attached to &lt;code&gt;GPIO0&lt;/code&gt; when the button is pressed:&lt;/p&gt;</description></item><item><title>Controlling a servo with your Arduino</title><link>https://blog.oddbit.com/post/2013-03-07-controlling-a-servo/</link><pubDate>Thu, 07 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-07-controlling-a-servo/</guid><description>&lt;p&gt;I&amp;rsquo;ve recently started playing with an &lt;a href="http://arduino.cc/"&gt;Arduino&lt;/a&gt; kit I purchased a year
ago (and only just now got around to unboxing). I purchased the kit
from &lt;a href="https://www.sparkfun.com/"&gt;SparkFun&lt;/a&gt;, and it includes a motley collection of resistors,
LEDs, a motor, a servo, and more.&lt;/p&gt;
&lt;p&gt;I was fiddling around with &lt;a href="http://oomlout.com/a/products/ardx/circ-04/"&gt;this exercise&lt;/a&gt;, which uses the
&lt;code&gt;SoftwareServo&lt;/code&gt; library to control a servo. Using this library,
you just pass it an angle and the library takes care of everything
else, e.g. to rotate to 90 degrees you would do this:&lt;/p&gt;</description></item></channel></rss>