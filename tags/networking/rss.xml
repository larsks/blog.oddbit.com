<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Networking on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/networking/</link><description>Recent content in Networking on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Sun, 19 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/networking/rss.xml" rel="self" type="application/rss+xml"/><item><title>NAT between identical networks using VRF</title><link>https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/</link><pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/</guid><description>&lt;p>Last week, Oskar Stenberg asked on &lt;a href="https://unix.stackexchange.com/q/735931/4989">Unix &amp;amp; Linux&lt;/a> if it were possible to configure connectivity between two networks, both using the same address range, without involving network namespaces. That is, given this high level view of the network&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://excalidraw.com/#json=uuXRRZ2ybaAXiUvbQVkNO,krx3lsbf12c-tDhuWtRjbg">&lt;img alt="two networks with the same address range connected by a host named &amp;ldquo;middleman&amp;rdquo;" src="https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/the-problem.svg">&lt;/a>&lt;/p>
&lt;p>&amp;hellip;can we set things up so that hosts on the &amp;ldquo;inner&amp;rdquo; network can communicate with hosts on the &amp;ldquo;outer&amp;rdquo; network using the range &lt;code>192.168.3.0/24&lt;/code>, and similarly for communication in the other direction?&lt;/p></description><content>&lt;p>Last week, Oskar Stenberg asked on &lt;a href="https://unix.stackexchange.com/q/735931/4989">Unix &amp;amp; Linux&lt;/a> if it were possible to configure connectivity between two networks, both using the same address range, without involving network namespaces. That is, given this high level view of the network&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://excalidraw.com/#json=uuXRRZ2ybaAXiUvbQVkNO,krx3lsbf12c-tDhuWtRjbg">&lt;img alt="two networks with the same address range connected by a host named &amp;ldquo;middleman&amp;rdquo;" src="https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/the-problem.svg">&lt;/a>&lt;/p>
&lt;p>&amp;hellip;can we set things up so that hosts on the &amp;ldquo;inner&amp;rdquo; network can communicate with hosts on the &amp;ldquo;outer&amp;rdquo; network using the range &lt;code>192.168.3.0/24&lt;/code>, and similarly for communication in the other direction?&lt;/p>
&lt;h2 id="setting-up-a-lab">Setting up a lab&lt;/h2>
&lt;p>When investigating this sort of networking question, I find it easiest to reproduce the topology in a virtual environment so that it&amp;rsquo;s easy to test things out. I generally use &lt;a href="https://mininet.org">Mininet&lt;/a> for this, which provides a simple Python API for creating virtual nodes and switches and creating links between them.&lt;/p>
&lt;p>I created the following network topology for this test:&lt;/p>
&lt;figure class="center" >
&lt;img src="topology-1.svg" alt="virtual network topology diagram" />
&lt;/figure>
&lt;p>In the rest of this post, I&amp;rsquo;ll be referring to these hostnames.&lt;/p>
&lt;p>See the bottom of this post for a link to the repository that contains the complete test environment.&lt;/p>
&lt;h2 id="vrf-in-theory">VRF in theory&lt;/h2>
&lt;p>VRF stands for &amp;ldquo;Virtual Routing and Forwarding&amp;rdquo;. From the &lt;a href="https://en.wikipedia.org/wiki/Virtual_routing_and_forwarding">Wikipedia article on the topic&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>In IP-based computer networks, virtual routing and forwarding (VRF) is a technology that allows multiple instances of a routing table to co-exist within the same router at the same time. One or more logical or physical interfaces may have a VRF and these VRFs do not share routes therefore the packets are only forwarded between interfaces on the same VRF. VRFs are the TCP/IP layer 3 equivalent of a VLAN. Because the routing instances are independent, the same or overlapping IP addresses can be used without conflicting with each other. Network functionality is improved because network paths can be segmented without requiring multiple routers.&lt;a href="https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/the-problem.svg">1&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>In Linux, VRF support is implemented as a &lt;a href="https://docs.kernel.org/networking/vrf.html">special type of network device&lt;/a>. A VRF device sets up an isolated routing domain; network traffic on devices associated with a VRF will use the routing table associated with that VRF, rather than the main routing table, which permits us to connect multiple networks with overlapping address ranges.&lt;/p>
&lt;p>We can create new VRF devices with the &lt;code>ip link add&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add vrf-inner type vrf table 100
&lt;/code>&lt;/pre>&lt;p>Running the above command results in the following changes:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>It creates a new network device named &lt;code>vrf-inner&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It adds a new route policy rule (if it doesn&amp;rsquo;t already exist) that looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>1000: from all lookup [l3mdev-table]
&lt;/code>&lt;/pre>&lt;p>This causes route lookups to use the appropriate route table for interfaces associated with a VRF.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>After creating a VRF device, we can add interfaces to it like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link set eth0 master vrf-inner
&lt;/code>&lt;/pre>&lt;p>This associates the given interface with the VRF device, and it moves all routes associated with the interface out of the &lt;code>local&lt;/code> and &lt;code>main&lt;/code> routing tables and into the VRF-specific routing table.&lt;/p>
&lt;p>You can see a list of vrf devices by running &lt;code>ip vrf show&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip vrf show
Name Table
-----------------------
vrf-inner 100
&lt;/code>&lt;/pre>&lt;p>You can see a list of devices associated with a particular VRF with the &lt;code>ip link&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip -brief link show master vrf-inner
eth0@if448 UP 72:87:af:d3:b5:f9 &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="vrf-in-practice">VRF in practice&lt;/h2>
&lt;p>We&amp;rsquo;re going to create two VRF devices on the &lt;code>middleman&lt;/code> host; one associated with the &amp;ldquo;inner&amp;rdquo; network and one associated with the &amp;ldquo;outer&amp;rdquo; network. In our virtual network topology, the &lt;code>middleman&lt;/code> host has two network interfaces:&lt;/p>
&lt;ul>
&lt;li>&lt;code>middleman-eth0&lt;/code> is connected to the &amp;ldquo;inner&amp;rdquo; network&lt;/li>
&lt;li>&lt;code>middleman-eth1&lt;/code> is connected to the &amp;ldquo;outer&amp;rdquo; network&lt;/li>
&lt;/ul>
&lt;p>Both devices have the same address (&lt;code>192.168.2.1&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code># ip addr show
2: middleman-eth0@if426: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master vrf-inner state UP group default qlen 1000
link/ether 32:9e:01:2e:78:2f brd ff:ff:ff:ff:ff:ff link-netnsid 0
inet 192.168.2.1/24 brd 192.168.2.255 scope global middleman-eth0
valid_lft forever preferred_lft forever
root@mininet-vm:~/unix-735931# ip addr show middleman-eth1
3: middleman-eth1@if427: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master vrf-outer state UP group default qlen 1000
link/ether 12:be:9a:09:33:93 brd ff:ff:ff:ff:ff:ff link-netnsid 0
inet 192.168.2.1/24 brd 192.168.2.255 scope global middleman-eth1
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>And the main routing table looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip route show
192.168.2.0/24 dev middleman-eth1 proto kernel scope link src 192.168.2.1
192.168.2.0/24 dev middleman-eth0 proto kernel scope link src 192.168.2.1
&lt;/code>&lt;/pre>&lt;p>If you&amp;rsquo;re at all familiar with Linux network configuration, that probably looks weird. Right now this isn&amp;rsquo;t a particularly functional network configuration, but we can fix that!&lt;/p>
&lt;p>To create our two VRF devices, we run the following commands:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add vrf-inner type vrf table 100
ip link add vrf-outer type vrf table 200
ip link set vrf-inner up
ip link set vrf-outer up
&lt;/code>&lt;/pre>&lt;p>This associates &lt;code>vrf-inner&lt;/code> with route table 100, and &lt;code>vrf-outer&lt;/code> with route table 200. At this point, tables 100 and 200 are empty:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip route show table 100
Error: ipv4: FIB table does not exist.
Dump terminated
# ip route show table 200
Error: ipv4: FIB table does not exist.
Dump terminated
&lt;/code>&lt;/pre>&lt;p>Next, we add our interfaces to the appropriate VRF devices:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link set middleman-eth0 master vrf-inner
ip link set middleman-eth1 master vrf-outer
&lt;/code>&lt;/pre>&lt;p>After running these commands, there are no routes left in the main routing table:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip route show
&amp;lt;no output&amp;gt;
&lt;/code>&lt;/pre>&lt;p>And the routes associated with our two physical interfaces are now contained by the appropriate VRF routing tables. Here&amp;rsquo;s table 100:&lt;/p>
&lt;pre tabindex="0">&lt;code>root@mininet-vm:~/unix-735931# ip route show table 100
broadcast 192.168.2.0 dev middleman-eth0 proto kernel scope link src 192.168.2.1
192.168.2.0/24 dev middleman-eth0 proto kernel scope link src 192.168.2.1
local 192.168.2.1 dev middleman-eth0 proto kernel scope host src 192.168.2.1
broadcast 192.168.2.255 dev middleman-eth0 proto kernel scope link src 192.168.2.1
&lt;/code>&lt;/pre>&lt;p>And table 200:&lt;/p>
&lt;pre tabindex="0">&lt;code>root@mininet-vm:~/unix-735931# ip route show table 200
broadcast 192.168.2.0 dev middleman-eth1 proto kernel scope link src 192.168.2.1
192.168.2.0/24 dev middleman-eth1 proto kernel scope link src 192.168.2.1
local 192.168.2.1 dev middleman-eth1 proto kernel scope host src 192.168.2.1
broadcast 192.168.2.255 dev middleman-eth1 proto kernel scope link src 192.168.2.1
&lt;/code>&lt;/pre>&lt;p>This configuration effectively gives us two isolated networks:&lt;/p>
&lt;figure class="center" >
&lt;img src="topology-2.svg" alt="virtual network topology diagram" />
&lt;/figure>
&lt;p>We can verify that nodes in the &amp;ldquo;inner&amp;rdquo; and &amp;ldquo;outer&amp;rdquo; networks are now able to communicate with &lt;code>middleman&lt;/code>. We can reach &lt;code>middleman&lt;/code> from &lt;code>innernode0&lt;/code>; in this case, we&amp;rsquo;re communicating with interface &lt;code>middleman-eth0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ping -c1 192.168.2.1
PING 192.168.2.1 (192.168.2.1) 56(84) bytes of data.
64 bytes from 192.168.2.1: icmp_seq=1 ttl=64 time=0.126 ms
--- 192.168.2.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.126/0.126/0.126/0.000 ms
&lt;/code>&lt;/pre>&lt;p>Similarly, we can reach &lt;code>middleman&lt;/code> from &lt;code>outernode&lt;/code>, but in this case we&amp;rsquo;re communicating with interface &lt;code>middleman-eth1&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>outernode0# ping -c1 192.168.2.1
PING 192.168.2.1 (192.168.2.1) 56(84) bytes of data.
64 bytes from 192.168.2.1: icmp_seq=1 ttl=64 time=1.02 ms
--- 192.168.2.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 1.020/1.020/1.020/0.000 ms
&lt;/code>&lt;/pre>&lt;h2 id="configure-routing-on-the-nodes">Configure routing on the nodes&lt;/h2>
&lt;p>Our goal is to let nodes on one side of the network to use the address range &lt;code>192.168.3.0/24&lt;/code> to refer to nodes on the other side of the network. Right now, if we were to try to access &lt;code>192.168.3.10&lt;/code> from &lt;code>innernode0&lt;/code>, the attempt would fail with:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ping 192.168.3.10
ping: connect: Network is unreachable
&lt;/code>&lt;/pre>&lt;p>The &amp;ldquo;network is unreachable&amp;rdquo; message means that &lt;code>innernode0&lt;/code> has no idea where to send that request. That&amp;rsquo;s because at the moment, the routing table on all the nodes look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ip route
192.168.2.0/24 dev outernode0-eth0 proto kernel scope link src 192.168.2.10
&lt;/code>&lt;/pre>&lt;p>There is neither a default gateway nor a network-specific route appropriate for &lt;code>192.168.3.0/24&lt;/code> addresses. Let&amp;rsquo;s add a network route that will route that address range through &lt;code>middleman&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ip route add 192.168.3.0/24 via 192.168.2.1
innernode0# ip route
192.168.2.0/24 dev innernode0-eth0 proto kernel scope link src 192.168.2.10
192.168.3.0/24 via 192.168.2.1 dev innernode0-eth0
&lt;/code>&lt;/pre>&lt;p>This same change needs to be made on all the &lt;code>innernode*&lt;/code> and &lt;code>outernode*&lt;/code> nodes.&lt;/p>
&lt;p>With the route in place, attempts to reach &lt;code>192.168.3.10&lt;/code> from &lt;code>innernode0&lt;/code> will still fail, but now they&amp;rsquo;re getting rejected by &lt;code>middleman&lt;/code> because &lt;em>it&lt;/em> doesn&amp;rsquo;t have any appropriate routes:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ping -c1 192.168.3.10
PING 192.168.3.10 (192.168.3.10) 56(84) bytes of data.
From 192.168.2.1 icmp_seq=1 Destination Net Unreachable
--- 192.168.3.10 ping statistics ---
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms
&lt;/code>&lt;/pre>&lt;p>We need to tell &lt;code>middleman&lt;/code> what to do with these packets.&lt;/p>
&lt;h2 id="configure-routing-and-nat-on-middleman">Configure routing and NAT on middleman&lt;/h2>
&lt;p>In order to achieve our desired connectivity, we need to:&lt;/p>
&lt;ol>
&lt;li>Map the &lt;code>192.168.3.0/24&lt;/code> destination address to the equivalent &lt;code>192.168.2.0/24&lt;/code> address &lt;em>before&lt;/em> the kernel makes a routing decision.&lt;/li>
&lt;li>Map the &lt;code>192.168.2.0/24&lt;/code> source address to the equivalent &lt;code>192.168.3.0/24&lt;/code> address &lt;em>after&lt;/em> the kernel makes a routing decision (so that replies will go back to &amp;ldquo;other&amp;rdquo; side).&lt;/li>
&lt;li>Ensure that the kernel uses the routing table for the &lt;em>target&lt;/em> network when making routing decisions for these connections.&lt;/li>
&lt;/ol>
&lt;p>We can achieve (1) and (2) using the netfilter &lt;a href="https://www.netfilter.org/documentation/HOWTO/netfilter-extensions-HOWTO-4.html#ss4.4">&lt;code>NETMAP&lt;/code>&lt;/a> extension by adding the following two rules:&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t nat -A PREROUTING -d 192.168.3.0/24 -j NETMAP --to 192.168.2.0/24
iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -j NETMAP --to 192.168.3.0/24
&lt;/code>&lt;/pre>&lt;p>For incoming traffic destined for the 192.168.3.0/24 network, this maps the destination address to the matching &lt;code>192.168.2.0/24&lt;/code> address. For outgoing traffic with a source address on the &lt;code>192.168.2.0/24&lt;/code> network, this maps the source to the equivalent &lt;code>192.168.3.0/24&lt;/code> network (so that the recipient see the traffic as coming from &amp;ldquo;the other side&amp;rdquo;).&lt;/p>
&lt;p>(For those of you wondering, &amp;ldquo;can we do this using &lt;code>nftables&lt;/code> instead?&amp;rdquo;, as of this writing &lt;a href="https://wiki.nftables.org/wiki-nftables/index.php/Supported_features_compared_to_xtables#NETMAP">&lt;code>nftables&lt;/code> does not appear to have &lt;code>NETMAP&lt;/code> support&lt;/a>, so we have to use &lt;code>iptables&lt;/code> for this step.)&lt;/p>
&lt;p>With this change in place, re-trying that &lt;code>ping&lt;/code> command on &lt;code>innernode0&lt;/code> will apparently succeed:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0 ping -c1 192.168.3.10
PING 192.168.3.10 (192.168.3.10) 56(84) bytes of data.
64 bytes from 192.168.3.10: icmp_seq=1 ttl=63 time=0.063 ms
--- 192.168.3.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.063/0.063/0.063/0.000 ms
&lt;/code>&lt;/pre>&lt;p>However, running &lt;code>tcpdump&lt;/code> on &lt;code>middleman&lt;/code> will show us that we haven&amp;rsquo;t yet achieved our goal:&lt;/p>
&lt;pre tabindex="0">&lt;code>12:59:52.899054 middleman-eth0 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo request, id 16520, seq 1, length 64
12:59:52.899077 middleman-eth0 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo request, id 16520, seq 1, length 64
12:59:52.899127 middleman-eth0 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo reply, id 16520, seq 1, length 64
12:59:52.899130 middleman-eth0 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo reply, id 16520, seq 1, length 64
&lt;/code>&lt;/pre>&lt;p>You can see that our packet is coming on on &lt;code>middleman-eth0&lt;/code>&amp;hellip;and going right back out the same interface. We have thus far achieved a very complicated loopback interface.&lt;/p>
&lt;p>The missing piece is some logic to have the kernel use the routing table for the &amp;ldquo;other side&amp;rdquo; when making routing decisions for these packets. We&amp;rsquo;re going to do that by:&lt;/p>
&lt;ol>
&lt;li>Tagging packets with a mark that indicates the interface on which they were recieved&lt;/li>
&lt;li>Using this mark to select an appropriate routing table&lt;/li>
&lt;/ol>
&lt;p>We add the packet mark by adding these rules to the &lt;code>MANGLE&lt;/code> table &lt;code>PREROUTING&lt;/code> chain:&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t mangle -A PREROUTING -i middleman-eth0 -d 192.168.3.0/24 -j MARK --set-mark 100
iptables -t mangle -A PREROUTING -i middleman-eth1 -d 192.168.3.0/24 -j MARK --set-mark 200
&lt;/code>&lt;/pre>&lt;p>And we utilize that mark in route lookups by adding the following two route policy rules:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip rule add prio 100 fwmark 100 lookup 200
ip rule add prio 200 fwmark 200 lookup 100
&lt;/code>&lt;/pre>&lt;p>It is critical that these rules come before (aka &amp;ldquo;have a higher priority than&amp;rdquo;, aka &amp;ldquo;have a lower number than&amp;rdquo;) the &lt;code>l3mdev&lt;/code> rule added when we created the VRF devices.&lt;/p>
&lt;h2 id="validation-does-it-actually-work">Validation: Does it actually work?&lt;/h2>
&lt;p>With that last set of changes in place, if we repeat the &lt;code>ping&lt;/code> test from &lt;code>innernode0&lt;/code> to &lt;code>outernode0&lt;/code> and run &lt;code>tcpdump&lt;/code> on &lt;code>middleman&lt;/code>, we see:&lt;/p>
&lt;pre tabindex="0">&lt;code>13:05:27.667793 middleman-eth0 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo request, id 16556, seq 1, length 64
13:05:27.667816 middleman-eth1 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo request, id 16556, seq 1, length 64
13:05:27.667863 middleman-eth1 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo reply, id 16556, seq 1, length 64
13:05:27.667868 middleman-eth0 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo reply, id 16556, seq 1, length 64
&lt;/code>&lt;/pre>&lt;p>Now we finally see the desired behavior: the request from &lt;code>innernode0&lt;/code> comes in on &lt;code>eth0&lt;/code>, goes out on &lt;code>eth1&lt;/code> with the addresses appropriately mapped and gets delivered to &lt;code>outernode0&lt;/code>. The reply from &lt;code>outernode0&lt;/code> goes through the process in reverse, and arrives back at &lt;code>innernode0&lt;/code>.&lt;/p>
&lt;h2 id="connection-tracking-or-one-more-thing">Connection tracking (or, &amp;ldquo;One more thing&amp;hellip;&amp;rdquo;)&lt;/h2>
&lt;p>There is a subtle problem with the configuration we&amp;rsquo;ve implemented so far: the Linux connection tracking mechanism (&amp;quot;&lt;a href="https://arthurchiao.art/blog/conntrack-design-and-implementation/">conntrack&lt;/a>&amp;quot;) by default identifies a connection by the 4-tuple &lt;code>(source_address, source_port, destination_address, destination_port)&lt;/code>. To understand why this is a problem, assume that we&amp;rsquo;re running a web server on port 80 on all the &amp;ldquo;inner&amp;rdquo; and &amp;ldquo;outer&amp;rdquo; nodes.&lt;/p>
&lt;p>To connect from &lt;code>innernode0&lt;/code> to &lt;code>outernode0&lt;/code>, we could use the following command. We&amp;rsquo;re using the &lt;code>--local-port&lt;/code> option here because we want to control the source port of our connections:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# curl --local-port 4000 192.168.3.10
&lt;/code>&lt;/pre>&lt;p>To connect from &lt;code>outernode0&lt;/code> to &lt;code>innernode0&lt;/code>, we would use the same command:&lt;/p>
&lt;pre tabindex="0">&lt;code>outernode0# curl --local-port 4000 192.168.3.10
&lt;/code>&lt;/pre>&lt;p>If we look at the connection tracking table on &lt;code>middleman&lt;/code>, we will see a single connection:&lt;/p>
&lt;pre tabindex="0">&lt;code>middleman# conntrack -L
tcp 6 115 TIME_WAIT src=192.168.2.10 dst=192.168.3.10 sport=4000 dport=80 src=192.168.2.10 dst=192.168.3.10 sport=80 dport=4000 [ASSURED] mark=0 use=1
&lt;/code>&lt;/pre>&lt;p>This happens because the 4-tuple for our two connections is identical. Conflating connections like this can cause traffic to stop flowing if both connections are active at the same time.&lt;/p>
&lt;p>We need to provide the connection track subsystem with some additional information to uniquely identify these connections. We can do this by using the netfilter &lt;code>CT&lt;/code> module to assign each connection to a unique conntrack origination &amp;ldquo;zone&amp;rdquo;:&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t raw -A PREROUTING -s 192.168.2.0/24 -i middleman-eth0 -j CT --zone-orig 100
iptables -t raw -A PREROUTING -s 192.168.2.0/24 -i middleman-eth1 -j CT --zone-orig 200
&lt;/code>&lt;/pre>&lt;p>What is a &amp;ldquo;zone&amp;rdquo;? From &lt;a href="https://lore.kernel.org/all/4B9158F5.5040205@parallels.com/T/">the patch adding this feature&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>A zone is simply a numerical identifier associated with a network
device that is incorporated into the various hashes and used to
distinguish entries in addition to the connection tuples.&lt;/p>
&lt;/blockquote>
&lt;p>With these rules in place, if we repeat the test with &lt;code>curl&lt;/code> we will see two distinct connections:&lt;/p>
&lt;pre tabindex="0">&lt;code>middleman# conntrack -L
tcp 6 117 TIME_WAIT src=192.168.2.10 dst=192.168.3.10 sport=4000 dport=80 zone-orig=100 src=192.168.2.10 dst=192.168.3.10 sport=80 dport=26148 [ASSURED] mark=0 use=1
tcp 6 115 TIME_WAIT src=192.168.2.10 dst=192.168.3.10 sport=4000 dport=80 zone-orig=200 src=192.168.2.10 dst=192.168.3.10 sport=80 dport=4000 [ASSURED] mark=0 use=1
&lt;/code>&lt;/pre>&lt;h2 id="repository-and-demo">Repository and demo&lt;/h2>
&lt;p>You can find a complete test environment in &lt;a href="https://github.com/larsks/unix-example-735931-1-1-nat">this repository&lt;/a>; that includes the mininet topology I mentioned at the beginning of this post as well as shell scripts to implement all the address, route, and netfilter configurations.&lt;/p>
&lt;p>And here&amp;rsquo;s a video that runs through the steps described in this post:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/Kws98JNKcxE?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div></content></item><item><title>Packet, packet, who's got the packet?</title><link>https://blog.oddbit.com/post/2023-02-14-whos-got-the-packet/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-02-14-whos-got-the-packet/</guid><description>&lt;p>In &lt;a href="https://unix.stackexchange.com/q/735522/4989">this question&lt;/a>, August Vrubel has some C code that sets up a &lt;a href="https://docs.kernel.org/networking/tuntap.html">tun&lt;/a> interface and then injects a packet, but the packet seemed to disappear into the ether. In this post, I&amp;rsquo;d like to take a slightly extended look at &lt;a href="https://unix.stackexchange.com/a/735534/4989">my answer&lt;/a> because I think it&amp;rsquo;s a great opportunity for learning a bit more about performing network diagnostics.&lt;/p>
&lt;p>The original code looked like this:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="671238954" type="checkbox" />
&lt;label for="671238954">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">original sendpacket.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/if.h&amp;gt;
#include &amp;lt;linux/if_tun.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
static int tunAlloc(void) {
int fd;
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;, .ifr_flags = IFF_TUN | IFF_NO_PI};
fd = open(&amp;#34;/dev/net/tun&amp;#34;, O_RDWR);
ioctl(fd, TUNSETIFF, (void *)&amp;amp;ifr);
ioctl(fd, TUNSETOWNER, geteuid());
return fd;
}
// this is a test
static void bringInterfaceUp(void) {
int sock;
struct sockaddr_in addr = {.sin_family = AF_INET};
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;};
inet_aton(&amp;#34;172.30.0.1&amp;#34;, &amp;amp;addr.sin_addr);
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));
sock = socket(AF_INET, SOCK_DGRAM, 0);
ioctl(sock, SIOCSIFADDR, &amp;amp;ifr);
ioctl(sock, SIOCGIFFLAGS, &amp;amp;ifr);
ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
ioctl(sock, SIOCSIFFLAGS, &amp;amp;ifr);
close(sock);
}
static void emitPacket(int tap_fd) {
unsigned char packet[] = {
0x45, 0x00, 0x00, 0x3c, 0xd8, 0x6f, 0x40, 0x00, 0x3f, 0x06, 0x08, 0x91,
172, 30, 0, 1, 192, 168, 255, 8, 0xa2, 0x9a, 0x27, 0x11,
0x80, 0x0b, 0x63, 0x79, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xfa, 0xf0,
0x89, 0xd8, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a,
0x5b, 0x76, 0x5f, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07};
write(tap_fd, packet, sizeof(packet));
}
int main() {
int tap_fd;
tap_fd = tunAlloc();
bringInterfaceUp();
emitPacket(tap_fd);
close(tap_fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>A problem with the original code is that it creates the interface, sends the packet, and tears down the interface with no delays, making it very difficult to inspect the interface configuration, perform packet captures, or otherwise figure out what&amp;rsquo;s going on.&lt;/p></description><content>&lt;p>In &lt;a href="https://unix.stackexchange.com/q/735522/4989">this question&lt;/a>, August Vrubel has some C code that sets up a &lt;a href="https://docs.kernel.org/networking/tuntap.html">tun&lt;/a> interface and then injects a packet, but the packet seemed to disappear into the ether. In this post, I&amp;rsquo;d like to take a slightly extended look at &lt;a href="https://unix.stackexchange.com/a/735534/4989">my answer&lt;/a> because I think it&amp;rsquo;s a great opportunity for learning a bit more about performing network diagnostics.&lt;/p>
&lt;p>The original code looked like this:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="671238954" type="checkbox" />
&lt;label for="671238954">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">original sendpacket.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/if.h&amp;gt;
#include &amp;lt;linux/if_tun.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
static int tunAlloc(void) {
int fd;
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;, .ifr_flags = IFF_TUN | IFF_NO_PI};
fd = open(&amp;#34;/dev/net/tun&amp;#34;, O_RDWR);
ioctl(fd, TUNSETIFF, (void *)&amp;amp;ifr);
ioctl(fd, TUNSETOWNER, geteuid());
return fd;
}
// this is a test
static void bringInterfaceUp(void) {
int sock;
struct sockaddr_in addr = {.sin_family = AF_INET};
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;};
inet_aton(&amp;#34;172.30.0.1&amp;#34;, &amp;amp;addr.sin_addr);
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));
sock = socket(AF_INET, SOCK_DGRAM, 0);
ioctl(sock, SIOCSIFADDR, &amp;amp;ifr);
ioctl(sock, SIOCGIFFLAGS, &amp;amp;ifr);
ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
ioctl(sock, SIOCSIFFLAGS, &amp;amp;ifr);
close(sock);
}
static void emitPacket(int tap_fd) {
unsigned char packet[] = {
0x45, 0x00, 0x00, 0x3c, 0xd8, 0x6f, 0x40, 0x00, 0x3f, 0x06, 0x08, 0x91,
172, 30, 0, 1, 192, 168, 255, 8, 0xa2, 0x9a, 0x27, 0x11,
0x80, 0x0b, 0x63, 0x79, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xfa, 0xf0,
0x89, 0xd8, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a,
0x5b, 0x76, 0x5f, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07};
write(tap_fd, packet, sizeof(packet));
}
int main() {
int tap_fd;
tap_fd = tunAlloc();
bringInterfaceUp();
emitPacket(tap_fd);
close(tap_fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>A problem with the original code is that it creates the interface, sends the packet, and tears down the interface with no delays, making it very difficult to inspect the interface configuration, perform packet captures, or otherwise figure out what&amp;rsquo;s going on.&lt;/p>
&lt;p>In order to resolve those issues, I added some prompts before sending the packet and before tearing down the &lt;code>tun&lt;/code> interface (and also some minimal error checking), giving us:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="586397412" type="checkbox" />
&lt;label for="586397412">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">sendpacket.c with prompts and error checking&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/if.h&amp;gt;
#include &amp;lt;linux/if_tun.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#define must(x) _must(#x, __FILE__, __LINE__, __func__, (x))
void _must(const char *call, const char *filename, int line,
const char *funcname, int err) {
char buf[1024];
snprintf(buf, 1023, &amp;#34;%s (@ %s:%d)&amp;#34;, call, filename, line);
if (err &amp;lt; 0) {
perror(buf);
exit(1);
}
}
static int tunAlloc(void) {
int fd;
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;, .ifr_flags = IFF_TUN | IFF_NO_PI};
fd = open(&amp;#34;/dev/net/tun&amp;#34;, O_RDWR);
must(ioctl(fd, TUNSETIFF, (void *)&amp;amp;ifr));
must(ioctl(fd, TUNSETOWNER, geteuid()));
return fd;
}
static void bringInterfaceUp(void) {
int sock;
struct sockaddr_in addr = {.sin_family = AF_INET};
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;};
inet_aton(&amp;#34;172.30.0.1&amp;#34;, &amp;amp;addr.sin_addr);
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));
sock = socket(AF_INET, SOCK_DGRAM, 0);
must(ioctl(sock, SIOCSIFADDR, &amp;amp;ifr));
must(ioctl(sock, SIOCGIFFLAGS, &amp;amp;ifr));
ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
must(ioctl(sock, SIOCSIFFLAGS, &amp;amp;ifr));
close(sock);
}
static void emitPacket(int tap_fd) {
unsigned char packet[] = {
0x45, 0x00, 0x00, 0x3c, 0xd8, 0x6f, 0x40, 0x00, 0x3f, 0x06, 0x08, 0x91,
172, 30, 0, 1, 192, 168, 255, 8, 0xa2, 0x9a, 0x27, 0x11,
0x80, 0x0b, 0x63, 0x79, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xfa, 0xf0,
0x89, 0xd8, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a,
0x5b, 0x76, 0x5f, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07};
write(tap_fd, packet, sizeof(packet));
}
void prompt(char *promptString) {
printf(&amp;#34;%s\n&amp;#34;, promptString);
getchar();
}
int main() {
int tap_fd;
tap_fd = tunAlloc();
bringInterfaceUp();
prompt(&amp;#34;interface is up&amp;#34;);
emitPacket(tap_fd);
prompt(&amp;#34;sent packet&amp;#34;);
close(tap_fd);
printf(&amp;#34;all done&amp;#34;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>We start by compiling the code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>gcc -o sendpacket sendpacket.c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we try running this as a regular user, it will simply fail (which confirms that at least some of our error handling is working correctly):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ ./sendpacket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ioctl&lt;span style="color:#f92672">(&lt;/span>fd, TUNSETIFF, &lt;span style="color:#f92672">(&lt;/span>void *&lt;span style="color:#f92672">)&lt;/span>&amp;amp;ifr&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>@ sendpacket-pause.c:33&lt;span style="color:#f92672">)&lt;/span>: Operation not permitted
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We need to run it as &lt;code>root&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ sudo ./sendpacket
interface is up
&lt;/code>&lt;/pre>&lt;p>The &lt;code>interface is up&lt;/code> prompt means that the code has configured the interface but has not yet sent the packet. Let&amp;rsquo;s take a look at the interface configuration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ ip addr show tun0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3390: tun0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu &lt;span style="color:#ae81ff">1500&lt;/span> qdisc fq_codel state UNKNOWN group default qlen &lt;span style="color:#ae81ff">500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link/none
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inet 172.30.0.1/32 scope global tun0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inet6 fe80::c7ca:fe15:5d5c:2c49/64 scope link stable-privacy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The code will emit a TCP &lt;code>SYN&lt;/code> packet targeting address &lt;code>192.168.255.8&lt;/code>, port &lt;code>10001&lt;/code>. In another terminal, let&amp;rsquo;s watch for that on all interfaces. If we start &lt;code>tcpdump&lt;/code> and press RETURN at the &lt;code>interface is up&lt;/code> prompt, we&amp;rsquo;ll see something like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># tcpdump -nn -i any port 10001&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>22:36:35.336643 tun0 In IP 172.30.0.1.41626 &amp;gt; 192.168.255.8.10001: Flags &lt;span style="color:#f92672">[&lt;/span>S&lt;span style="color:#f92672">]&lt;/span>, seq 2148230009, win 64240, options &lt;span style="color:#f92672">[&lt;/span>mss 1460,sackOK,TS val &lt;span style="color:#ae81ff">1534484436&lt;/span> ecr 0,nop,wscale 7&lt;span style="color:#f92672">]&lt;/span>, length &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And indeed, we see the problem that was described: the packet enters the system on &lt;code>tun0&lt;/code>, but never goes anywhere else. What&amp;rsquo;s going on?&lt;/p>
&lt;h2 id="introducing-pwru-packet-where-are-you">Introducing pwru (Packet, Where are you?)&lt;/h2>
&lt;p>&lt;a href="https://github.com/cilium/pwru">&lt;code>pwru&lt;/code>&lt;/a> is a nifty utility written by the folks at Cilium that takes advantage of &lt;a href="https://ebpf.io/">eBPF&lt;/a> to attach traces to hundreds of kernel functions to trace packet processing through the Linux kernel. It&amp;rsquo;s especially useful when packets seem to be getting dropped with no obvious explanation. Let&amp;rsquo;s see what it can tell us!&lt;/p>
&lt;p>A convenient way to run &lt;code>pwru&lt;/code> is using their official Docker image. We&amp;rsquo;ll run it like this, filtering by protocol and destination port so that we only see results relating to the synthesized packet created by the &lt;code>sendpacket.c&lt;/code> code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>docker run --privileged --rm -t --pid&lt;span style="color:#f92672">=&lt;/span>host &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /sys/kernel/debug/:/sys/kernel/debug/ &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> cilium/pwru --filter-proto tcp --filter-port &lt;span style="color:#ae81ff">10001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we run &lt;code>sendpacket&lt;/code> while &lt;code>pwru&lt;/code> is running, the output looks something like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>2023/02/15 03:42:33 Per cpu buffer size: 4096 bytes
2023/02/15 03:42:33 Attaching kprobes (via kprobe-multi)...
1469 / 1469 [-----------------------------------------------------------------------------] 100.00% ? p/s
2023/02/15 03:42:33 Attached (ignored 0)
2023/02/15 03:42:33 Listening for events..
SKB CPU PROCESS FUNC
0xffff8ce13e987900 6 [sendpacket-orig] netif_receive_skb
0xffff8ce13e987900 6 [sendpacket-orig] skb_defer_rx_timestamp
0xffff8ce13e987900 6 [sendpacket-orig] __netif_receive_skb
0xffff8ce13e987900 6 [sendpacket-orig] __netif_receive_skb_one_core
0xffff8ce13e987900 6 [sendpacket-orig] ip_rcv
0xffff8ce13e987900 6 [sendpacket-orig] ip_rcv_core
0xffff8ce13e987900 6 [sendpacket-orig] kfree_skb_reason(SKB_DROP_REASON_IP_CSUM)
0xffff8ce13e987900 6 [sendpacket-orig] skb_release_head_state
0xffff8ce13e987900 6 [sendpacket-orig] sock_wfree
0xffff8ce13e987900 6 [sendpacket-orig] skb_release_data
0xffff8ce13e987900 6 [sendpacket-orig] skb_free_head
0xffff8ce13e987900 6 [sendpacket-orig] kfree_skbmem
&lt;/code>&lt;/pre>&lt;p>And now we have a big blinking sign that tells us why the packet is being dropped:&lt;/p>
&lt;pre tabindex="0">&lt;code>0xffff8ce13e987900 6 [sendpacket-orig] kfree_skb_reason(SKB_DROP_REASON_IP_CSUM)
&lt;/code>&lt;/pre>&lt;h2 id="fixing-the-checksum">Fixing the checksum&lt;/h2>
&lt;p>It looks like the synthesized packet data includes a bad checksum. We could update the code to correctly calculate the checksum&amp;hellip;or we could just use &lt;a href="https://www.wireshark.org/">Wireshark&lt;/a> and have it tell us the correct values. Because this isn&amp;rsquo;t meant to be an IP networking primer, we&amp;rsquo;ll just use Wireshark, which gives us the following updated code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">emitPacket&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> tap_fd) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> cs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> packet[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x45&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x3c&lt;/span>, &lt;span style="color:#ae81ff">0xd8&lt;/span>, &lt;span style="color:#ae81ff">0x6f&lt;/span>, &lt;span style="color:#ae81ff">0x40&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x3f&lt;/span>, &lt;span style="color:#ae81ff">0x06&lt;/span>, &lt;span style="color:#ae81ff">0xf7&lt;/span>, &lt;span style="color:#ae81ff">0x7b&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">172&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">192&lt;/span>, &lt;span style="color:#ae81ff">168&lt;/span>, &lt;span style="color:#ae81ff">255&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">0xa2&lt;/span>, &lt;span style="color:#ae81ff">0x9a&lt;/span>, &lt;span style="color:#ae81ff">0x27&lt;/span>, &lt;span style="color:#ae81ff">0x11&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x80&lt;/span>, &lt;span style="color:#ae81ff">0x0b&lt;/span>, &lt;span style="color:#ae81ff">0x63&lt;/span>, &lt;span style="color:#ae81ff">0x79&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0xa0&lt;/span>, &lt;span style="color:#ae81ff">0x02&lt;/span>, &lt;span style="color:#ae81ff">0xfa&lt;/span>, &lt;span style="color:#ae81ff">0xf0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x78&lt;/span>, &lt;span style="color:#ae81ff">0xc3&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x02&lt;/span>, &lt;span style="color:#ae81ff">0x04&lt;/span>, &lt;span style="color:#ae81ff">0x05&lt;/span>, &lt;span style="color:#ae81ff">0xb4&lt;/span>, &lt;span style="color:#ae81ff">0x04&lt;/span>, &lt;span style="color:#ae81ff">0x02&lt;/span>, &lt;span style="color:#ae81ff">0x08&lt;/span>, &lt;span style="color:#ae81ff">0x0a&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x5b&lt;/span>, &lt;span style="color:#ae81ff">0x76&lt;/span>, &lt;span style="color:#ae81ff">0x5f&lt;/span>, &lt;span style="color:#ae81ff">0xd4&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x00&lt;/span>, &lt;span style="color:#ae81ff">0x01&lt;/span>, &lt;span style="color:#ae81ff">0x03&lt;/span>, &lt;span style="color:#ae81ff">0x03&lt;/span>, &lt;span style="color:#ae81ff">0x07&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">write&lt;/span>(tap_fd, packet, &lt;span style="color:#66d9ef">sizeof&lt;/span>(packet));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we repeat our invocation of &lt;code>pwru&lt;/code> and run a test with the updated code, we see:&lt;/p>
&lt;pre tabindex="0">&lt;code>2023/02/15 04:17:29 Per cpu buffer size: 4096 bytes
2023/02/15 04:17:29 Attaching kprobes (via kprobe-multi)...
1469 / 1469 [-----------------------------------------------------------------------------] 100.00% ? p/s
2023/02/15 04:17:29 Attached (ignored 0)
2023/02/15 04:17:29 Listening for events..
SKB CPU PROCESS FUNC
0xffff8cd8a6c5ef00 9 [sendpacket-chec] netif_receive_skb
0xffff8cd8a6c5ef00 9 [sendpacket-chec] skb_defer_rx_timestamp
0xffff8cd8a6c5ef00 9 [sendpacket-chec] __netif_receive_skb
0xffff8cd8a6c5ef00 9 [sendpacket-chec] __netif_receive_skb_one_core
0xffff8cd8a6c5ef00 9 [sendpacket-chec] ip_rcv
0xffff8cd8a6c5ef00 9 [sendpacket-chec] ip_rcv_core
0xffff8cd8a6c5ef00 9 [sendpacket-chec] sock_wfree
0xffff8cd8a6c5ef00 9 [sendpacket-chec] nf_hook_slow
0xffff8cd8a6c5ef00 9 [sendpacket-chec] nf_checksum
0xffff8cd8a6c5ef00 9 [sendpacket-chec] nf_ip_checksum
0xffff8cd8a6c5ef00 9 [sendpacket-chec] __skb_checksum_complete
0xffff8cd8a6c5ef00 9 [sendpacket-chec] tcp_v4_early_demux
0xffff8cd8a6c5ef00 9 [sendpacket-chec] ip_route_input_noref
0xffff8cd8a6c5ef00 9 [sendpacket-chec] ip_route_input_slow
0xffff8cd8a6c5ef00 9 [sendpacket-chec] fib_validate_source
0xffff8cd8a6c5ef00 9 [sendpacket-chec] __fib_validate_source
0xffff8cd8a6c5ef00 9 [sendpacket-chec] ip_handle_martian_source
0xffff8cd8a6c5ef00 9 [sendpacket-chec] kfree_skb_reason(SKB_DROP_REASON_NOT_SPECIFIED)
0xffff8cd8a6c5ef00 9 [sendpacket-chec] skb_release_head_state
0xffff8cd8a6c5ef00 9 [sendpacket-chec] skb_release_data
0xffff8cd8a6c5ef00 9 [sendpacket-chec] skb_free_head
0xffff8cd8a6c5ef00 9 [sendpacket-chec] kfree_skbmem
&lt;/code>&lt;/pre>&lt;h2 id="dealing-with-martians">Dealing with martians&lt;/h2>
&lt;p>Looking at the above output, we&amp;rsquo;re no longer seeing the &lt;code>SKB_DROP_REASON_IP_CSUM&lt;/code> error; instead, we&amp;rsquo;re getting dropped by the routing logic:&lt;/p>
&lt;pre tabindex="0">&lt;code>0xffff8cd8a6c5ef00 9 [sendpacket-chec] fib_validate_source
0xffff8cd8a6c5ef00 9 [sendpacket-chec] __fib_validate_source
0xffff8cd8a6c5ef00 9 [sendpacket-chec] ip_handle_martian_source
0xffff8cd8a6c5ef00 9 [sendpacket-chec] kfree_skb_reason(SKB_DROP_REASON_NOT_SPECIFIED)
&lt;/code>&lt;/pre>&lt;p>Specifically, the packet is being dropped as a &amp;ldquo;martian source&amp;rdquo;, which means a packet that has a source address that is invalid for the interface on which it is being received. Unlike the previous error, we can actually get kernel log messages about this problem. If we had the &lt;code>log_martians&lt;/code> sysctl enabled for all interfaces:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>sysctl -w net.ipv4.conf.all.log_martians&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or if we enabled it specifically for &lt;code>tun0&lt;/code> after the interface is created:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>sysctl -w net.ipv4.conf.tun0.log_martians&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We would see the following message logged by the kernel:&lt;/p>
&lt;pre tabindex="0">&lt;code>Feb 14 12:14:03 madhatter kernel: IPv4: martian source 192.168.255.8 from 172.30.0.1, on dev tun0
&lt;/code>&lt;/pre>&lt;p>We&amp;rsquo;re seeing this particular error because &lt;code>tun0&lt;/code> is configured with address &lt;code>172.30.0.1&lt;/code>, but it claims to be receiving a packet with the same source address from &amp;ldquo;somewhere else&amp;rdquo; on the network. This is a problem because we would never be able to reply to that packet (our replies would get routed to the local host). To deal with this problem, we can either change the source address of the packet, or we can change the IP address assigned to the &lt;code>tun0&lt;/code> interface. Since changing the source address would mean mucking about with checksums again, let&amp;rsquo;s change the address of &lt;code>tun0&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">bringInterfaceUp&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sock;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_in addr &lt;span style="color:#f92672">=&lt;/span> {.sin_family &lt;span style="color:#f92672">=&lt;/span> AF_INET};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> ifreq ifr &lt;span style="color:#f92672">=&lt;/span> {.ifr_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;tun0&amp;#34;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">inet_aton&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;172.30.0.10&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>addr.sin_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">memcpy&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ifr.ifr_addr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>addr, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sock &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">socket&lt;/span>(AF_INET, SOCK_DGRAM, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">must&lt;/span>(&lt;span style="color:#a6e22e">ioctl&lt;/span>(sock, SIOCSIFADDR, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ifr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">must&lt;/span>(&lt;span style="color:#a6e22e">ioctl&lt;/span>(sock, SIOCGIFFLAGS, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ifr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ifr.ifr_flags &lt;span style="color:#f92672">|=&lt;/span> IFF_UP &lt;span style="color:#f92672">|&lt;/span> IFF_RUNNING;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">must&lt;/span>(&lt;span style="color:#a6e22e">ioctl&lt;/span>(sock, SIOCSIFFLAGS, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ifr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">close&lt;/span>(sock);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With this change, &lt;code>tun0&lt;/code> now looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>3452: tun0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500
link/none
inet 172.30.0.10/32 scope global tun0
valid_lft forever preferred_lft forever
inet6 fe80::bda3:ddc8:e60e:106b/64 scope link stable-privacy
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>And if we repeat our earlier test in which we use &lt;code>tcpdump&lt;/code> to watch for our synthesized packet on any interface, we now see the desired behavior:&lt;/p>
&lt;pre tabindex="0">&lt;code># tcpdump -nn -i any port 10001
23:37:55.897786 tun0 In IP 172.30.0.1.41626 &amp;gt; 192.168.255.8.10001: Flags [S], seq 2148230009, win 64240, options [mss 1460,sackOK,TS val 1534484436 ecr 0,nop,wscale 7], length 0
23:37:55.897816 eth0 Out IP 172.30.0.1.41626 &amp;gt; 192.168.255.8.10001: Flags [S], seq 2148230009, win 64240, options [mss 1460,sackOK,TS val 1534484436 ecr 0,nop,wscale 7], length 0
&lt;/code>&lt;/pre>&lt;p>The packet is correctly handled by the kernel and sent out to our default gateway.&lt;/p>
&lt;h2 id="finishing-up">Finishing up&lt;/h2>
&lt;p>The final version of the code looks like this:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="519364872" type="checkbox" />
&lt;label for="519364872">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">working sendpacket.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/if.h&amp;gt;
#include &amp;lt;linux/if_tun.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#define must(x) _must(#x, __FILE__, __LINE__, __func__, (x))
void _must(const char *call, const char *filename, int line,
const char *funcname, int err) {
char buf[1024];
snprintf(buf, 1023, &amp;#34;%s (@ %s:%d)&amp;#34;, call, filename, line);
if (err &amp;lt; 0) {
perror(buf);
exit(1);
}
}
static int tunAlloc(void) {
int fd;
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;, .ifr_flags = IFF_TUN | IFF_NO_PI};
fd = open(&amp;#34;/dev/net/tun&amp;#34;, O_RDWR);
must(ioctl(fd, TUNSETIFF, (void *)&amp;amp;ifr));
must(ioctl(fd, TUNSETOWNER, geteuid()));
return fd;
}
static void bringInterfaceUp(void) {
int sock;
struct sockaddr_in addr = {.sin_family = AF_INET};
struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;};
inet_aton(&amp;#34;172.30.0.10&amp;#34;, &amp;amp;addr.sin_addr);
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));
sock = socket(AF_INET, SOCK_DGRAM, 0);
must(ioctl(sock, SIOCSIFADDR, &amp;amp;ifr));
must(ioctl(sock, SIOCGIFFLAGS, &amp;amp;ifr));
ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
must(ioctl(sock, SIOCSIFFLAGS, &amp;amp;ifr));
close(sock);
}
static void emitPacket(int tap_fd) {
uint16_t cs;
uint8_t packet[] = {
0x45, 0x00, 0x00, 0x3c, 0xd8, 0x6f, 0x40, 0x00, 0x3f, 0x06, 0xf7, 0x7b,
172, 30, 0, 1, 192, 168, 255, 8, 0xa2, 0x9a, 0x27, 0x11,
0x80, 0x0b, 0x63, 0x79, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xfa, 0xf0,
0x78, 0xc3, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a,
0x5b, 0x76, 0x5f, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07,
};
write(tap_fd, packet, sizeof(packet));
}
void prompt(char *promptString) {
printf(&amp;#34;%s\n&amp;#34;, promptString);
getchar();
}
int main() {
int tap_fd;
tap_fd = tunAlloc();
bringInterfaceUp();
prompt(&amp;#34;interface is up&amp;#34;);
emitPacket(tap_fd);
prompt(&amp;#34;sent packet&amp;#34;);
close(tap_fd);
printf(&amp;#34;all done&amp;#34;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div></content></item><item><title>Setting up an IPv6 VLAN</title><link>https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/</guid><description>&lt;p>My internet service provider (&lt;a href="https://www.verizon.com/home/fios/">FIOS&lt;/a>) doesn&amp;rsquo;t yet (sad face) offer IPv6 capable service, so I&amp;rsquo;ve set up an IPv6 tunnel using the &lt;a href="https://www.tunnelbroker.net/">Hurricane Electric&lt;/a> tunnel broker. I want to provide IPv6 connectivity to multiple systems in my house, but not to &lt;strong>all&lt;/strong> systems in my house &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. In order to meet those requirements, I&amp;rsquo;m going to set up the tunnel on the router, and then expose connectivity over an IPv6-only VLAN. In this post, we&amp;rsquo;ll walk through the steps necessary to set that up.&lt;/p></description><content>&lt;p>My internet service provider (&lt;a href="https://www.verizon.com/home/fios/">FIOS&lt;/a>) doesn&amp;rsquo;t yet (sad face) offer IPv6 capable service, so I&amp;rsquo;ve set up an IPv6 tunnel using the &lt;a href="https://www.tunnelbroker.net/">Hurricane Electric&lt;/a> tunnel broker. I want to provide IPv6 connectivity to multiple systems in my house, but not to &lt;strong>all&lt;/strong> systems in my house &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. In order to meet those requirements, I&amp;rsquo;m going to set up the tunnel on the router, and then expose connectivity over an IPv6-only VLAN. In this post, we&amp;rsquo;ll walk through the steps necessary to set that up.&lt;/p>
&lt;p>Parts of this post are going to be device specific: for example, I&amp;rsquo;m using a Ubiquiti &lt;a href="https://store.ui.com/collections/operator-edgemax-routers/products/edgerouter-x">EdgeRouter X&lt;/a> as my Internet router, so the tunnel setup is going to be specific to that device. The section about setting things up on my Linux desktop will be more generally applicable.&lt;/p>
&lt;p>There are three major parts to this post:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/#configure-the-edgerouter">Configure the EdgeRouter&lt;/a>&lt;/p>
&lt;p>This shows how to set up an IPv6 tunnel and configure an IPv6-only
VLAN on the EdgeRouter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/#configure-the-switch">Configure the switch&lt;/a>&lt;/p>
&lt;p>This is only necessary due to the specifics of the connection between
my desktop and the router; you can probably skip this.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/#configure-the-desktop">Configure the desktop&lt;/a>&lt;/p>
&lt;p>This shows how to set up the IPv6 VLAN interface under Linux using &lt;code>nmcli&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="what-we-know">What we know&lt;/h2>
&lt;p>When you set up an IPv6 tunnel with hurricane electric, you receive several bits of information. We care in particular about the following (the IPv6 addresses and client IPv4 addresses here have been munged for privacy reasons):&lt;/p>
&lt;h3 id="ipv6-tunnel-endpoints">IPv6 Tunnel Endpoints&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Server IPv4 Address&lt;/td>
&lt;td>209.51.161.14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Server IPv6 Address&lt;/td>
&lt;td>2001:470:1236:1212::1/64&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Client IPv4 Address&lt;/td>
&lt;td>1.2.3.4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Client IPv6 Address&lt;/td>
&lt;td>2001:470:1236:1212::2/64&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="routed-ipv6-prefixes">Routed IPv6 Prefixes&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Routed /64&lt;/td>
&lt;td>2001:470:1237:1212::/64&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>We&amp;rsquo;ll refer back to this information as we configured things later on.&lt;/p>
&lt;h2 id="configure-the-edgerouter">Configure the EdgeRouter&lt;/h2>
&lt;h3 id="create-the-tunnel-interface">Create the tunnel interface&lt;/h3>
&lt;p>The first step in the process is to create a tunnel interface &amp;ndash; that is, an interface that looks like an ordinary network interface, but is in fact encapsulating traffic and sending it to the tunnel broker where it will unpacked and sent on its way.&lt;/p>
&lt;p>I&amp;rsquo;ll be creating a &lt;a href="https://wiki.linuxfoundation.org/networking/tunneling#sit_tunnels">SIT&lt;/a> tunnel, which is designed to &amp;ldquo;interconnect isolated IPv6 networks&amp;rdquo; over an IPv4 connection.&lt;/p>
&lt;p>I start by setting the tunnel encapsulation type and assigning an IPv6 address to the tunnel interface. This is the &amp;ldquo;Client IPv6 Address&amp;rdquo; from the earlier table:&lt;/p>
&lt;pre tabindex="0">&lt;code>set interfaces tunnel tun0 encapsulation sit
set interfaces tunnel tun0 address 2001:470:1236:1212::2/64
&lt;/code>&lt;/pre>&lt;p>Next I need to define the local and remote IPv4 endpoints of the tunnel. The remote endpoint is the &amp;ldquo;Server IPv4&amp;rdquo; address. The value &lt;code>0.0.0.0&lt;/code> for the &lt;code>local-ip&lt;/code> option means &amp;ldquo;whichever source address is appropriate for connecting to the given remote address&amp;rdquo;:&lt;/p>
&lt;pre tabindex="0">&lt;code>set interfaces tunnel tun0 remote-ip 209.51.161.14
set interfaces tunnel tun0 local-ip 0.0.0.0
&lt;/code>&lt;/pre>&lt;p>Finally, I associate some firewall rulesets with the interface. This is import because, unlike IPv4, as you assign IPv6 addresses to internal devices they will be &lt;em>directly connected to the internet&lt;/em>. With no firewall rules in place you would find yourself inadvertently exposing services that previously were &amp;ldquo;behind&amp;rdquo; your home router.&lt;/p>
&lt;pre tabindex="0">&lt;code>set interfaces tunnel tun0 firewall in ipv6-name WANv6_IN
set interfaces tunnel tun0 firewall local ipv6-name WANv6_LOCAL
&lt;/code>&lt;/pre>&lt;p>I&amp;rsquo;m using the existing &lt;code>WANv6_IN&lt;/code> and &lt;code>WANv6_LOCAL&lt;/code> rulesets, which by default block all inbound traffic. These correspond to the following &lt;code>ip6tables&lt;/code> chains:&lt;/p>
&lt;pre tabindex="0">&lt;code>root@ubnt:~# ip6tables -S WANv6_IN
-N WANv6_IN
-A WANv6_IN -m comment --comment WANv6_IN-10 -m state --state RELATED,ESTABLISHED -j RETURN
-A WANv6_IN -m comment --comment WANv6_IN-20 -m state --state INVALID -j DROP
-A WANv6_IN -m comment --comment &amp;#34;WANv6_IN-10000 default-action drop&amp;#34; -j LOG --log-prefix &amp;#34;[WANv6_IN-default-D]&amp;#34;
-A WANv6_IN -m comment --comment &amp;#34;WANv6_IN-10000 default-action drop&amp;#34; -j DROP
root@ubnt:~# ip6tables -S WANv6_LOCAL
-N WANv6_LOCAL
-A WANv6_LOCAL -m comment --comment WANv6_LOCAL-10 -m state --state RELATED,ESTABLISHED -j RETURN
-A WANv6_LOCAL -m comment --comment WANv6_LOCAL-20 -m state --state INVALID -j DROP
-A WANv6_LOCAL -p ipv6-icmp -m comment --comment WANv6_LOCAL-30 -j RETURN
-A WANv6_LOCAL -p udp -m comment --comment WANv6_LOCAL-40 -m udp --sport 547 --dport 546 -j RETURN
-A WANv6_LOCAL -m comment --comment &amp;#34;WANv6_LOCAL-10000 default-action drop&amp;#34; -j LOG --log-prefix &amp;#34;[WANv6_LOCAL-default-D]&amp;#34;
-A WANv6_LOCAL -m comment --comment &amp;#34;WANv6_LOCAL-10000 default-action drop&amp;#34; -j DROP
&lt;/code>&lt;/pre>&lt;p>As you can see, both rulesets block all inbound traffic by default unless it is &lt;em>related&lt;/em> to an existing outbound connection.&lt;/p>
&lt;h3 id="create-a-vlan-interface">Create a vlan interface&lt;/h3>
&lt;p>I need to create a network interface on the router that will be the default gateway for my local IPv6-only network. From the tunnel broker, I received the CIDR &lt;code>2001:470:1237:1212::/64&lt;/code> for local use, so:&lt;/p>
&lt;ul>
&lt;li>I&amp;rsquo;ve decided to split this up into smaller networks (because a /64 has over 18 &lt;em>quintillion&lt;/em> available addresses). I&amp;rsquo;m using &lt;code>/110&lt;/code> networks in this example, which means I will only ever be able to have 262,146 devices on each network (note that the decision to use a smaller subnet impacts your choices for address autoconfiguration; see &lt;a href="https://www.rfc-editor.org/rfc/rfc7421">RFC 7421&lt;/a> for the relevant discussion).&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>I&amp;rsquo;m using the first &lt;code>/110&lt;/code> network for this VLAN, which comprises addresses &lt;code>2001:470:1237:1212::1&lt;/code> through &lt;code>2001:470:1237:1212::3:ffff&lt;/code>. I&amp;rsquo;ll use the first address as the router address.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>I&amp;rsquo;ve arbitrarily decided to use VLAN id 10 for this purpose.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>To create an interface for VLAN id 10 with address &lt;code>2001:470:1237:1212::1/110&lt;/code>, we use the &lt;code>set interfaces ... vif&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>set interfaces switch switch0 vif 10 address 2001:470:1237:1212::1/110
&lt;/code>&lt;/pre>&lt;h3 id="configure-the-default-ipv6-route">Configure the default IPv6 route&lt;/h3>
&lt;p>We don&amp;rsquo;t receive &lt;a href="https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol">router advertisements&lt;/a> over the IPv6 tunnel, which means we need to explicitly configure the IPv6 default route. The default gateway will be the &amp;ldquo;Server IPv6 Address&amp;rdquo; we received from the tunnel broker.&lt;/p>
&lt;pre tabindex="0">&lt;code>set protocol static route6 ::/0 next-hop 2001:470:1236:1212::1
&lt;/code>&lt;/pre>&lt;h3 id="enable-router-advertisements">Enable router advertisements&lt;/h3>
&lt;p>IPv6 systems on our local network will use the &lt;a href="https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol">neighbor discovery protocol&lt;/a> to discover the default gateway for the network. Support for this service is provided by &lt;a href="https://radvd.litech.org/">RADVD&lt;/a>, and we configure it using the &lt;code>set interfaces ... ipv6 router-advert&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>set interfaces switch switch0 vif 10 ipv6 router-advert send-advert true
set interfaces switch switch0 vif 10 ipv6 router-advert managed-flag true
set interfaces switch switch0 vif 10 ipv6 router-advert prefix ::/110
&lt;/code>&lt;/pre>&lt;p>The &lt;code>managed-flag&lt;/code> setting corresponds to the RADVD &lt;code>AdvManagedFlag&lt;/code> configuration setting, which instructs clients to use DHCPv6 for address autoconfiguration.&lt;/p>
&lt;h3 id="configure-the-dhcpv6-service">Configure the DHCPv6 service&lt;/h3>
&lt;p>While in theory it is possible for clients to assign IPv6 addresses without the use of a DHCP server using &lt;a href="https://en.wikipedia.org/wiki/IPv6_address#Stateless_address_autoconfiguration">stateless address autoconfiguration&lt;/a>, this requires that we&amp;rsquo;re using a /64 subnet (see e.g. &lt;a href="https://www.rfc-editor.org/rfc/rfc7421">RFC 7421&lt;/a>). There is no such limitation when using DHCPv6.&lt;/p>
&lt;pre tabindex="0">&lt;code>set service dhcpv6-server shared-network-name VLAN10 subnet 2001:470:1237:1212::/110 address-range start 2001:470:1237:1212::10 stop 2001:470:1237:1212::3:ffff
set service dhcpv6-server shared-network-name VLAN10 subnet 2001:470:1237:1212::/110 name-server 2001:470:1237:1212::1
set service dhcpv6-server shared-network-name VLAN10 subnet 2001:470:1237:1212::/110 domain-search house
set service dhcpv6-server shared-network-name VLAN10 subnet 2001:470:1237:1212::/110 lease-time default 86400
&lt;/code>&lt;/pre>&lt;p>Here I&amp;rsquo;m largely setting things up to mirror the configuration of the IPv4 dhcp server for the &lt;code>name-server&lt;/code>, &lt;code>domain-search&lt;/code>, and &lt;code>lease-time&lt;/code> settings. I&amp;rsquo;m letting the DHCPv6 server allocate pretty much the entire network range, with the exception of the first 10 addresses.&lt;/p>
&lt;h3 id="commit-the-changes">Commit the changes&lt;/h3>
&lt;p>After making the above changes they need to be activated:&lt;/p>
&lt;pre tabindex="0">&lt;code>commit
&lt;/code>&lt;/pre>&lt;h3 id="verify-the-configuration">Verify the configuration&lt;/h3>
&lt;p>This produces the following interface configuration for &lt;code>tun0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>13: tun0@NONE: &amp;lt;POINTOPOINT,NOARP,UP,LOWER_UP&amp;gt; mtu 1480 qdisc noqueue state UNKNOWN group default qlen 1000
link/sit 0.0.0.0 peer 209.51.161.14
inet6 2001:470:1236:1212::2/64 scope global
valid_lft forever preferred_lft forever
inet6 fe80::c0a8:101/64 scope link
valid_lft forever preferred_lft forever
inet6 fe80::6c07:49c7/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>And for &lt;code>switch0.10&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ubnt@ubnt:~$ ip addr show switch0.10
14: switch0.10@switch0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
link/ether 78:8a:20:bb:05:db brd ff:ff:ff:ff:ff:ff
inet6 2001:470:1237:1212::1/110 scope global
valid_lft forever preferred_lft forever
inet6 fe80::7a8a:20ff:febb:5db/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>And the following route configuration:&lt;/p>
&lt;pre tabindex="0">&lt;code>ubnt@ubnt:~$ ip -6 route | grep -v fe80
2001:470:1236:1212::/64 dev tun0 proto kernel metric 256 pref medium
2001:470:1237:1212::/110 dev switch0.10 proto kernel metric 256 pref medium
default via 2001:470:1236:1212::1 dev tun0 proto zebra metric 1024 pref medium
&lt;/code>&lt;/pre>&lt;p>We can confirm things are properly configured by accessing a remote service that reports our ip address:&lt;/p>
&lt;pre tabindex="0">&lt;code>ubnt@ubnt:~$ curl https://api64.ipify.org
2001:470:1236:1212::2
&lt;/code>&lt;/pre>&lt;h2 id="configure-the-switch">Configure the switch&lt;/h2>
&lt;p>In my home network, devices in my office connect to a switch, and the switch connects back to the router. I need to configure the switch (an older Netgear M4100-D12G) to pass the VLAN on to the desktop.&lt;/p>
&lt;h3 id="add-vlan-10-to-the-vlan-database-with-name-ipv6net0">Add vlan 10 to the vlan database with name &lt;code>ipv6net0&lt;/code>&lt;/h3>
&lt;p>I start by defining the VLAN in the VLAN database:&lt;/p>
&lt;pre tabindex="0">&lt;code>vlan database
vlan 10
vlan name 10 ipv6net0
exit
&lt;/code>&lt;/pre>&lt;h3 id="configure-vlan-10-as-a-tagged-member-of-ports-1-10">Configure vlan 10 as a tagged member of ports 1-10&lt;/h3>
&lt;p>Next, I configure the switch to pass VLAN 10 as a tagged VLAN on all switch interfaces:&lt;/p>
&lt;pre tabindex="0">&lt;code>configure
interface 0/1-0/10
vlan participation include 10
vlan tagging 10
exit
exit
&lt;/code>&lt;/pre>&lt;h2 id="configure-the-desktop">Configure the desktop&lt;/h2>
&lt;p>With the above configuration in place, traffic on VLAN 10 will arrive on my Linux desktop (which is connected to the switch we configured in the previous step). I can use &lt;a href="https://developer-old.gnome.org/NetworkManager/stable/nmcli.html">&lt;code>nmcli&lt;/code>&lt;/a>, the &lt;a href="https://networkmanager.dev/">NetworkManager&lt;/a> CLI, to add a VLAN interface (I&amp;rsquo;m using &lt;a href="https://getfedora.org/">Fedora&lt;/a> 37, which uses NetworkManager to manage network interface configuration; other distributions may have different tooling).&lt;/p>
&lt;p>The following command will create a &lt;em>connection&lt;/em> named &lt;code>vlan10&lt;/code>. Bringing up the connection will create an interface named &lt;code>vlan10&lt;/code>, configured to receive traffic on VLAN 10 arriving on &lt;code>eth0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>nmcli con add type vlan con-name vlan10 ifname vlan10 dev eth0 id 10 ipv6.method auto
nmcli con up vlan10
&lt;/code>&lt;/pre>&lt;p>This produces the following interface configuration:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ ip addr show vlan10
7972: vlan10@eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
link/ether 2c:f0:5d:c9:12:a9 brd ff:ff:ff:ff:ff:ff
inet6 2001:470:1237:1212::2:c19a/128 scope global dynamic noprefixroute
valid_lft 85860sec preferred_lft 53460sec
inet6 fe80::ced8:1750:d67c:2ead/64 scope link noprefixroute
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>And the following route configuration:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ ip -6 route show | grep vlan10
2001:470:1237:1212::2:c19a dev vlan10 proto kernel metric 404 pref medium
2001:470:1237:1212::/110 dev vlan10 proto ra metric 404 pref medium
fe80::/64 dev vlan10 proto kernel metric 1024 pref medium
default via fe80::7a8a:20ff:febb:5db dev vlan10 proto ra metric 404 pref medium
&lt;/code>&lt;/pre>&lt;p>We can confirm things are properly configured by accessing a remote service that reports our ip address:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ curl https://api64.ipify.org
2001:470:1237:1212::2:c19a
&lt;/code>&lt;/pre>&lt;p>Note that unlike access using IPv4, the address visible here is the address assigned to our local interface. There is no NAT happening at the router.&lt;/p>
&lt;hr>
&lt;p>Cover image by &lt;a href="https://www.explainthatstuff.com/chris-woodford.html">Chris Woodford/explainthatstuff.com&lt;/a>, licensed under &lt;a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0&lt;/a>.&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Some services (Netflix is a notable example) block access over the IPv6 tunnels because it breaks their geolocation process and prevents them from determining your country of origin. I don&amp;rsquo;t want to break things for other folks in my house just because I want to play with IPv6.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content></item><item><title>Creating a VXLAN overlay network with Open vSwitch</title><link>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</guid><description>&lt;p>In this post, we&amp;rsquo;ll walk through the process of getting virtual
machines on two different hosts to communicate over an overlay network
created using the support for VXLAN in &lt;a href="https://www.openvswitch.org/">Open vSwitch&lt;/a> (or OVS).&lt;/p>
&lt;h2 id="the-test-environment">The test environment&lt;/h2>
&lt;p>For this post, I&amp;rsquo;ll be working with two systems:&lt;/p>
&lt;ul>
&lt;li>&lt;code>node0.ovs.virt&lt;/code> at address 192.168.122.107&lt;/li>
&lt;li>&lt;code>node1.ovs.virt&lt;/code> at address 192.168.122.174&lt;/li>
&lt;/ul>
&lt;p>These hosts are running CentOS 8, although once we get past the
package installs the instructions will be similar for other
distributions.&lt;/p></description><content>&lt;p>In this post, we&amp;rsquo;ll walk through the process of getting virtual
machines on two different hosts to communicate over an overlay network
created using the support for VXLAN in &lt;a href="https://www.openvswitch.org/">Open vSwitch&lt;/a> (or OVS).&lt;/p>
&lt;h2 id="the-test-environment">The test environment&lt;/h2>
&lt;p>For this post, I&amp;rsquo;ll be working with two systems:&lt;/p>
&lt;ul>
&lt;li>&lt;code>node0.ovs.virt&lt;/code> at address 192.168.122.107&lt;/li>
&lt;li>&lt;code>node1.ovs.virt&lt;/code> at address 192.168.122.174&lt;/li>
&lt;/ul>
&lt;p>These hosts are running CentOS 8, although once we get past the
package installs the instructions will be similar for other
distributions.&lt;/p>
&lt;p>While reading through this post, remember that unless otherwise
specified we&amp;rsquo;re going to be running the indicated commands on &lt;em>both&lt;/em>
hosts.&lt;/p>
&lt;h2 id="install-packages">Install packages&lt;/h2>
&lt;p>Before we can get started configuring things we&amp;rsquo;ll need to install OVS
and &lt;a href="https://libvirt.org/">libvirt&lt;/a>. While &lt;code>libvirt&lt;/code> is included with the base CentOS
distribution, for OVS we&amp;rsquo;ll need to add both the &lt;a href="https://fedoraproject.org/wiki/EPEL">EPEL&lt;/a> repository
as well as a recent CentOS &lt;a href="https://www.openstack.org/">OpenStack&lt;/a> repository (OVS is included
in the CentOS OpenStack repositories because it is required by
OpenStack&amp;rsquo;s networking service):&lt;/p>
&lt;pre tabindex="0">&lt;code>yum -y install epel-release centos-release-openstack-victoria
&lt;/code>&lt;/pre>&lt;p>With these additional repositories enabled we can now install the
required packages:&lt;/p>
&lt;pre tabindex="0">&lt;code>yum -y install \
libguestfs-tools-c \
libvirt \
libvirt-daemon-kvm \
openvswitch2.15 \
tcpdump \
virt-install
&lt;/code>&lt;/pre>&lt;h2 id="enable-services">Enable services&lt;/h2>
&lt;p>We need to start both the &lt;code>libvirtd&lt;/code> and &lt;code>openvswitch&lt;/code> services:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable --now openvswitch libvirtd
&lt;/code>&lt;/pre>&lt;p>This command will (a) mark the services to start automatically when
the system boots and (b) immediately start the service.&lt;/p>
&lt;h2 id="configure-libvirt">Configure libvirt&lt;/h2>
&lt;p>When &lt;code>libvirt&lt;/code> is first installed it doesn&amp;rsquo;t have any configured
storage pools. Let&amp;rsquo;s create one in the default location,
&lt;code>/var/lib/libvirt/images&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>virsh pool-define-as default --type dir --target /var/lib/libvirt/images
&lt;/code>&lt;/pre>&lt;p>We need to mark the pool active, and we might as well configure it to
activate automatically next time the system boots:&lt;/p>
&lt;pre tabindex="0">&lt;code>virsh pool-start default
virsh pool-autostart default
&lt;/code>&lt;/pre>&lt;h2 id="configure-open-vswitch">Configure Open vSwitch&lt;/h2>
&lt;h3 id="create-the-bridge">Create the bridge&lt;/h3>
&lt;p>With all the prerequisites out of the way we can finally start working
with Open vSwitch. Our first task is to create the OVS bridge that
will host our VXLAN tunnels. To create a bridge named &lt;code>br0&lt;/code>, we run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-br br0
&lt;/code>&lt;/pre>&lt;p>We can inspect the OVS configuration by running &lt;code>ovs-vsctl show&lt;/code>,
which should output something like:&lt;/p>
&lt;pre tabindex="0">&lt;code>cc1e7217-e393-4e21-97c1-92324d47946d
Bridge br0
Port br0
Interface br0
type: internal
ovs_version: &amp;#34;2.15.1&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s not forget to mark the interface &amp;ldquo;up&amp;rdquo;:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link set br0 up
&lt;/code>&lt;/pre>&lt;h3 id="create-the-vxlan-tunnels">Create the VXLAN tunnels&lt;/h3>
&lt;p>Up until this point we&amp;rsquo;ve been running identical commands on both
&lt;code>node0&lt;/code> and &lt;code>node1&lt;/code>. In order to create our VXLAN tunnels, we need to
provide a remote endpoint for the VXLAN connection, which is going to
be &amp;ldquo;the other host&amp;rdquo;. On &lt;code>node0&lt;/code>, we run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br0 vx_node1 -- set interface vx_node1 \
type=vxlan options:remote_ip=192.168.122.174
&lt;/code>&lt;/pre>&lt;p>This creates a VXLAN interface named &lt;code>vx_node1&lt;/code> (named that way
because the remote endpoint is &lt;code>node1&lt;/code>). The OVS configuration now
looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>cc1e7217-e393-4e21-97c1-92324d47946d
Bridge br0
Port vx_node1
Interface vx_node1
type: vxlan
options: {remote_ip=&amp;#34;192.168.122.174&amp;#34;}
Port br0
Interface br0
type: internal
ovs_version: &amp;#34;2.15.1&amp;#34;
&lt;/code>&lt;/pre>&lt;p>On &lt;code>node1&lt;/code> we will run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br0 vx_node0 -- set interface vx_node0 \
type=vxlan options:remote_ip=192.168.122.107
&lt;/code>&lt;/pre>&lt;p>Which results in:&lt;/p>
&lt;pre tabindex="0">&lt;code>58451994-e0d1-4bf1-8f91-7253ddf4c016
Bridge br0
Port br0
Interface br0
type: internal
Port vx_node0
Interface vx_node0
type: vxlan
options: {remote_ip=&amp;#34;192.168.122.107&amp;#34;}
ovs_version: &amp;#34;2.15.1&amp;#34;
&lt;/code>&lt;/pre>&lt;p>At this point, we have a functional overlay network: anything attached
to &lt;code>br0&lt;/code> on either system will appear to share the same layer 2
network. Let&amp;rsquo;s take advantage of this to connect a pair of virtual
machines.&lt;/p>
&lt;h2 id="create-virtual-machines">Create virtual machines&lt;/h2>
&lt;h3 id="download-a-base-image">Download a base image&lt;/h3>
&lt;p>We&amp;rsquo;ll need a base image for our virtual machines. I&amp;rsquo;m going to use the
CentOS 8 Stream image, which we can download to our storage directory
like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -L -o /var/lib/libvirt/images/centos-8-stream.qcow2 \
https://cloud.centos.org/centos/8-stream/x86_64/images/CentOS-Stream-GenericCloud-8-20210210.0.x86_64.qcow2
&lt;/code>&lt;/pre>&lt;p>We need to make sure &lt;code>libvirt&lt;/code> is aware of the new image:&lt;/p>
&lt;pre tabindex="0">&lt;code>virsh pool-refresh default
&lt;/code>&lt;/pre>&lt;p>Lastly, we&amp;rsquo;ll want to set a root password on the image so that we can
log in to our virtual machines:&lt;/p>
&lt;pre tabindex="0">&lt;code>virt-customize -a /var/lib/libvirt/images/centos-8-stream.qcow2 \
--root-password password:secret
&lt;/code>&lt;/pre>&lt;h3 id="create-the-virtual-machine">Create the virtual machine&lt;/h3>
&lt;p>We&amp;rsquo;re going to create a pair of virtual machines (one on each host).
We&amp;rsquo;ll be creating each vm with two network interfaces:&lt;/p>
&lt;ul>
&lt;li>One will be attached to the libvirt &lt;code>default&lt;/code> network; this will
allow us to &lt;code>ssh&lt;/code> into the vm in order to configure things.&lt;/li>
&lt;li>The second will be attached to the OVS bridge&lt;/li>
&lt;/ul>
&lt;p>To create a virtual machine on &lt;code>node0&lt;/code> named &lt;code>vm0.0&lt;/code>, run the
following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>virt-install \
-r 3000 \
--network network=default \
--network bridge=br0,virtualport.type=openvswitch \
--os-variant centos8 \
--disk pool=default,size=10,backing_store=centos-8-stream.qcow2,backing_format=qcow2 \
--import \
--noautoconsole \
-n vm0.0
&lt;/code>&lt;/pre>&lt;p>The most interesting option in the above command line is probably the
one used to create the virtual disk:&lt;/p>
&lt;pre tabindex="0">&lt;code>--disk pool=default,size=10,backing_store=centos-8-stream.qcow2,backing_format=qcow2 \
&lt;/code>&lt;/pre>&lt;p>This creates a 10GB &amp;ldquo;&lt;a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write&lt;/a>&amp;rdquo; disk that uses
&lt;code>centos-8-stream.qcow2&lt;/code> as a backing store. That means that reads will
generally come from the &lt;code>centos-8-stream.qcow2&lt;/code> image, but writes will
be stored in the new image. This makes it easy for us to quickly
create multiple virtual machines from the same base image.&lt;/p>
&lt;p>On &lt;code>node1&lt;/code> we would run a similar command, although here we&amp;rsquo;re naming
the virtual machine &lt;code>vm1.0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>virt-install \
-r 3000 \
--network network=default \
--network bridge=br0,virtualport.type=openvswitch \
--os-variant centos8 \
--disk pool=default,size=10,backing_store=centos-8-stream.qcow2,backing_format=qcow2 \
--import \
--noautoconsole \
-n vm1.0
&lt;/code>&lt;/pre>&lt;h3 id="configure-networking-for-vm00">Configure networking for vm0.0&lt;/h3>
&lt;p>On &lt;code>node0&lt;/code>, get the address of the new virtual machine on the default
network using the &lt;code>virsh domifaddr&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node0 ~]# virsh domifaddr vm0.0
Name MAC address Protocol Address
-------------------------------------------------------------------------------
vnet2 52:54:00:21:6e:4f ipv4 192.168.124.83/24
&lt;/code>&lt;/pre>&lt;p>Connect to the vm using &lt;code>ssh&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node0 ~]# ssh 192.168.124.83
root@192.168.124.83&amp;#39;s password:
Activate the web console with: systemctl enable --now cockpit.socket
Last login: Sat Apr 17 14:08:17 2021 from 192.168.124.1
[root@localhost ~]#
&lt;/code>&lt;/pre>&lt;p>(Recall that the &lt;code>root&lt;/code> password is &lt;code>secret&lt;/code>.)&lt;/p>
&lt;p>Configure interface &lt;code>eth1&lt;/code> with an address. For this post, we&amp;rsquo;ll use
the &lt;code>10.0.0.0/24&lt;/code> range for our overlay network. To assign this vm the
address &lt;code>10.0.0.10&lt;/code>, we can run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip addr add 10.0.0.10/24 dev eth1
ip link set eth1 up
&lt;/code>&lt;/pre>&lt;h3 id="configure-networking-for-vm10">Configure networking for vm1.0&lt;/h3>
&lt;p>We need to repeat the process for &lt;code>vm1.0&lt;/code> on &lt;code>node1&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node1 ~]# virsh domifaddr vm1.0
Name MAC address Protocol Address
-------------------------------------------------------------------------------
vnet0 52:54:00:e9:6e:43 ipv4 192.168.124.69/24
&lt;/code>&lt;/pre>&lt;p>Connect to the vm using &lt;code>ssh&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node0 ~]# ssh 192.168.124.69
root@192.168.124.69&amp;#39;s password:
Activate the web console with: systemctl enable --now cockpit.socket
Last login: Sat Apr 17 14:08:17 2021 from 192.168.124.1
[root@localhost ~]#
&lt;/code>&lt;/pre>&lt;p>We&amp;rsquo;ll use address 10.0.0.11 for this system:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip addr add 10.0.0.11/24 dev eth1
ip link set eth1 up
&lt;/code>&lt;/pre>&lt;h3 id="verify-connectivity">Verify connectivity&lt;/h3>
&lt;p>At this point, our setup is complete. On &lt;code>vm0.0&lt;/code>, we can connect to
&lt;code>vm1.1&lt;/code> over the overlay network. For example, we can ping the remote
host:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@localhost ~]# ping -c2 10.0.0.11
PING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.
64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=1.79 ms
64 bytes from 10.0.0.11: icmp_seq=2 ttl=64 time=0.719 ms
--- 10.0.0.11 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 0.719/1.252/1.785/0.533 ms
&lt;/code>&lt;/pre>&lt;p>Or connect to it using &lt;code>ssh&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@localhost ~]# ssh 10.0.0.11 uptime
root@10.0.0.11&amp;#39;s password:
14:21:33 up 1:18, 1 user, load average: 0.00, 0.00, 0.00
&lt;/code>&lt;/pre>&lt;p>Using &lt;code>tcpdump&lt;/code>, we can verify that these connections are going over
the overlay network. Let&amp;rsquo;s watch for VXLAN traffic on &lt;code>node1&lt;/code> by
running the following command (VXLAN is a UDP protocol running on port
4789)&lt;/p>
&lt;pre tabindex="0">&lt;code>tcpdump -i eth0 -n port 4789
&lt;/code>&lt;/pre>&lt;p>When we run &lt;code>ping -c2 10.0.0.11&lt;/code> on &lt;code>vm0.0&lt;/code>, we see the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>14:23:50.312574 IP 192.168.122.107.52595 &amp;gt; 192.168.122.174.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.10 &amp;gt; 10.0.0.11: ICMP echo request, id 4915, seq 1, length 64
14:23:50.314896 IP 192.168.122.174.59510 &amp;gt; 192.168.122.107.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.11 &amp;gt; 10.0.0.10: ICMP echo reply, id 4915, seq 1, length 64
14:23:51.314080 IP 192.168.122.107.52595 &amp;gt; 192.168.122.174.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.10 &amp;gt; 10.0.0.11: ICMP echo request, id 4915, seq 2, length 64
14:23:51.314259 IP 192.168.122.174.59510 &amp;gt; 192.168.122.107.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.11 &amp;gt; 10.0.0.10: ICMP echo reply, id 4915, seq 2, length 64
&lt;/code>&lt;/pre>&lt;p>In the output above, we see that each packet in the transaction
results in two lines of output from &lt;code>tcpdump&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>14:23:50.312574 IP 192.168.122.107.52595 &amp;gt; 192.168.122.174.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.10 &amp;gt; 10.0.0.11: ICMP echo request, id 4915, seq 1, length 64
&lt;/code>&lt;/pre>&lt;p>The first line shows the contents of the VXLAN packet, while the
second lines shows the data that was encapsulated in the VXLAN packet.&lt;/p>
&lt;h2 id="thats-all-folks">That&amp;rsquo;s all folks&lt;/h2>
&lt;p>We&amp;rsquo;ve achieved our goal: we have two virtual machines on two different
hosts communicating over a VXLAN overlay network. If you were to do
this &amp;ldquo;for real&amp;rdquo;, you would probably want to make a number of changes:
for example, the network configuration we&amp;rsquo;ve applied in many cases
will not persist across a reboot; handling persistent network
configuration is still very distribution dependent, so I&amp;rsquo;ve left it
out of this post.&lt;/p></content></item><item><title>OpenShift and CNV: Exposing virtualized services</title><link>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/</link><pubDate>Thu, 30 Jul 2020 01:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/</guid><description>&lt;p>This is the second in a &lt;a href="https://blog.oddbit.com/tag/openshift-and-cnv">series of posts&lt;/a> about my experience working
with &lt;a href="https://www.openshift.com/">OpenShift&lt;/a> and &lt;a href="https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization">CNV&lt;/a>. In this post, I&amp;rsquo;ll be taking a look
at how to expose services on a virtual machine once you&amp;rsquo;ve git it up
and running.&lt;/p>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#tldr">TL;DR&lt;/a>&lt;/li>
&lt;li>&lt;a href="#overview">Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#connectivity-options">Connectivity options&lt;/a>&lt;/li>
&lt;li>&lt;a href="#direct-attachment">Direct attachment&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-an-openshift-service">Using an OpenShift Service&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#exposing-services-on-nodeports">Exposing services on NodePorts&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exposing-services-on-cluster-external-ipso">Exposing services on cluster external IPso&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exposing-services-using-a-loadbalancer">Exposing services using a LoadBalancer&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>Networking seems to be a weak area for CNV right now. Out of the box,
your options for exposing a service on a virtual machine on a public
address at a well known port are slim.&lt;/p></description><content>&lt;p>This is the second in a &lt;a href="https://blog.oddbit.com/tag/openshift-and-cnv">series of posts&lt;/a> about my experience working
with &lt;a href="https://www.openshift.com/">OpenShift&lt;/a> and &lt;a href="https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization">CNV&lt;/a>. In this post, I&amp;rsquo;ll be taking a look
at how to expose services on a virtual machine once you&amp;rsquo;ve git it up
and running.&lt;/p>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#tldr">TL;DR&lt;/a>&lt;/li>
&lt;li>&lt;a href="#overview">Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#connectivity-options">Connectivity options&lt;/a>&lt;/li>
&lt;li>&lt;a href="#direct-attachment">Direct attachment&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-an-openshift-service">Using an OpenShift Service&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#exposing-services-on-nodeports">Exposing services on NodePorts&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exposing-services-on-cluster-external-ipso">Exposing services on cluster external IPso&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exposing-services-using-a-loadbalancer">Exposing services using a LoadBalancer&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>Networking seems to be a weak area for CNV right now. Out of the box,
your options for exposing a service on a virtual machine on a public
address at a well known port are slim.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>We&amp;rsquo;re hoping to use OpenShift + CNV as an alternative to existing
hypervisor platforms, primarily to reduce the number of complex,
distributed projects we need to manage. If we can have a single
control plane for both containerized and virtualized workloads, it
seems like a win for everyone.&lt;/p>
&lt;p>In order to support the most common use case for our virtualization
platforms, consumers of this service need to be able to:&lt;/p>
&lt;ul>
&lt;li>Start a virtual machine using an image of their choice&lt;/li>
&lt;li>Expose services on that virtual machine using well-known ports
on a routeable ip address&lt;/li>
&lt;/ul>
&lt;p>All of the above should be self service (that is, none of those steps
should requiring opening a support ticket or otherwise require
administrative assistance).&lt;/p>
&lt;h2 id="connectivity-options">Connectivity options&lt;/h2>
&lt;p>There are broadly two major connectivity models available to CNV
managed virtual machines:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/#direct-attachment">Direct attachment to a host network&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/#using-an-openshift-service">Using an OpenShift Service&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>We&amp;rsquo;re going to start with the direct attachment model, since this may
be familiar to people coming to CNV from other hypervisor platforms.&lt;/p>
&lt;h2 id="direct-attachment">Direct attachment&lt;/h2>
&lt;p>With a little configuration, it is possible to attach virtual machines
directly to an existing layer two network.&lt;/p>
&lt;p>When running CNV, you can affect the network configuration of your
OpenShift hosts by creating &lt;code>NodeNetworkConfigurationPolicy&lt;/code>
objects. Support for this is provided by &lt;code>nmstate&lt;/code>, which is packaged
with CNV. For details, see &amp;ldquo;&lt;a href="https://docs.openshift.com/container-platform/4.4/cnv/cnv_node_network/cnv-updating-node-network-config.html">Updating node network configuration&lt;/a>&amp;rdquo; in
the OpenShift documentation.&lt;/p>
&lt;p>For example, if we want to create a bridge interface on our nodes to
permit CNV managed virtual machines to attach to the network
associated with interface &lt;code>eth1&lt;/code>, we might submit the following
configuration:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: nmstate.io/v1alpha1
kind: NodeNetworkConfigurationPolicy
metadata:
name: br-example-policy
spec:
nodeSelector:
node-role.kubernetes.io/worker: &amp;#34;&amp;#34;
desiredState:
interfaces:
- name: br-example
type: linux-bridge
state: up
ipv4:
dhcp: true
enabled: true
bridge:
options:
stp:
enabled: false
port:
- name: eth1
&lt;/code>&lt;/pre>&lt;p>This would create a Linux bridge device &lt;code>br-example&lt;/code> with interface
&lt;code>eth1&lt;/code> as a member. In order to expose this bridge to virtual
machines, we need to create a &lt;code>NetworkAttachmentDefinition&lt;/code> (which can
be abbreviated as &lt;code>net-attach-def&lt;/code>, but not as &lt;code>nad&lt;/code> for reasons that
may be obvious to English speakers or readers of Urban Dictionary).&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: k8s.cni.cncf.io/v1
kind: NetworkAttachmentDefinition
metadata:
name: example
namespace: default
spec:
config: &amp;gt;-
{
&amp;#34;name&amp;#34;: &amp;#34;example&amp;#34;,
&amp;#34;cniVersion&amp;#34;: &amp;#34;0.3.1&amp;#34;,
&amp;#34;plugins&amp;#34;: [
{
&amp;#34;type&amp;#34;: &amp;#34;cnv-bridge&amp;#34;,
&amp;#34;bridge&amp;#34;: &amp;#34;br-example&amp;#34;,
&amp;#34;ipam&amp;#34;: {}
},
{
&amp;#34;type&amp;#34;: &amp;#34;cnv-tuning&amp;#34;
}
]
}
&lt;/code>&lt;/pre>&lt;p>Once you have the above definitions in place, it&amp;rsquo;s easy to select this
network when adding interfaces to a virtual machine. Actually making
use of these connections can be a little difficult.&lt;/p>
&lt;p>In a situation that may remind of you of &lt;a href="https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-1-worki/">some issues we had with the
installer&lt;/a>, your virtual machine will boot with a randomly
generated MAC address. Under CNV, generated MAC addresses are
associated with &lt;code>VirtualMachineInstance&lt;/code> resources, which represents
currently running virtual machines. Your &lt;code>VirtualMachine&lt;/code> object is
effectively a template used to generate a new &lt;code>VirtualMachineInstance&lt;/code>
each time it boots. Because the address is associated with the
&lt;em>instance&lt;/em>, you get a new MAC address every time you boot the virtual
machine. That makes it very difficult to associate a static IP address
with your CNV managed virtual machine.&lt;/p>
&lt;p>It is possible to manually assign a MAC address to the virtual machine
when you create, but now you have a bevy of new problems:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Anybody who wants to deploy a virtual machine needs to know what a
MAC address looks like (you laugh, but this isn&amp;rsquo;t something people
generally have to think about).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You probably need some way to track MAC address allocation to avoid
conflicts when everyone chooses &lt;code>DE:AD:BE:EF:CA:FE&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="using-an-openshift-service">Using an OpenShift Service&lt;/h2>
&lt;p>Out of the box, your virtual machines can attach to the default pod
network, which is private network that provides masqueraded outbound
access and no direct inbound access. In this situation, your virtual
machine behaves much more like a container from a network perspective,
and you have access to many of the same network primitives available
to pods. You access these mechanisms by creating an OpenShift
&lt;code>Service&lt;/code> resource.&lt;/p>
&lt;p>Under OpenShift, a &lt;code>Service&lt;/code> is used to &amp;ldquo;expose an application running
on a set of &lt;code>Pods&lt;/code> as a network service (from &lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/">the Kubernetes
documentation&lt;/a>&amp;rdquo;. From the perspective of OpenShift, your
virtual machine is just another application running in a Pod, so we
can use Service resources to expose applications running on your
virtual machine.&lt;/p>
&lt;p>In order to manage these options, you&amp;rsquo;ll want to install the
&lt;code>virtctl&lt;/code> client. You can grab an &lt;a href="https://github.com/kubevirt/kubevirt/releases">upstream release&lt;/a> from the
&lt;a href="https://github.com/kubevirt/kubevirt">kubevirt&lt;/a> project, or you can &lt;a href="https://docs.openshift.com/container-platform/4.2/cnv/cnv_install/cnv-installing-virtctl.html">enable the appropriate
repositories&lt;/a> and install the &lt;code>kubevirt-virtctl&lt;/code> package.&lt;/p>
&lt;h3 id="exposing-services-on-nodeports">Exposing services on NodePorts&lt;/h3>
&lt;p>A &lt;code>NodePort&lt;/code> lets you expose a service on a random port associated
with the ip addresses of your OpenShift nodes. If you have a virtual
machine named &lt;code>test-vm-1&lt;/code> and you want to access the SSH service on
port 22, you can use the &lt;code>virtctl&lt;/code> command like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>virtctl expose vm test-vm-1 --port=22 --name=myvm-ssh-np --type=NodePort
&lt;/code>&lt;/pre>&lt;p>This will result in &lt;code>Service&lt;/code> that looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ oc get service myvm-ssh-np
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
myvm-ssh-np NodePort 172.30.4.25 &amp;lt;none&amp;gt; 22:31424/TCP 42s
&lt;/code>&lt;/pre>&lt;p>The &lt;code>CLUSTER-IP&lt;/code> in the above output is a cluster internal IP address
that can be used to connect to your server from other containers or
virtual machines. The &lt;code>22:31424/TCP&lt;/code> entry tells us that port &lt;code>31424&lt;/code>
on our OpenShift hosts now maps to port &lt;code>22&lt;/code> in our virtual machine.&lt;/p>
&lt;p>You can connect to your virtual machine with an &lt;code>ssh&lt;/code> command line
along the lines of:&lt;/p>
&lt;pre tabindex="0">&lt;code>ssh -p 31424 someuser@hostname.of.a.node
&lt;/code>&lt;/pre>&lt;p>You can use the hostname of any node in your OpenShift cluster.&lt;/p>
&lt;p>This is fine for testing things out, but it doesn&amp;rsquo;t allow you to
expose services on a well known port, and the cluster administrator
may be uncomfortable with services like this using the ip addresses of
cluster hosts.&lt;/p>
&lt;h3 id="exposing-services-on-cluster-external-ipso">Exposing services on cluster external IPso&lt;/h3>
&lt;p>It is possible to manually assign an external ip address to an
OpenShift service. For example:&lt;/p>
&lt;pre tabindex="0">&lt;code>virtctl expose vm test-vm-1 --port 22 --name myvm-ssh-ext --external-ip 192.168.185.18
&lt;/code>&lt;/pre>&lt;p>Which results in the follow service:&lt;/p>
&lt;pre tabindex="0">&lt;code>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
myvm-ssh-ext ClusterIP 172.30.224.127 192.168.185.18 22/TCP 47s
&lt;/code>&lt;/pre>&lt;p>While this sounds promising at first, there are several caveats:&lt;/p>
&lt;ul>
&lt;li>We once again find ourselves needing to manually manage a pool of
addresses.&lt;/li>
&lt;li>By default, assigning an external ip address requires cluster-admin
privileges.&lt;/li>
&lt;li>Once an external ip is assigned to a service, OpenShift doesn&amp;rsquo;t
actually take care of configuring that address on any host
interfaces: it is up to the local administrator to arrange for
traffic to that address to arrive at the cluster.&lt;/li>
&lt;/ul>
&lt;p>The practical impact of setting an external ip on a service is to
instantiate netfilter rules equivalent to the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>-d 192.168.185.18/32 -p tcp --dport 22 -j DNAT --to-destination 10.129.2.11:22
&lt;/code>&lt;/pre>&lt;p>If you configure the address &lt;code>192.168.185.18&lt;/code> on a host interface (or
otherwise arrange for traffic to that address to reach your host),
these rules take care of directing the connection to your virtual
machine.&lt;/p>
&lt;h3 id="exposing-services-using-a-loadbalancer">Exposing services using a LoadBalancer&lt;/h3>
&lt;p>Historically, OpenShift was designed to run in cloud environments such
as OpenStack, AWS, Google Cloud Engine, and so forth. These platforms
provide integrated load balancer mechanisms that OpenShift was able to
leverage to expose services. Creating a &lt;code>LoadBalancer&lt;/code> service would
instruct the platform to (a) allocate an address, (b) create a load
balancer, and (c) direct traffic from the load balancer to the target
of your service.&lt;/p>
&lt;p>We can request a &lt;code>LoadBalancer&lt;/code> using &lt;code>virtctl&lt;/code> like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>virtctl expose vm test-vm-1 --port=22 --name=myvm-ssh-np --type=LoadBalancer
&lt;/code>&lt;/pre>&lt;p>Unfortunately, OpenShift for baremetal hosts does not include a load
balancer out of the box. This is a shame, because the &lt;code>LoadBalancer&lt;/code>
solution hits just about all of our requirements:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>It automatically assigns ip addresses from a configured pool, so
consumers of the environment don&amp;rsquo;t need to manage either ip- or
MAC-address assignment on their own.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It doesn&amp;rsquo;t require special privileges or administrator intervention
(other than for the initial configuration).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It lets you expose services on ports of your choice, rather than
random ports.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>There are some solutions out there that will provide an integrated
load balancer implementation for your baremetal cluster. I&amp;rsquo;ve looked
at:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/redhat-cop/keepalived-operator">keepalived-operator&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://metallb.universe.tf/">metallb&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>I hope we see an integrated LoadBalancer mechanism available for OpenShift on
baremetal in a near-future release.&lt;/p></content></item><item><title>Configuring Open vSwitch with nmcli</title><link>https://blog.oddbit.com/post/2020-02-15-configuring-open-vswitch-with/</link><pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-02-15-configuring-open-vswitch-with/</guid><description>&lt;p>I recently acquired a managed switch for my home office in order to segment a few devices off onto their own isolated vlan. As part of this, I want to expose these vlans on my desktop using Open vSwitch (OVS), and I wanted to implement the configuration using NetworkManager rather than either relying on the legacy &lt;code>/etc/sysconfig/network-scripts&lt;/code> scripts or rolling my own set of services. These are my notes in case I ever have to do this again.&lt;/p></description><content>&lt;p>I recently acquired a managed switch for my home office in order to segment a few devices off onto their own isolated vlan. As part of this, I want to expose these vlans on my desktop using Open vSwitch (OVS), and I wanted to implement the configuration using NetworkManager rather than either relying on the legacy &lt;code>/etc/sysconfig/network-scripts&lt;/code> scripts or rolling my own set of services. These are my notes in case I ever have to do this again.&lt;/p>
&lt;p>First, we need the openvswitch plugin for NetworkManager:&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install NetworkManager-ovs
&lt;/code>&lt;/pre>&lt;p>Without the plugin, &lt;code>nmcli&lt;/code> will happily accept all your configuration commands, but you&amp;rsquo;ll get an error when you try to bring an interface up.&lt;/p>
&lt;h2 id="target-configuration">Target configuration&lt;/h2>
&lt;p>This is what I want when we&amp;rsquo;re done:&lt;/p>
&lt;pre tabindex="0">&lt;code>1e668de8-c2ac-4dd7-9824-95e1cade31ce
Bridge br-house
Port &amp;#34;vlan1&amp;#34;
tag: 1
Interface &amp;#34;vlan1&amp;#34;
type: internal
Port &amp;#34;vlan102&amp;#34;
tag: 102
Interface &amp;#34;vlan102&amp;#34;
type: internal
Port br-house
Interface br-house
type: internal
Port &amp;#34;eth0&amp;#34;
Interface &amp;#34;eth0&amp;#34;
type: system
Port &amp;#34;vlan101&amp;#34;
tag: 101
Interface &amp;#34;vlan101&amp;#34;
type: internal
ovs_version: &amp;#34;2.12.0&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="nmcli-commands">NMCLI commands&lt;/h2>
&lt;p>To create the ovs bridge:&lt;/p>
&lt;pre tabindex="0">&lt;code>nmcli c add type ovs-bridge conn.interface br-house con-name br-house
nmcli c add type ovs-port conn.interface br-house master br-house con-name ovs-port-br-house
nmcli c add type ovs-interface slave-type ovs-port conn.interface br-house master ovs-port-br-house con-name ovs-if-br-house
&lt;/code>&lt;/pre>&lt;p>Unlike &lt;code>ovs-vsctl&lt;/code>, creating the bridge won&amp;rsquo;t automatically create an interface for you. The two additional commands above get us an actual interface named &lt;code>br-house&lt;/code> (configured using DHCP, because we didn&amp;rsquo;t explicitly set &lt;code>ipv4.method&lt;/code> on the interface).&lt;/p>
&lt;p>Next, we add &lt;code>eth0&lt;/code> to the bridge:&lt;/p>
&lt;pre tabindex="0">&lt;code>nmcli c add type ovs-port conn.interface eth0 master br-house con-name ovs-port-eth0
nmcli c add type ethernet conn.interface eth0 master ovs-port-eth0 con-name ovs-if-eth0
&lt;/code>&lt;/pre>&lt;p>And finally, we create some ports to expose specific vlans:&lt;/p>
&lt;pre tabindex="0">&lt;code>nmcli c add type ovs-port conn.interface vlan1 master br-house ovs-port.tag 1 con-name ovs-port-vlan1
nmcli c add type ovs-interface slave-type ovs-port conn.interface vlan1 master ovs-port-vlan1 con-name ovs-if-vlan1 ipv4.method static ipv4.address 192.168.7.1/24
nmcli c add type ovs-port conn.interface vlan101 master br-house ovs-port.tag 101 con-name ovs-port-vlan101
nmcli c add type ovs-interface slave-type ovs-port conn.interface vlan101 master ovs-port-vlan101 con-name ovs-if-vlan101 ipv4.method static ipv4.address 192.168.11.1/24
nmcli c add type ovs-port conn.interface vlan102 master br-house ovs-port.tag 102 con-name ovs-port-vlan102
nmcli c add type ovs-interface slave-type ovs-port conn.interface vlan102 master ovs-port-vlan102 con-name ovs-if-vlan102 ipv4.method static ipv4.address 192.168.13.1/24
&lt;/code>&lt;/pre></content></item><item><title>OVN and DHCP: A minimal example</title><link>https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>A long time ago, I wrote an article &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">all about OpenStack Neutron&lt;/a> (which at that time was called Quantum). That served as an excellent reference for a number of years, but if you&amp;rsquo;ve deployed a recent version of OpenStack you may have noticed that the network architecture looks completely different. The network namespaces previously used to implement routers and dhcp servers are gone (along with iptables rules and other features), and have been replaced by OVN (&amp;ldquo;Open Virtual Network&amp;rdquo;). What is OVN? How does it work? In this article, I&amp;rsquo;d like to explore a minimal OVN installation to help answer these questions.&lt;/p></description><content>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>A long time ago, I wrote an article &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">all about OpenStack Neutron&lt;/a> (which at that time was called Quantum). That served as an excellent reference for a number of years, but if you&amp;rsquo;ve deployed a recent version of OpenStack you may have noticed that the network architecture looks completely different. The network namespaces previously used to implement routers and dhcp servers are gone (along with iptables rules and other features), and have been replaced by OVN (&amp;ldquo;Open Virtual Network&amp;rdquo;). What is OVN? How does it work? In this article, I&amp;rsquo;d like to explore a minimal OVN installation to help answer these questions.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>We&amp;rsquo;re going to create a single OVN logical switch to which we will attach a few ports. We will demonstrate how we can realize a port on a physical node and configure it using DHCP, using a virtual DHCP server provided by OVN.&lt;/p>
&lt;h2 id="so-what-is-ovn-anyway">So what is OVN anyway?&lt;/h2>
&lt;p>If you&amp;rsquo;re just getting started with OVN, you&amp;rsquo;ll find that&amp;rsquo;s a hard question to answer: there is no dedicated OVN website; there&amp;rsquo;s no OVN landing page at &lt;a href="http://openvswitch.org">http://openvswitch.org&lt;/a>; in fact, there&amp;rsquo;s really no documentation for OVN at all other than the man pages. The only high-level description you&amp;rsquo;ll find comes from the &lt;code>ovn-architecture(7)&lt;/code> man page:&lt;/p>
&lt;blockquote>
&lt;p>OVN, the Open Virtual Network, is a system to support virtual network
abstraction. OVN complements the existing capabilities of OVS to add
native support for virtual network abstractions, such as virtual L2 and L3
overlays and security groups.&lt;/p>
&lt;/blockquote>
&lt;p>Where Open vSwitch (OVS) provides a virtual switch on a single host, OVN extends this abstraction to span multiple hosts. You can create virtual switches that span many physical nodes, and OVN will take care of creating overlay networks to support this abstraction. While OVS is primarily just a layer 2 device, OVN also operates at layer 3: you can create virtual routers to connect your virtual networks as well a variety of access control mechanisms such as security groups and ACLs.&lt;/p>
&lt;h2 id="requirements">Requirements&lt;/h2>
&lt;p>You&amp;rsquo;re going to need a recent version of OVN. Packages are available for &lt;a href="http://docs.openvswitch.org/en/latest/intro/install/distributions/">most major distributions&lt;/a>. I used &lt;a href="https://getfedora.org/">Fedora 31&lt;/a> for my testing, which includes OVS and OVN version 2.12.0. You can of course also &lt;a href="http://docs.openvswitch.org/en/latest/intro/install/">install from source&lt;/a>.&lt;/p>
&lt;p>This post assumes that you are logged in to your system as the &lt;code>root&lt;/code> user. Most of the commands require root access in order to function correctly.&lt;/p>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>OVN operates with a pair of databases. The &lt;em>Northbound&lt;/em> database contains the &lt;em>logical&lt;/em> structure of your networks: this is where you define switches, routers, ports, and so on.&lt;/p>
&lt;p>The &lt;em>Southbound&lt;/em> database is concerned with the &lt;em>physical&lt;/em> structure of your network. This database maintains information about which ports are realized on which hosts.&lt;/p>
&lt;p>The &lt;a href="http://www.openvswitch.org/support/dist-docs/ovn-northd.8.html">&lt;code>ovn-northd&lt;/code>&lt;/a> service &amp;ldquo;translates the logical network configuration in terms of conventional network concepts, taken from the OVN North‐ bound Database, into logical datapath flows in the OVN Southbound Database below it.&amp;rdquo; (&lt;a href="http://www.openvswitch.org/support/dist-docs/ovn-architecture.7.html">ovn-architecture(7)&lt;/a>)&lt;/p>
&lt;p>The &lt;a href="http://www.openvswitch.org/support/dist-docs/ovn-controller.8.html">&lt;code>ovn-controller&lt;/code>&lt;/a> service running on each host connects to the Southbound database and is responsible for configuring OVS as instructed by the database configuration.&lt;/p>
&lt;h2 id="test-environment">Test environment&lt;/h2>
&lt;p>This article assumes a test environment with three nodes running Fedora 31. All nodes have a single interface connecting to a shared layer 2 network:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>MAC address&lt;/th>
&lt;th>IP address&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ovn0&lt;/td>
&lt;td>de:ca:ff:00:00:64&lt;/td>
&lt;td>192.168.122.100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ovn1&lt;/td>
&lt;td>de:ca:ff:00:00:65&lt;/td>
&lt;td>192.168.122.101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ovn2&lt;/td>
&lt;td>de:ca:ff:00:00:66&lt;/td>
&lt;td>192.168.122.102&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="setting-up-ovn">Setting up OVN&lt;/h1>
&lt;h2 id="initial-configuration-steps">Initial configuration steps&lt;/h2>
&lt;p>Our first step will be to activate &lt;code>openvswitch&lt;/code> and &lt;code>ovn-controller&lt;/code> on all of the nodes in our test environment. On all nodes, run the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable --now openvswitch ovn-controller
&lt;/code>&lt;/pre>&lt;p>The &lt;code>--now&lt;/code> flag causes &lt;code>systemd&lt;/code> to start the service as well as enabling it in future boots.&lt;/p>
&lt;p>By default, OVN manages an &lt;code>openvswitch&lt;/code> bridge named &lt;code>br-int&lt;/code> (for &amp;ldquo;integration&amp;rdquo;). We&amp;rsquo;ll need to create this on all of our nodes. On all nodes, run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-br br-int
&lt;/code>&lt;/pre>&lt;h2 id="configuring-the-controller">Configuring the controller&lt;/h2>
&lt;p>We will designate the node &lt;code>ovn0&lt;/code> as our controller (which simply means &amp;ldquo;this node will run &lt;code>ovn-northd&lt;/code>). The first thing we need to do is enable the &lt;code>ovn-northd&lt;/code> service. On node &lt;code>ovn0&lt;/code>, run:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable --now ovn-northd
&lt;/code>&lt;/pre>&lt;p>In addition to starting the &lt;code>ovn-northd&lt;/code> service itself, this will also starts two instances of &lt;a href="http://www.openvswitch.org/support/dist-docs/ovsdb-server.1.html">&lt;code>ovsdb-server&lt;/code>&lt;/a>: one serving the Northbound database, listening on &lt;code>/run/ovn/ovnnb_db.sock&lt;/code>, and the second for the Southbound database, listening on &lt;code>/run/ovn/ovnsb_db.sock&lt;/code>. In order for the &lt;code>ovn-controller&lt;/code> service on the other nodes to connect to the Southbound database, we will need to configure that instance of &lt;code>ovsdb-server&lt;/code> to listen for tcp connections. We can do that using the &lt;code>ovn-sbctl set-connection&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-sbctl set-connection ptcp:6642
&lt;/code>&lt;/pre>&lt;p>The &lt;code>ptcp&lt;/code> in the above setting means &amp;ldquo;passive tcp&amp;rdquo;, which means &amp;ldquo;listen on port 6642 for connections&amp;rdquo;. After running the above command, we see that there is now an &lt;code>ovsdb-server&lt;/code> instance listening on port 6642:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ss -tlnp | grep 6642
LISTEN 0 10 0.0.0.0:6642 0.0.0.0:* users:((&amp;#34;ovsdb-server&amp;#34;,pid=1798,fd=21))
&lt;/code>&lt;/pre>&lt;h2 id="connecting-nodes-to-the-controller">Connecting nodes to the controller&lt;/h2>
&lt;p>Now that we have our controller configured, we have to connect the &lt;code>ovn-controller&lt;/code> service on our nodes to the Southbound database. We do this by creating several entries in the &lt;code>external_ids&lt;/code> column of the OVS &lt;code>open_vswitch&lt;/code> database on each host:&lt;/p>
&lt;ul>
&lt;li>&lt;code>ovn-remote&lt;/code> &amp;ndash; this is the address of the controller&lt;/li>
&lt;li>&lt;code>ovn-encap-ip&lt;/code> &amp;ndash; this is the local address that will be used for tunnel endpoints&lt;/li>
&lt;li>&lt;code>ovn-encap-type&lt;/code> &amp;ndash; the encapsulation mechanism to use for tunnels&lt;/li>
&lt;li>&lt;code>system-id&lt;/code> &amp;ndash; a unique identifier for the local host&lt;/li>
&lt;/ul>
&lt;p>On all nodes, run the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl set open_vswitch . \
external_ids:ovn-remote=tcp:192.168.122.100:6642 \
external_ids:ovn-encap-ip=$(ip addr show eth0 | awk &amp;#39;$1 == &amp;#34;inet&amp;#34; {print $2}&amp;#39; | cut -f1 -d/) \
external_ids:ovn-encap-type=geneve \
external_ids:system-id=$(hostname)
&lt;/code>&lt;/pre>&lt;p>This points &lt;code>ovn-remote&lt;/code> at the address of the controller, sets &lt;code>ovn-encap-ip&lt;/code> to the address of &lt;code>eth0&lt;/code> on the local host, sets &lt;code>systemd-id&lt;/code> to the local hostname, and selects &lt;a href="https://tools.ietf.org/html/draft-ietf-nvo3-geneve-08">geneve&lt;/a> encapsulation for tunnels (see &lt;a href="https://blog.russellbryant.net/2017/05/30/ovn-geneve-vs-vxlan-does-it-matter/">this post&lt;/a> for information on why OVN prefers Geneve encapsulation).&lt;/p>
&lt;p>We can verify these settings by using the &lt;code>ovs-vsctl list&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ovs-vsctl --columns external_ids list open_vswitch
external_ids : {hostname=&amp;#34;ovn1.virt&amp;#34;, ovn-encap-ip=&amp;#34;192.168.122.101&amp;#34;, ovn-encap-type=geneve, ovn-remote=&amp;#34;192.168.122.100&amp;#34;, rundir=&amp;#34;/var/run/openvswitch&amp;#34;, system-id=&amp;#34;ovn1&amp;#34;}
&lt;/code>&lt;/pre>&lt;p>After running the above commands, each node should now have tunnels interfaces connecting to the other nodes in the test environment. For example, running &lt;code>ovs-vsctl show&lt;/code> on node &lt;code>ovn1&lt;/code> looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>f0087676-7f93-419c-9da0-32321d2d3668
Bridge br-int
fail_mode: secure
Port &amp;#34;ovn-ovn0-0&amp;#34;
Interface &amp;#34;ovn-ovn0-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.100&amp;#34;}
Port br-int
Interface br-int
type: internal
Port &amp;#34;ovn-ovn2-0&amp;#34;
Interface &amp;#34;ovn-ovn2-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.102&amp;#34;}
ovs_version: &amp;#34;2.12.0&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Due to what appears to be &lt;a href="https://mail.openvswitch.org/pipermail/ovs-discuss/2020-January/049692.html">some sort of race condition in OVN&lt;/a>, you may not see the geneve tunnels in the &lt;code>ovs-vsctl show&lt;/code> output. If this is the case, restart &lt;code>ovn-controller&lt;/code> on all your ovn nodes:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl restart ovn-controller
&lt;/code>&lt;/pre>&lt;p>The issue with the geneve tunnels appears to be resolved by &lt;a href="https://patchwork.ozlabs.org/patch/1222380/">this patch&lt;/a>, which will hopefully land in OVN in the near future.&lt;/p>
&lt;h1 id="creating-a-virtual-network">Creating a virtual network&lt;/h1>
&lt;p>Now that we have a functioning OVN environment, we&amp;rsquo;re ready to create our virtual network.&lt;/p>
&lt;h2 id="create-a-logical-switch">Create a logical switch&lt;/h2>
&lt;p>We&amp;rsquo;ll start by creating a logical switch, which we will call &lt;code>net0&lt;/code>. We create that using the &lt;code>ovn-nbctl ls-add&lt;/code> command. Run the following on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl ls-add net0
&lt;/code>&lt;/pre>&lt;p>After running the above command, the output of &lt;code>ovn-nbctl show&lt;/code> will look something like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-nbctl show
switch d8d96fb2-e1e7-469d-8c72-b7e891fb16ba (net0)
&lt;/code>&lt;/pre>&lt;p>Next, we need to set some configuration options on the switch that will be used to set the range from which we allocate addresses via DHCP. We&amp;rsquo;re going to have OVN manage the &lt;code>10.0.0.0/24&lt;/code> network, which means we need to set &lt;code>other_config:subnet&lt;/code> to &lt;code>10.0.0.0/24&lt;/code>. I generally like to reserve some addresses from the DHCP range to use for static allocations, so I have also set &lt;code>other_config:exclude_ips&lt;/code> to &lt;code>10.0.0.1..10.0.0.10&lt;/code>. This means that DHCP allocations will come from the range &lt;code>10.0.0.11&lt;/code> - &lt;code>10.0.0.254&lt;/code>.&lt;/p>
&lt;p>To apply these settings, run the following commands on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl set logical_switch net0 \
other_config:subnet=&amp;#34;10.0.0.0/24&amp;#34; \
other_config:exclude_ips=&amp;#34;10.0.0.1..10.0.0.10&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="create-dhcp-options">Create DHCP options&lt;/h2>
&lt;p>Each port that we want to configure using DHCP needs to be associated with a set of DHCP options. We accomplish this by creating a new entry in the Northbound &lt;code>dhcp_options&lt;/code> table, and then set the &lt;code>dhcp_options&lt;/code> column of the port to the id of the object we created in the &lt;code>dhcp_options&lt;/code> table.&lt;/p>
&lt;p>Looking at &lt;a href="https://github.com/ovn-org/ovn/blob/master/northd/ovn-northd.c#L4113">the source&lt;/a>, there are three required options that must be set in order for DHCP to operate:&lt;/p>
&lt;ul>
&lt;li>&lt;code>server_id&lt;/code> &amp;ndash; the ip address of the virtual dhcp server&lt;/li>
&lt;li>&lt;code>server_mac&lt;/code> &amp;ndash; the MAC address of the virtual dhcp server&lt;/li>
&lt;li>&lt;code>lease_time&lt;/code> &amp;ndash; the lifetime of DHCP leases&lt;/li>
&lt;/ul>
&lt;p>While not actually required, we can also set the &lt;code>router&lt;/code> key to provide information about the default gateway. We&amp;rsquo;re not going to make use of it in this example, but in practice you will probably want to set the &lt;code>router&lt;/code> option.&lt;/p>
&lt;p>We also need to set the CIDR range that will be served by the DHCP server.&lt;/p>
&lt;p>We can create the appropriate options using the &lt;code>ovn-nbctl dhcp-options-create&lt;/code> command. Run the following on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl dhcp-options-create 10.0.0.0/24
&lt;/code>&lt;/pre>&lt;p>Despite the name of that command, it doesn&amp;rsquo;t actually let us set DHCP options. For that, we need to first look up the uuid of our newly created entry in the &lt;code>dhcp_options&lt;/code> table. Let&amp;rsquo;s store that in the &lt;code>CIDR_UUID&lt;/code> variable, which we will use in a few places in the remainder of this post:&lt;/p>
&lt;pre tabindex="0">&lt;code>CIDR_UUID=$(ovn-nbctl --bare --columns=_uuid find dhcp_options cidr=&amp;#34;10.0.0.0/24&amp;#34;)
&lt;/code>&lt;/pre>&lt;p>With that uuid in hand, we can now set the required options:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl dhcp-options-set-options ${CIDR_UUID} \
lease_time=3600 \
router=10.0.0.1 \
server_id=10.0.0.1 \
server_mac=c0:ff:ee:00:00:01
&lt;/code>&lt;/pre>&lt;p>We can use the database &lt;code>list&lt;/code> command to inspect the &lt;code>dhcp_options&lt;/code> table to verify that things look as we expect:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-nbctl list dhcp_options
_uuid : f8a6abc5-b8e4-4209-8809-b95435b4d48b
cidr : &amp;#34;10.0.0.0/24&amp;#34;
external_ids : {lease_time=&amp;#34;3600&amp;#34;, router=&amp;#34;10.0.0.1&amp;#34;, server_id=&amp;#34;10.0.0.1&amp;#34;, server_mac=&amp;#34;c0:ff:ee:00:00:01&amp;#34;}
options : {}
&lt;/code>&lt;/pre>&lt;p>Instead of using the &lt;code>dhcp-options-create&lt;/code> command, as we did in this section, we could instead have used the database &lt;code>create&lt;/code> command. The quoting requirements for that command are a little more complex, but unlike the &lt;code>dhcp-options-create&lt;/code> command the &lt;code>create&lt;/code> command returns the id of the row it creates. This can be useful if you&amp;rsquo;re using the command as part of a script. The equivalent &lt;code>create&lt;/code> command would look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>CIDR_UUID=$(ovn-nbctl create dhcp_options \
cidr=10.0.0.0/24 \
options=&amp;#39;&amp;#34;lease_time&amp;#34;=&amp;#34;3600&amp;#34; &amp;#34;router&amp;#34;=&amp;#34;10.0.0.1&amp;#34; &amp;#34;server_id&amp;#34;=&amp;#34;10.0.0.1&amp;#34; &amp;#34;server_mac&amp;#34;=&amp;#34;c0:ff:ee:00:00:01&amp;#34;&amp;#39;)
&lt;/code>&lt;/pre>&lt;h2 id="create-logical-ports">Create logical ports&lt;/h2>
&lt;p>Let&amp;rsquo;s add the following three logical ports to the switch:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>MAC Address&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>port1&lt;/td>
&lt;td>c0:ff:ee:00:00:11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port2&lt;/td>
&lt;td>c0:ff:ee:00:00:12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port3&lt;/td>
&lt;td>c0:ff:ee:00:00:13&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>For each port, we&amp;rsquo;ll need to run three commands. First, we create the port on the switch:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-add net0 port1
&lt;/code>&lt;/pre>&lt;p>Next, we set the port addresses. For this example, I&amp;rsquo;m using static MAC addresses and dynamic (assigned by DHCP) IP addresses, so the command will look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-set-addresses port1 &amp;#34;c0:ff:ee:00:00:11 dynamic&amp;#34;
&lt;/code>&lt;/pre>&lt;p>If you want OVN to set MAC addresses for the ports as well, you would instead run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-set-addresses port1 &amp;#34;dynamic&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Finally, we associate the port with the DHCP options we created in the previous section:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-set-dhcpv4-options port1 $CIDR_UUID
&lt;/code>&lt;/pre>&lt;p>Repeat the above sequence for &lt;code>port2&lt;/code> and &lt;code>port3&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-add net0 port2
ovn-nbctl lsp-set-addresses port2 &amp;#34;c0:ff:ee:00:00:12 dynamic&amp;#34;
ovn-nbctl lsp-set-dhcpv4-options port2 $CIDR_UUID
ovn-nbctl lsp-add net0 port3
ovn-nbctl lsp-set-addresses port3 &amp;#34;c0:ff:ee:00:00:13 dynamic&amp;#34;
ovn-nbctl lsp-set-dhcpv4-options port3 $CIDR_UUID
&lt;/code>&lt;/pre>&lt;p>When you&amp;rsquo;re done, &lt;code>ovn-nbctl show&lt;/code> should return output similar to the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>switch 3c03342f-f762-410b-9f4e-572d266c8ff7 (net0)
port port2
addresses: [&amp;#34;c0:ff:ee:00:00:12 dynamic&amp;#34;]
port port3
addresses: [&amp;#34;c0:ff:ee:00:00:13 dynamic&amp;#34;]
port port1
addresses: [&amp;#34;c0:ff:ee:00:00:11 dynamic&amp;#34;]
&lt;/code>&lt;/pre>&lt;p>We can see additional details using the database command &lt;code>ovn-nbctl list logical_switch_port&lt;/code>. The entry for &lt;code>port1&lt;/code> might look like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>_uuid : 8ad6a4c0-4c7b-4817-bf13-8e7b1a86bab1
addresses : [&amp;#34;c0:ff:ee:00:00:11 dynamic&amp;#34;]
dhcpv4_options : f8a6abc5-b8e4-4209-8809-b95435b4d48b
dhcpv6_options : []
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:11 10.0.0.11&amp;#34;
enabled : []
external_ids : {}
ha_chassis_group : []
name : port1
options : {}
parent_name : []
port_security : []
tag : []
tag_request : []
type : &amp;#34;&amp;#34;
up : false
&lt;/code>&lt;/pre>&lt;p>Looking at the &lt;code>dynamic_addresses&lt;/code> column we can see that &lt;code>port1&lt;/code> has been assigned the ip address &lt;code>10.0.0.11&lt;/code>. We can see the assigned addresses for all of our ports like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-nbctl --columns dynamic_addresses list logical_switch_port
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:13 10.0.0.13&amp;#34;
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:11 10.0.0.11&amp;#34;
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:12 10.0.0.12&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="simulating-a-dhcp-request-with-ovn-trace">Simulating a DHCP request with ovn-trace&lt;/h2>
&lt;p>At this point, we have a functioning switch, although we haven&amp;rsquo;t actually realized the ports anywhere yet. This is the perfect time to introduce the &lt;code>ovn-trace&lt;/code> tool, which can be used to simulate how your OVN network will handle a packet of data.&lt;/p>
&lt;p>We can show how OVN will respond to a DHCP &lt;code>DISCOVER&lt;/code> message with the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-trace --summary net0 &amp;#39;
inport==&amp;#34;port1&amp;#34; &amp;amp;&amp;amp;
eth.src==c0:ff:ee:00:00:11 &amp;amp;&amp;amp;
ip4.src==0.0.0.0 &amp;amp;&amp;amp;
ip.ttl==1 &amp;amp;&amp;amp;
ip4.dst==255.255.255.255 &amp;amp;&amp;amp;
udp.src==68 &amp;amp;&amp;amp;
udp.dst==67&amp;#39;
&lt;/code>&lt;/pre>&lt;p>The above command simulates a packet originating on &lt;code>port1&lt;/code> with the appropriate MAC address (&lt;code>eth.src&lt;/code>, &lt;code>c0:ff:ee:00:00:11&lt;/code>) and a source address (&lt;code>ip4.src&lt;/code>) of &lt;code>0.0.0.0&lt;/code> (port 68 (&lt;code>udp.src&lt;/code>)), targeting (&lt;code>ip4.dst&lt;/code>) the broadcast address &lt;code>255.255.255.255&lt;/code> (port 67 (&lt;code>udp.dst&lt;/code>)).&lt;/p>
&lt;p>Assuming everything is functioning correctly, this should produce the following output:&lt;/p>
&lt;pre tabindex="0">&lt;code># udp,reg14=0x2,vlan_tci=0x0000,dl_src=c0:ff:ee:00:00:11,dl_dst=c0:ff:ee:00:00:01,nw_src=0.0.0.0,nw_dst=255.255.255.255,nw_tos=0,nw_ecn=0,nw_ttl=1,tp_src=68,tp_dst=67
ingress(dp=&amp;#34;net0&amp;#34;, inport=&amp;#34;port1&amp;#34;) {
next;
reg0[3] = put_dhcp_opts(offerip = 10.0.0.11, lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1);
/* We assume that this packet is DHCPDISCOVER or DHCPREQUEST. */;
next;
eth.dst = eth.src;
eth.src = c0:ff:ee:00:00:01;
ip4.dst = 10.0.0.11;
ip4.src = 10.0.0.1;
udp.src = 67;
udp.dst = 68;
outport = inport;
flags.loopback = 1;
output;
egress(dp=&amp;#34;net0&amp;#34;, inport=&amp;#34;port1&amp;#34;, outport=&amp;#34;port1&amp;#34;) {
next;
output;
/* output to &amp;#34;port1&amp;#34;, type &amp;#34;&amp;#34; */;
};
};
&lt;/code>&lt;/pre>&lt;p>In the above output, you can see that OVN is filling in the details of the DHCP lease (that&amp;rsquo;s the &lt;code>put_dhcp_options&lt;/code> command), and then sending the packet back out &lt;code>port1&lt;/code> with the ethernet source and destination addresses reversed (so that the destination address is now the MAC address of &lt;code>port1&lt;/code>).&lt;/p>
&lt;p>It looks like everything is working in theory. Let&amp;rsquo;s attach some actual network interfaces and see what happens!&lt;/p>
&lt;h1 id="attaching-network-interfaces">Attaching network interfaces&lt;/h1>
&lt;p>In this section, we will attach network interfaces to our logical switch and demonstrate that they can be properly configured using DHCP.&lt;/p>
&lt;h2 id="create-an-ovs-port">Create an OVS port&lt;/h2>
&lt;p>On host &lt;code>ovn1&lt;/code>, let&amp;rsquo;s create port &lt;code>port1&lt;/code>. We&amp;rsquo;ll want to ensure that (a) the MAC address of this port matches the MAC address we configured earlier (&lt;code>c0:ff:ee:00:00:11&lt;/code>), and we need to make sure that the &lt;code>iface-id&lt;/code> external id matches the port name we registered in the Northbound database. We can do that with the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br-int port1 -- \
set interface port1 \
type=internal \
mac=&amp;#39;[&amp;#34;c0:ff:ee:00:00:11&amp;#34;]&amp;#39; \
external_ids:iface-id=port1
&lt;/code>&lt;/pre>&lt;p>After running this command, running &lt;code>ovs-vsctl show&lt;/code> on &lt;code>ovn1&lt;/code> should produce:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ovs-vsctl show
f359ad7a-5fcd-49b3-8557-e61be3a0b130
Bridge br-int
fail_mode: secure
Port br-int
Interface br-int
type: internal
Port &amp;#34;port1&amp;#34;
Interface &amp;#34;port1&amp;#34;
type: internal
Port &amp;#34;ovn-ovn2-0&amp;#34;
Interface &amp;#34;ovn-ovn2-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.102&amp;#34;}
Port &amp;#34;ovn-ovn0-0&amp;#34;
Interface &amp;#34;ovn-ovn0-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.100&amp;#34;}
ovs_version: &amp;#34;2.12.0&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Furthermore, OVN should also be aware of this port. If we run &lt;code>ovn-sbctl show&lt;/code> on &lt;code>ovn0&lt;/code>, we see a binding for host &lt;code>ovn1&lt;/code> (look for the &lt;code>Port_Binding port1&lt;/code> line under &lt;code>Chassis ovn1&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-sbctl show
Chassis ovn0
hostname: ovn0.virt
Encap geneve
ip: &amp;#34;192.168.122.100&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Chassis ovn1
hostname: ovn1.virt
Encap geneve
ip: &amp;#34;192.168.122.101&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port1
Chassis ovn2
hostname: ovn2.virt
Encap geneve
ip: &amp;#34;192.168.122.102&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
&lt;/code>&lt;/pre>&lt;h2 id="configure-the-port-using-dhcp">Configure the port using DHCP&lt;/h2>
&lt;p>We can now try to configure this interface with DHCP. Let&amp;rsquo;s first move the interface into a network namespace; this means we don&amp;rsquo;t need to worry about messing up routing on the host. We&amp;rsquo;ll create a namespace named &lt;code>vm1&lt;/code> and make &lt;code>port1&lt;/code> part of that namespace:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns add vm1
ip link set netns vm1 port1
ip -n vm1 addr add 127.0.0.1/8 dev lo
ip -n vm1 link set lo up
&lt;/code>&lt;/pre>&lt;p>We can now configure the interface using DHCP by running the &lt;code>dhclient&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns exec vm1 dhclient -v -i port1 --no-pid
&lt;/code>&lt;/pre>&lt;p>After &lt;code>dhclient&lt;/code> goes to the background, we see that it was able to successfully request an address:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ip netns exec vm1 dhclient -v -i port1 --no-pid
Internet Systems Consortium DHCP Client 4.4.1
Copyright 2004-2018 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
Listening on LPF/port1/c0:ff:ee:00:00:11
Sending on LPF/port1/c0:ff:ee:00:00:11
Sending on Socket/fallback
Created duid &amp;#34;\000\004\344J\012\236\007\033AF\261\354\246\273\206\011\226g&amp;#34;.
DHCPDISCOVER on port1 to 255.255.255.255 port 67 interval 7 (xid=0xffc0820a)
DHCPOFFER of 10.0.0.11 from 10.0.0.1
DHCPREQUEST for 10.0.0.11 on port1 to 255.255.255.255 port 67 (xid=0xffc0820a)
DHCPACK of 10.0.0.11 from 10.0.0.1 (xid=0xffc0820a)
bound to 10.0.0.11 -- renewal in 1378 seconds.
&lt;/code>&lt;/pre>&lt;p>And it has correctly configured the interface:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ip netns exec vm1 ip addr show port1
6: port1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
link/ether c0:ff:ee:00:00:11 brd ff:ff:ff:ff:ff:ff
inet 10.0.0.11/24 brd 10.0.0.255 scope global dynamic port1
valid_lft 577sec preferred_lft 577sec
inet6 fe80::c2ff:eeff:fe00:11/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;h2 id="configuring-port2-on-ovn1">Configuring port2 on ovn1&lt;/h2>
&lt;p>Let&amp;rsquo;s repeat the above process with &lt;code>port2&lt;/code>, again using host &lt;code>ovn1&lt;/code>. First we add the port:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br-int port2 -- \
set interface port2 \
type=internal \
mac=&amp;#39;[&amp;#34;c0:ff:ee:00:00:12&amp;#34;]&amp;#39; \
external_ids:iface-id=port2
&lt;/code>&lt;/pre>&lt;p>Add it to a namespace:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns add vm2
ip link set netns vm2 port2
ip -n vm2 addr add 127.0.0.1/8 dev lo
ip -n vm2 link set lo up
&lt;/code>&lt;/pre>&lt;p>Configure it using &lt;code>dhclient&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns exec vm2 dhclient -v -i port2 --no-pid
&lt;/code>&lt;/pre>&lt;p>And finally look at the OVN port bindings on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-sbctl show
Chassis ovn1
hostname: ovn1.virt
Encap geneve
ip: &amp;#34;192.168.122.101&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port2
Port_Binding port1
Chassis ovn0
hostname: ovn0.virt
Encap geneve
ip: &amp;#34;192.168.122.100&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Chassis ovn2
hostname: ovn2.virt
Encap geneve
ip: &amp;#34;192.168.122.102&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
&lt;/code>&lt;/pre>&lt;h2 id="configuring-port3-on-ovn2">Configuring port3 on ovn2&lt;/h2>
&lt;p>Lastly, let&amp;rsquo;s repeat the above process for &lt;code>port3&lt;/code> on host &lt;code>ovn2&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br-int port3 -- \
set interface port3 \
type=internal \
mac=&amp;#39;[&amp;#34;c0:ff:ee:00:00:13&amp;#34;]&amp;#39; \
external_ids:iface-id=port3
ip netns add vm3
ip link set netns vm3 port3
ip -n vm3 addr add 127.0.0.1/8 dev lo
ip -n vm3 link set lo up
ip netns exec vm3 dhclient -v -i port3 --no-pid
&lt;/code>&lt;/pre>&lt;p>When we&amp;rsquo;re done, &lt;code>ovn-sbctl show&lt;/code> looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-sbctl show
Chassis ovn1
hostname: ovn1.virt
Encap geneve
ip: &amp;#34;192.168.122.101&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port2
Port_Binding port1
Chassis ovn0
hostname: ovn0.virt
Encap geneve
ip: &amp;#34;192.168.122.100&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Chassis ovn2
hostname: ovn2.virt
Encap geneve
ip: &amp;#34;192.168.122.102&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port3
&lt;/code>&lt;/pre>&lt;h2 id="verify-connectivity">Verify connectivity&lt;/h2>
&lt;p>We can verify that the network namespaces we&amp;rsquo;ve created in the above examples are able to communicate with each other regardless of the host on which they have been created. For example, if we log into &lt;code>ovn2&lt;/code> we can show that we are able to reach the address of &lt;code>port1&lt;/code> (&lt;code>10.0.0.11&lt;/code>) from &lt;code>port3&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn2 ~]# ip netns exec vm3 ping -c1 10.0.0.11
PING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.
64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=0.266 ms
--- 10.0.0.11 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.266/0.266/0.266/0.000 ms
&lt;/code>&lt;/pre>&lt;h1 id="thats-all-folks">That&amp;rsquo;s all folks!&lt;/h1>
&lt;p>I hope this post helps you understand how to set up a simple OVN environment with DHCP. Please feel free to leave comments and questions!&lt;/p>
&lt;h2 id="thanks-to">Thanks to&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/LorenzoBianconi">Lorenzo Bianconi&lt;/a> for helping sort this out over email.&lt;/li>
&lt;li>&lt;a href="https://twitter.com/zhouhanok">Han Zhou&lt;/a> for helping solve the issue around Geneve tunnels coming up appropriately.&lt;/li>
&lt;/ul>
&lt;h2 id="see-also">See also&lt;/h2>
&lt;p>Below are some of the resources to which I referred while figuring out how to put this all together:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developers.redhat.com/blog/2018/09/03/ovn-dynamic-ip-address-management/">Dynamic IP address management in Open Virtual Network (OVN): Part One&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developers.redhat.com/blog/2018/09/27/dynamic-ip-address-management-in-open-virtual-network-ovn-part-two/">Dynamic IP address management in Open Virtual Network (OVN): Part Two&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qyx.me/2018/07/10/run-and-test-ovn/">Run Open Virtual Network (OVN) in Ubuntu&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://dani.foroselectronica.es/simple-ovn-setup-in-5-minutes-491/">Simple OVN setup in 5 minutes&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Configuring a static address for wlan0 on Raspbian Stretch</title><link>https://blog.oddbit.com/post/2018-06-14-configuring-a-static-address-f/</link><pubDate>Thu, 14 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-06-14-configuring-a-static-address-f/</guid><description>&lt;p>Recent releases of Raspbian have adopted the use of &lt;a href="http://manpages.ubuntu.com/manpages/trusty/man8/dhcpcd5.8.html">dhcpcd&lt;/a> to
manage both dynamic and static interface configuration. If you would
prefer to use the traditional &lt;code>/etc/network/interfaces&lt;/code> mechanism
instead, follow these steps.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>First, disable &lt;code>dhcpcd&lt;/code> and &lt;code>wpa_supplicant&lt;/code>.&lt;/p>
&lt;pre>&lt;code> systemctl disable --now dhdpcd wpa_supplicant
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>You will need a &lt;code>wpa_supplicant&lt;/code> configuration for &lt;code>wlan0&lt;/code> in
&lt;code>/etc/wpa_supplicant/wpa_supplicant-wlan0.conf&lt;/code>.&lt;/p>
&lt;p>If you already have an appropriate configuration in
&lt;code>/etc/wpa_supplicant/wpa_supplicant.conf&lt;/code>, you can just symlink the
file:&lt;/p>
&lt;pre>&lt;code> cd /etc/wpa_supplicant
ln -s wpa_supplicant.conf wpa_supplicant-wlan0.conf
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Enable the &lt;code>wpa_supplicant&lt;/code> service for &lt;code>wlan0&lt;/code>:&lt;/p></description><content>&lt;p>Recent releases of Raspbian have adopted the use of &lt;a href="http://manpages.ubuntu.com/manpages/trusty/man8/dhcpcd5.8.html">dhcpcd&lt;/a> to
manage both dynamic and static interface configuration. If you would
prefer to use the traditional &lt;code>/etc/network/interfaces&lt;/code> mechanism
instead, follow these steps.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>First, disable &lt;code>dhcpcd&lt;/code> and &lt;code>wpa_supplicant&lt;/code>.&lt;/p>
&lt;pre>&lt;code> systemctl disable --now dhdpcd wpa_supplicant
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>You will need a &lt;code>wpa_supplicant&lt;/code> configuration for &lt;code>wlan0&lt;/code> in
&lt;code>/etc/wpa_supplicant/wpa_supplicant-wlan0.conf&lt;/code>.&lt;/p>
&lt;p>If you already have an appropriate configuration in
&lt;code>/etc/wpa_supplicant/wpa_supplicant.conf&lt;/code>, you can just symlink the
file:&lt;/p>
&lt;pre>&lt;code> cd /etc/wpa_supplicant
ln -s wpa_supplicant.conf wpa_supplicant-wlan0.conf
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Enable the &lt;code>wpa_supplicant&lt;/code> service for &lt;code>wlan0&lt;/code>:&lt;/p>
&lt;pre>&lt;code> systemctl enable --now wpa_supplicant@wlan0
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Create an appropriate configuration in
&lt;code>/etc/network/interfaces.d/wlan0&lt;/code>. For example:&lt;/p>
&lt;pre>&lt;code> allow-hotplug wlan0
iface wlan0 inet static
address 192.168.2.100
netmask 255.255.255.0
iface wlan0 inet6 static
address 2607:f0d0:2001:000a:0000:0000:0000:0010
netmask 64
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Reboot to make sure everything comes up as expected. With the
above configuration, after rebooting you should see:&lt;/p>
&lt;pre>&lt;code> root@raspberrypi:~# ip addr show wlan0
3: wlan0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc mq state UP group default qlen 1000
link/ether 00:e1:b0:67:98:67 brd ff:ff:ff:ff:ff:ff
inet 192.168.2.100/24 brd 192.168.2.255 scope global wlan0
valid_lft forever preferred_lft forever
inet6 2607:f0d0:2001:a::10/64 scope global
valid_lft forever preferred_lft forever
inet6 fe80::2e1:b0ff:fe67:9867/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol></content></item><item><title>Using Docker macvlan networks</title><link>https://blog.oddbit.com/post/2018-03-12-using-docker-macvlan-networks/</link><pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-03-12-using-docker-macvlan-networks/</guid><description>&lt;p>A question that crops up regularly on &lt;a href="https://docs.docker.com/opensource/ways/#docker-users">#docker&lt;/a> is &amp;ldquo;How do I attach
a container directly to my local network?&amp;rdquo; One possible answer to that
question is the &lt;a href="https://docs.docker.com/network/macvlan/">macvlan&lt;/a> network type, which lets you create
&amp;ldquo;clones&amp;rdquo; of a physical interface on your host and use that to attach
containers directly to your local network. For the most part it works
great, but it does come with some minor caveats and limitations. I
would like to explore those here.&lt;/p></description><content>&lt;p>A question that crops up regularly on &lt;a href="https://docs.docker.com/opensource/ways/#docker-users">#docker&lt;/a> is &amp;ldquo;How do I attach
a container directly to my local network?&amp;rdquo; One possible answer to that
question is the &lt;a href="https://docs.docker.com/network/macvlan/">macvlan&lt;/a> network type, which lets you create
&amp;ldquo;clones&amp;rdquo; of a physical interface on your host and use that to attach
containers directly to your local network. For the most part it works
great, but it does come with some minor caveats and limitations. I
would like to explore those here.&lt;/p>
&lt;p>For the purpose of this example, let&amp;rsquo;s say we have a host interface
&lt;code>eno1&lt;/code> that looks like this:&lt;/p>
&lt;pre>&lt;code>2: eno1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
link/ether 64:00:6a:7d:06:1a brd ff:ff:ff:ff:ff:ff
inet 192.168.1.24/24 brd 192.168.1.255 scope global dynamic eno1
valid_lft 73303sec preferred_lft 73303sec
inet6 fe80::b2c9:3793:303:2a55/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>To create a macvlan network named &lt;code>mynet&lt;/code> attached to that interface,
you might run something like this:&lt;/p>
&lt;pre>&lt;code>docker network create -d macvlan -o parent=eno1 \
--subnet 192.168.1.0/24 \
--gateway 192.168.1.1 \
mynet
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;but don&amp;rsquo;t do that.&lt;/p>
&lt;h2 id="address-assignment">Address assignment&lt;/h2>
&lt;p>When you create a container attached to your macvlan network, Docker
will select an address from the subnet range and assign it to your
container. This leads to the potential for conflicts: if Docker picks
an address that has already been assigned to another host on your
network, you have a problem!&lt;/p>
&lt;p>You can avoid this by reserving a portion of the subnet range for use
by Docker. There are two parts to this solution:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>You must configure any DHCP service on your network such that it
will not assign addresses in a given range.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You must tell Docker about that reserved range of addresses.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>How you accomplish the former depends entirely on your local network
infrastructure and is beyond the scope of this document. The latter
task is accomplished with the &lt;code>--ip-range&lt;/code> option to &lt;code>docker network create&lt;/code>.&lt;/p>
&lt;p>On my local network, my DHCP server will not assign any addresses
above &lt;code>192.168.1.190&lt;/code>. I have decided to assign to Docker the subset
&lt;code>192.168.1.192/27&lt;/code>, which is a range of 32 address starting at
192.168.1.192 and ending at 192.168.1.223. The corresponding &lt;code>docker network create&lt;/code> command would be:&lt;/p>
&lt;pre>&lt;code>docker network create -d macvlan -o parent=eno1 \
--subnet 192.168.1.0/24 \
--gateway 192.168.1.1 \
--ip-range 192.168.1.192/27 \
mynet
&lt;/code>&lt;/pre>
&lt;p>Now it is possible to create containers attached to my local network
without worrying about the possibility of ip address conflicts.&lt;/p>
&lt;h2 id="host-access">Host access&lt;/h2>
&lt;p>With a container attached to a macvlan network, you will find that
while it can contact other systems on your local network without a
problem, the container will not be able to connect to your host (and
your host will not be able to connect to your container). This is a
limitation of macvlan interfaces: without special support from a
network switch, your host is unable to send packets to its own macvlan
interfaces.&lt;/p>
&lt;p>Fortunately, there is a workaround for this problem: you can create
another macvlan interface on your host, and use that to communicate
with containers on the macvlan network.&lt;/p>
&lt;p>First, I&amp;rsquo;m going to reserve an address from our network range for use
by the host interface by using the &lt;code>--aux-address&lt;/code> option to &lt;code>docker network create&lt;/code>. That makes our final command line look like:&lt;/p>
&lt;pre>&lt;code>docker network create -d macvlan -o parent=eno1 \
--subnet 192.168.1.0/24 \
--gateway 192.168.1.1 \
--ip-range 192.168.1.192/27 \
--aux-address 'host=192.168.1.223' \
mynet
&lt;/code>&lt;/pre>
&lt;p>This will prevent Docker from assigning that address to a container.&lt;/p>
&lt;p>Next, we create a new macvlan interface on the host. You can call it
whatever you want, but I&amp;rsquo;m calling this one &lt;code>mynet-shim&lt;/code>:&lt;/p>
&lt;pre>&lt;code>ip link add mynet-shim link eno1 type macvlan mode bridge
&lt;/code>&lt;/pre>
&lt;p>Now we need to configure the interface with the address we reserved
and bring it up:&lt;/p>
&lt;pre>&lt;code>ip addr add 192.168.1.223/32 dev mynet-shim
ip link set mynet-shim up
&lt;/code>&lt;/pre>
&lt;p>The last thing we need to do is to tell our host to use that interface
when communicating with the containers. This is relatively easy
because we have restricted our containers to a particular CIDR subset
of the local network; we just add a route to that range like this:&lt;/p>
&lt;pre>&lt;code>ip route add 192.168.1.192/27 dev mynet-shim
&lt;/code>&lt;/pre>
&lt;p>With that route in place, your host will automatically use ths
&lt;code>mynet-shim&lt;/code> interface when communicating with containers on the
&lt;code>mynet&lt;/code> network.&lt;/p>
&lt;p>Note that the interface and routing configuration presented here is
not persistent &amp;ndash; you will lose if if you were to reboot your host.
How to make it persistent is distribution dependent.&lt;/p></content></item><item><title>Listening for connections on all ports/any port</title><link>https://blog.oddbit.com/post/2018-02-27-listening-for-connections-on-a/</link><pubDate>Tue, 27 Feb 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-02-27-listening-for-connections-on-a/</guid><description>&lt;p>On &lt;a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC&lt;/a> &amp;ndash; and other online communities &amp;ndash; it is common to use a
&amp;ldquo;pastebin&amp;rdquo; service to share snippets of code, logs, and other
material, rather than pasting them directly into a conversation.
These services will typically return a URL that you can share with
others so that they can see the content in their browser.&lt;/p>
&lt;p>One of my favorite pastebin services is &lt;a href="http://termbin.com">termbin.com&lt;/a>, because it
works from the command line using tools you probably already have
installed. Termbin runs the &lt;a href="https://github.com/solusipse/fiche">fiche&lt;/a> service, which listens for TCP
connections on port 9999, reads any content that you provide, and then
returns a URL. For example, if I wanted to share my &lt;code>iptables&lt;/code>
configuration with someone I could just run:&lt;/p></description><content>&lt;p>On &lt;a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC&lt;/a> &amp;ndash; and other online communities &amp;ndash; it is common to use a
&amp;ldquo;pastebin&amp;rdquo; service to share snippets of code, logs, and other
material, rather than pasting them directly into a conversation.
These services will typically return a URL that you can share with
others so that they can see the content in their browser.&lt;/p>
&lt;p>One of my favorite pastebin services is &lt;a href="http://termbin.com">termbin.com&lt;/a>, because it
works from the command line using tools you probably already have
installed. Termbin runs the &lt;a href="https://github.com/solusipse/fiche">fiche&lt;/a> service, which listens for TCP
connections on port 9999, reads any content that you provide, and then
returns a URL. For example, if I wanted to share my &lt;code>iptables&lt;/code>
configuration with someone I could just run:&lt;/p>
&lt;pre>&lt;code>$ iptables-save | nc termbin.com 9999
http://termbin.com/gjfp
&lt;/code>&lt;/pre>
&lt;p>Visiting &lt;a href="http://termbin.com/gjfp">http://termbin.com/gjfp&lt;/a> would show the output of that
command.&lt;/p>
&lt;p>It&amp;rsquo;s very convenient, but I found myself wondering: would it be
possible to configure things such that a service like &lt;a href="https://github.com/solusipse/fiche">fiche&lt;/a>
could listen on &lt;em>any&lt;/em> port?&lt;/p>
&lt;p>I started by looking into &lt;a href="https://en.wikipedia.org/wiki/Network_socket#Raw_socket">raw sockets&lt;/a>, but that turned out to be a
terrible idea. The solution was actually much simpler: use an
iptables &lt;a href="http://ipset.netfilter.org/iptables-extensions.man.html#lbDM">REDIRECT&lt;/a> rule to take all traffic to a given ip address
and redirect it to the &lt;a href="https://github.com/solusipse/fiche">fiche&lt;/a> service. This requires that you have
a spare ip address to dedicate to this service, but it is otherwise
very easy.&lt;/p>
&lt;p>First, we start the &lt;a href="https://github.com/solusipse/fiche">fiche&lt;/a> service:&lt;/p>
&lt;pre>&lt;code>$ ./fiche
[Fiche][STATUS] Starting fiche on Tue Feb 27 11:53:01 2018...
[Fiche][STATUS] Domain set to: http://example.com.
[Fiche][STATUS] Server started listening on port: 9999.
============================================================
&lt;/code>&lt;/pre>
&lt;p>And we add an additional address to one of our network interfaces.
I&amp;rsquo;m adding &lt;code>192.168.1.250&lt;/code> to &lt;code>eth0&lt;/code> on my local system:&lt;/p>
&lt;pre>&lt;code>$ sudo ip addr add 192.168.1.250/32 dev eth0
&lt;/code>&lt;/pre>
&lt;p>Next, we create two firewall rules:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>One in the &lt;code>nat&lt;/code> &lt;code>PREROUTING&lt;/code> table, which will intercept traffic
from external systems:&lt;/p>
&lt;pre>&lt;code> $ sudo iptables -t nat -A PREROUTING -p tcp -d 192.168.1.250 -j REDIRECT --to-ports 9999
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>One in the &lt;code>nat&lt;/code> &lt;code>OUTPUT&lt;/code> table, which will intercept any locally
generated traffic:&lt;/p>
&lt;pre>&lt;code> $ sudo iptables -t nat -A OUTPUT -p tcp -d 192.168.1.250 -j REDIRECT --to-ports 9999
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>These two rules will intercept any traffic &amp;ndash; on &lt;em>any&lt;/em> port &amp;ndash; to
192.168.1.250 and redirect it to the &lt;a href="https://github.com/solusipse/fiche">fiche&lt;/a> service.&lt;/p>
&lt;p>For example, using no port (&lt;code>nc&lt;/code> on my system defaults to port &lt;code>0&lt;/code>):&lt;/p>
&lt;pre>&lt;code>$ echo hello | nc 192.168.1.250
http://example.com/tfka
&lt;/code>&lt;/pre>
&lt;p>And any other port works as well:&lt;/p>
&lt;pre>&lt;code>$ echo hello | nc 192.168.1.250 10
http://example.com/0j0c
$ echo hello | nc 192.168.1.250 80
http://example.com/u4fq
&lt;/code>&lt;/pre>
&lt;p>This solution will work with any TCP service. The service will need
to be listening on &lt;code>INADDR_ANY&lt;/code> (&lt;code>0.0.0.0&lt;/code>), because the &lt;code>REDIRECT&lt;/code>
rule rewrites the destination address to &amp;ldquo;the primary address of the
incoming interface&amp;rdquo;.&lt;/p></content></item><item><title>Provider external networks (in an appropriate amount of detail)</title><link>https://blog.oddbit.com/post/2015-08-13-provider-external-networks-det/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2015-08-13-provider-external-networks-det/</guid><description>&lt;p>In &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">Quantum in Too Much Detail&lt;/a>, I discussed the architecture of a
Neutron deployment in detail. Since that article was published,
Neutron gained the ability to handle multiple external networks with a
single L3 agent. While I &lt;a href="https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/">wrote about that&lt;/a> back in 2014, I
covered the configuration side of it in much more detail than I
discussed the underlying network architecture. This post addresses
the architecture side.&lt;/p>
&lt;h2 id="the-players">The players&lt;/h2>
&lt;p>This document describes the architecture that results from a
particular OpenStack configuration, specifically:&lt;/p></description><content>&lt;p>In &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">Quantum in Too Much Detail&lt;/a>, I discussed the architecture of a
Neutron deployment in detail. Since that article was published,
Neutron gained the ability to handle multiple external networks with a
single L3 agent. While I &lt;a href="https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/">wrote about that&lt;/a> back in 2014, I
covered the configuration side of it in much more detail than I
discussed the underlying network architecture. This post addresses
the architecture side.&lt;/p>
&lt;h2 id="the-players">The players&lt;/h2>
&lt;p>This document describes the architecture that results from a
particular OpenStack configuration, specifically:&lt;/p>
&lt;ul>
&lt;li>Neutron networking using VXLAN or GRE tunnels;&lt;/li>
&lt;li>A dedicated network controller;&lt;/li>
&lt;li>Two external networks&lt;/li>
&lt;/ul>
&lt;h2 id="the-lay-of-the-land">The lay of the land&lt;/h2>
&lt;p>This is a simplified architecture diagram of the network connectivity
in this scenario:&lt;/p>
&lt;p>Everything on the compute hosts is identical to &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">my previous
article&lt;/a>, so I will only be discussing the network host here.&lt;/p>
&lt;p>For the purposes of this article, we have two external networks and
two internal networks defined:&lt;/p>
&lt;pre>&lt;code>$ neutron net-list
+--------------------------------------+-----------+----------...------------------+
| id | name | subnets ... |
+--------------------------------------+-----------+----------...------------------+
| 6f0a5622-4d2b-4e4d-b34a-09b70cacf3f1 | net1 | beb767f8-... 192.168.101.0/24 |
| 972f2853-2ba6-474d-a4be-a400d4e3dc97 | net2 | f6d0ca0f-... 192.168.102.0/24 |
| 12136507-9bbe-406f-b68b-151d2a78582b | external2 | 106db3d6-... 172.24.5.224/28 |
| 973a6eb3-eaf8-4697-b90b-b30315b0e05d | external1 | fe8e8193-... 172.24.4.224/28 |
+--------------------------------------+-----------+----------...------------------+
&lt;/code>&lt;/pre>
&lt;p>And two routers:&lt;/p>
&lt;pre>&lt;code>$ neutron router-list
+--------------------------------------+---------+-----------------------...-------------------+...
| id | name | external_gateway_info ... |...
+--------------------------------------+---------+-----------------------...-------------------+...
| 1b19e179-5d67-4d80-8449-bab42119a4c5 | router2 | {&amp;quot;network_id&amp;quot;: &amp;quot;121365... &amp;quot;172.24.5.226&amp;quot;}]} |...
| e2117de3-58ca-420d-9ac6-c4eccf5e7a53 | router1 | {&amp;quot;network_id&amp;quot;: &amp;quot;973a6e... &amp;quot;172.24.4.227&amp;quot;}]} |...
+--------------------------------------+---------+-----------------------...-------------------+...
&lt;/code>&lt;/pre>
&lt;p>And our logical connectivity is:&lt;/p>
&lt;pre>&lt;code>+---------+ +----------+ +-------------+
| | | | | |
| net1 +----&amp;gt; router1 +----&amp;gt; external1 |
| | | | | |
+---------+ +----------+ +-------------+
+---------+ +----------+ +-------------+
| | | | | |
| net2 +----&amp;gt; router2 +----&amp;gt; external2 |
| | | | | |
+---------+ +----------+ +-------------+
&lt;/code>&lt;/pre>
&lt;h2 id="router-attachments-to-integration-bridge">Router attachments to integration bridge&lt;/h2>
&lt;p>In the &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">legacy model&lt;/a>, in which an L3 agent supported a single
external network, the &lt;code>qrouter-...&lt;/code> namespaces that implement Neutron
routers were attached to both the integration bridge &lt;code>br-int&lt;/code> and the
external network bridge (the &lt;code>external_network_bridge&lt;/code> configuration
option from your &lt;code>l3_agent.ini&lt;/code>, often named &lt;code>br-ex&lt;/code>).&lt;/p>
&lt;p>In the provider network model, &lt;em>both&lt;/em> interfaces in a &lt;code>qrouter&lt;/code>
namespace are attached to the integration bridge. For the
configuration we&amp;rsquo;ve described above, the configuration of the
integration bridge ends up looking something like:&lt;/p>
&lt;pre>&lt;code>Bridge br-int
fail_mode: secure
Port &amp;quot;qvoc532d46c-33&amp;quot;
tag: 3
Interface &amp;quot;qvoc532d46c-33&amp;quot;
Port br-int
Interface br-int
type: internal
Port &amp;quot;qg-09e9da38-fb&amp;quot;
tag: 4
Interface &amp;quot;qg-09e9da38-fb&amp;quot;
type: internal
Port &amp;quot;qvo3ccea690-c2&amp;quot;
tag: 2
Interface &amp;quot;qvo3ccea690-c2&amp;quot;
Port &amp;quot;int-br-ex2&amp;quot;
Interface &amp;quot;int-br-ex2&amp;quot;
type: patch
options: {peer=&amp;quot;phy-br-ex2&amp;quot;}
Port &amp;quot;tapd2ff89e7-16&amp;quot;
tag: 2
Interface &amp;quot;tapd2ff89e7-16&amp;quot;
type: internal
Port patch-tun
Interface patch-tun
type: patch
options: {peer=patch-int}
Port &amp;quot;int-br-ex1&amp;quot;
Interface &amp;quot;int-br-ex1&amp;quot;
type: patch
options: {peer=&amp;quot;phy-br-ex1&amp;quot;}
Port &amp;quot;qr-affdbcee-5c&amp;quot;
tag: 3
Interface &amp;quot;qr-affdbcee-5c&amp;quot;
type: internal
Port &amp;quot;qr-b37877cd-42&amp;quot;
tag: 2
Interface &amp;quot;qr-b37877cd-42&amp;quot;
type: internal
Port &amp;quot;qg-19250d3f-5c&amp;quot;
tag: 1
Interface &amp;quot;qg-19250d3f-5c&amp;quot;
type: internal
Port &amp;quot;tap0881edf5-e5&amp;quot;
tag: 3
Interface &amp;quot;tap0881edf5-e5&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>qr-...&lt;/code> interface on each router is attached to an internal
network. The VLAN tag associated with this interface is whatever VLAN
Neutron has selected internally for the private network. In the above
output, these ports are on the network named &lt;code>net1&lt;/code>:&lt;/p>
&lt;pre>&lt;code>Port &amp;quot;qr-affdbcee-5c&amp;quot;
tag: 3
Interface &amp;quot;qr-affdbcee-5c&amp;quot;
type: internal
Port &amp;quot;tap0881edf5-e5&amp;quot;
tag: 3
Interface &amp;quot;tap0881edf5-e5&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>Where &lt;code>qr-affdbcee-5c&lt;/code> is &lt;code>router1&lt;/code>&amp;rsquo;s interface on that network, and
&lt;code>tap0881edf5-e5&lt;/code> is the port attached to a &lt;code>dhcp-...&lt;/code> namespace. The
same router is attached to the &lt;code>external1&lt;/code> network; this attachment is
represented by:&lt;/p>
&lt;pre>&lt;code>Port &amp;quot;qg-09e9da38-fb&amp;quot;
tag: 4
Interface &amp;quot;qg-09e9da38-fb&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>The external bridges are connected to the integration bridge using OVS
&amp;ldquo;patch&amp;rdquo; interfaces (the &lt;code>int-br-ex1&lt;/code> on the integration bridge and the
&lt;code>phy-br-ex1&lt;/code> interface on the &lt;code>br-ex1&lt;/code>).&lt;/p>
&lt;h2 id="from-here-to-there">From here to there&lt;/h2>
&lt;p>Connectivity between the &lt;code>qg-...&lt;/code> interface and the appropriate
external bridge (&lt;code>br-ex1&lt;/code> in this case) happens due to the VLAN tag
assigned on egress by the &lt;code>qg-...&lt;/code> interface and the following
OpenFlow rules associated with &lt;code>br-ex1&lt;/code>:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl dump-flows br-ex1
NXST_FLOW reply (xid=0x4):
cookie=0x0, duration=794.876s, table=0, n_packets=0, n_bytes=0, idle_age=794, priority=1 actions=NORMAL
cookie=0x0, duration=785.833s, table=0, n_packets=0, n_bytes=0, idle_age=785, priority=4,in_port=3,dl_vlan=4 actions=strip_vlan,NORMAL
cookie=0x0, duration=792.945s, table=0, n_packets=24, n_bytes=1896, idle_age=698, priority=2,in_port=3 actions=drop
&lt;/code>&lt;/pre>
&lt;p>Each of these rules contains some state information (like the
packet/byte counts), some conditions (like
&lt;code>priority=4,in_port=3,dl_vlan=4&lt;/code>) and one or more actions (like
&lt;code>actions=strip_vlan,NORMAL&lt;/code>). So, the second rule there matches
packets associated with VLAN tag 4 and strips the VLAN tag (after
which the packet is delivered to any physical interfaces that are
attached to this OVS bridge).&lt;/p>
&lt;p>Putting this all together:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>An outbound packet from a Nova server running on a compute node
enters via &lt;code>br-tun&lt;/code> (&lt;strong>H&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Flow rules on &lt;code>br-tun&lt;/code> translate the tunnel id into an internal
VLAN tag.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet gets delivered to the &lt;code>qr-...&lt;/code> interface of the
appropriate router. (&lt;strong>O&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet exits the &lt;code>qg-...&lt;/code> interface of the router (where it
is assigned the VLAN tag associated with the external network).
(&lt;strong>N&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet is delivered to the external bridge, where a flow rule
strip the VLAN tag. (&lt;strong>P&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet is sent out the physical interface associated with the
bridge.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="for-the-sake-of-completeness">For the sake of completeness&lt;/h2>
&lt;p>The second private network, &lt;code>net2&lt;/code>, is attached to &lt;code>router2&lt;/code> on the
&lt;code>qr-b37877cd-42&lt;/code> interface. It exits on the &lt;code>qg-19250d3f-5c&lt;/code>
interface, where packets will be assigned to VLAN 1:&lt;/p>
&lt;pre>&lt;code>Port &amp;quot;qr-b37877cd-42&amp;quot;
tag: 2
Interface &amp;quot;qr-b37877cd-42&amp;quot;
type: internal
Port &amp;quot;qg-19250d3f-5c&amp;quot;
tag: 1
Interface &amp;quot;qg-19250d3f-5c&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>The network interface configuration in the associated router namespace
looks like this:&lt;/p>
&lt;pre>&lt;code># ip netns exec qrouter-1b19e179-5d67-4d80-8449-bab42119a4c5 ip a
30: qg-19250d3f-5c: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether fa:16:3e:01:e9:e3 brd ff:ff:ff:ff:ff:ff
inet 172.24.5.226/28 brd 172.24.5.239 scope global qg-19250d3f-5c
valid_lft forever preferred_lft forever
inet6 fe80::f816:3eff:fe01:e9e3/64 scope link
valid_lft forever preferred_lft forever
37: qr-b37877cd-42: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether fa:16:3e:4c:6c:f2 brd ff:ff:ff:ff:ff:ff
inet 192.168.102.1/24 brd 192.168.102.255 scope global qr-b37877cd-42
valid_lft forever preferred_lft forever
inet6 fe80::f816:3eff:fe4c:6cf2/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>OpenFlow rules attached to &lt;code>br-ex2&lt;/code> will match these packets:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl dump-flows br-ex2
NXST_FLOW reply (xid=0x4):
cookie=0x0, duration=3841.678s, table=0, n_packets=0, n_bytes=0, idle_age=3841, priority=1 actions=NORMAL
cookie=0x0, duration=3831.396s, table=0, n_packets=0, n_bytes=0, idle_age=3831, priority=4,in_port=3,dl_vlan=1 actions=strip_vlan,NORMAL
cookie=0x0, duration=3840.085s, table=0, n_packets=26, n_bytes=1980, idle_age=3742, priority=2,in_port=3 actions=drop
&lt;/code>&lt;/pre>
&lt;p>We can see that the second rule here will patch traffic on VLAN 1
(&lt;code>priority=4,in_port=3,dl_vlan=1&lt;/code>) and strip the VLAN tag, after which
the packet will be delivered to any other interfaces attached to this
bridge.&lt;/p></content></item><item><title>Docker networking with dedicated network containers</title><link>https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/</link><pubDate>Mon, 06 Oct 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/</guid><description>&lt;p>The current version of Docker has a very limited set of networking
options:&lt;/p>
&lt;ul>
&lt;li>&lt;code>bridge&lt;/code> &amp;ndash; connect a container to the Docker bridge&lt;/li>
&lt;li>&lt;code>host&lt;/code> &amp;ndash; run the container in the global network namespace&lt;/li>
&lt;li>&lt;code>container:xxx&lt;/code> &amp;ndash; connect a container to the network namespace of
another container&lt;/li>
&lt;li>&lt;code>none&lt;/code> &amp;ndash; do not configure any networking&lt;/li>
&lt;/ul>
&lt;p>If you need something more than that, you can use a tool like
&lt;a href="https://github.com/jpetazzo/pipework">pipework&lt;/a> to provision additional network interfaces inside the
container, but this leads to a synchronization problem: &lt;code>pipework&lt;/code> can
only be used after your container is running. This means that when
starting your container, you must have logic that will wait until the
necessary networking is available before starting your service.&lt;/p></description><content>&lt;p>The current version of Docker has a very limited set of networking
options:&lt;/p>
&lt;ul>
&lt;li>&lt;code>bridge&lt;/code> &amp;ndash; connect a container to the Docker bridge&lt;/li>
&lt;li>&lt;code>host&lt;/code> &amp;ndash; run the container in the global network namespace&lt;/li>
&lt;li>&lt;code>container:xxx&lt;/code> &amp;ndash; connect a container to the network namespace of
another container&lt;/li>
&lt;li>&lt;code>none&lt;/code> &amp;ndash; do not configure any networking&lt;/li>
&lt;/ul>
&lt;p>If you need something more than that, you can use a tool like
&lt;a href="https://github.com/jpetazzo/pipework">pipework&lt;/a> to provision additional network interfaces inside the
container, but this leads to a synchronization problem: &lt;code>pipework&lt;/code> can
only be used after your container is running. This means that when
starting your container, you must have logic that will wait until the
necessary networking is available before starting your service.&lt;/p>
&lt;p>The &lt;a href="https://github.com/GoogleCloudPlatform/kubernetes">kubernetes&lt;/a> project uses a clever solution to this problem:&lt;/p>
&lt;p>Begin by starting a no-op container &amp;ndash; that is, a container that does
not run any services &amp;ndash; with &lt;code>--net=none&lt;/code>. It needs to run
&lt;em>something&lt;/em>; otherwise it will exit. The &lt;code>kubernetes/pause&lt;/code> image
implements an extremely minimal &amp;ldquo;do nothing but wait&amp;rdquo; solution.&lt;/p>
&lt;p>Once you have this no-op container running, you can set up the
corresponding network namespace to meet your requirements. For
example, you can create a &lt;code>veth&lt;/code> device pair and place one end in the
interface and attach another to a bridge on your system. &lt;a href="https://github.com/jpetazzo/pipework">Pipework&lt;/a>
can help with this, but you can also perform all the &lt;a href="https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/">changes by
hand&lt;/a>&lt;/p>
&lt;p>Once your networking is configured, start your actual service
container with &lt;code>--net=container:&amp;lt;id-of-noop-container&amp;gt;&lt;/code>. Your service
container will start with your configured network environment.&lt;/p>
&lt;p>You could, I suppose, decide to link &lt;em>every&lt;/em> service container with
it&amp;rsquo;s own network container, but that would get messy. Kubernetes
groups containers together into &amp;ldquo;pods&amp;rdquo;, in which all containers in a
pod share the same network namespace, which reduces the number of
&amp;ldquo;networking containers&amp;rdquo; necessary for services that have the same
networking requirements.&lt;/p>
&lt;p>This solution &amp;ndash; linking your service container with a no-op container
used to implement networking &amp;ndash; solves the problems identified at the
beginning of this post: because you can perform all your network
configuration prior to starting your service, your service container
does not need any special logic to deal with interfaces that will be
created after the container starts. The networking will already be
in place when the service starts.&lt;/p>
&lt;p>Docker issue &lt;a href="https://github.com/docker/docker/issues/7455">7455&lt;/a> proposes a docker-native solution that would
accomplish largely the same thing without requiring the separate
networking container (by permitting you to pre-configure a network
namespace and then pass that to docker using something like
&lt;code>--net=netns:&amp;lt;name-of-network-namespace&amp;gt;&lt;/code>).&lt;/p></content></item><item><title>Four ways to connect a docker container to a local network</title><link>https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/</link><pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/</guid><description>&lt;p>&lt;strong>Update (2018-03-22)&lt;/strong> Since I wrote this document back in 2014,
Docker has developed the &lt;a href="https://docs.docker.com/network/macvlan/">macvlan network
driver&lt;/a>. That gives you a
&lt;em>supported&lt;/em> mechanism for direct connectivity to a local layer 2
network. I&amp;rsquo;ve &lt;a href="https://blog.oddbit.com/2018/03/12/using-docker-macvlan-networks/">written an article about working with the macvlan
driver&lt;/a>.&lt;/p>
&lt;hr>
&lt;p>This article discusses four ways to make a Docker container appear on
a local network. These are not suggested as practical solutions, but
are meant to illustrate some of the underlying network technology
available in Linux.&lt;/p></description><content>&lt;p>&lt;strong>Update (2018-03-22)&lt;/strong> Since I wrote this document back in 2014,
Docker has developed the &lt;a href="https://docs.docker.com/network/macvlan/">macvlan network
driver&lt;/a>. That gives you a
&lt;em>supported&lt;/em> mechanism for direct connectivity to a local layer 2
network. I&amp;rsquo;ve &lt;a href="https://blog.oddbit.com/2018/03/12/using-docker-macvlan-networks/">written an article about working with the macvlan
driver&lt;/a>.&lt;/p>
&lt;hr>
&lt;p>This article discusses four ways to make a Docker container appear on
a local network. These are not suggested as practical solutions, but
are meant to illustrate some of the underlying network technology
available in Linux.&lt;/p>
&lt;p>If you were actually going to use one of these solutions as anything
other than a technology demonstration, you might look to the &lt;a href="https://github.com/jpetazzo/pipework">pipework&lt;/a> script, which can automate many of these configurations.&lt;/p>
&lt;h2 id="goals-and-assumptions">Goals and Assumptions&lt;/h2>
&lt;p>In the following examples, we have a host with address 10.12.0.76 on
the 10.12.0.0/21 network. We are creating a Docker container that we
want to expose as 10.12.0.117.&lt;/p>
&lt;p>I am running Fedora 20 with Docker 1.1.2. This means, in particular,
that my &lt;code>utils-linux&lt;/code> package is recent enough to include the
&lt;a href="http://man7.org/linux/man-pages/man1/nsenter.1.html">nsenter&lt;/a> command. If you don&amp;rsquo;t have that handy, there is a
convenient Docker recipe to build it for you at &lt;a href="https://github.com/jpetazzo/nsenter">jpetazzo/nsenter&lt;/a>
on GitHub.&lt;/p>
&lt;h2 id="a-little-help-along-the-way">A little help along the way&lt;/h2>
&lt;p>In this article we will often refer to the PID of a docker container.
In order to make this convenient, drop the following into a script
called &lt;code>docker-pid&lt;/code>, place it somewhere on your &lt;code>PATH&lt;/code>, and make it
executable:&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
exec docker inspect --format '{{ .State.Pid }}' &amp;quot;$@&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>This allows us to conveniently get the PID of a docker container by
name or ID:&lt;/p>
&lt;pre>&lt;code>$ docker-pid web
22041
&lt;/code>&lt;/pre>
&lt;p>In a script called &lt;code>docker-ip&lt;/code>, place the following:&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
exec docker inspect --format '{{ .NetworkSettings.IPAddress }}' &amp;quot;$@&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>And now we can get the ip address of a container like this:&lt;/p>
&lt;pre>&lt;code>$ docker-ip web
172.17.0.4
&lt;/code>&lt;/pre>
&lt;h2 id="using-nat">Using NAT&lt;/h2>
&lt;p>This uses the standard Docker network model combined with NAT rules on
your host to redirect inbound traffic to/outbound traffic from the
appropriate IP address.&lt;/p>
&lt;p>Assign our target address to your host interface:&lt;/p>
&lt;pre>&lt;code># ip addr add 10.12.0.117/21 dev em1
&lt;/code>&lt;/pre>
&lt;p>Start your docker container, using the &lt;code>-p&lt;/code> option to bind exposed
ports to an ip address and port on the host:&lt;/p>
&lt;pre>&lt;code># docker run -d --name web -p 10.12.0.117:80:80 larsks/simpleweb
&lt;/code>&lt;/pre>
&lt;p>With this command, Docker will set up the &lt;a href="https://docs.docker.com/articles/networking/">standard network&lt;/a> model:&lt;/p>
&lt;ul>
&lt;li>It will create a &lt;a href="http://lwn.net/Articles/232688/">veth&lt;/a> interface pair.&lt;/li>
&lt;li>Connect one end to the &lt;code>docker0&lt;/code> bridge.&lt;/li>
&lt;li>Place the other inside the container namespace as &lt;code>eth0&lt;/code>.&lt;/li>
&lt;li>Assign an ip address from the network used by the &lt;code>docker0&lt;/code> bridge.&lt;/li>
&lt;/ul>
&lt;p>Because we added &lt;code>-p 10.12.0.117:80:80&lt;/code> to our command line, Docker
will also create the following rule in the &lt;code>nat&lt;/code> table &lt;code>DOCKER&lt;/code>
chain (which is run from the &lt;code>PREROUTING&lt;/code> chain):&lt;/p>
&lt;pre>&lt;code>-A DOCKER -d 10.12.0.117/32 ! -i docker0 -p tcp -m tcp
--dport 80 -j DNAT --to-destination 172.17.0.4:80
&lt;/code>&lt;/pre>
&lt;p>This matches traffic TO our target address (&lt;code>-d 10.12.0.117/32&lt;/code>) not
originating on the &lt;code>docker0&lt;/code> bridge (&lt;code>! -i docker0&lt;/code>) destined for
&lt;code>tcp&lt;/code> port &lt;code>80&lt;/code> (&lt;code>-p tcp -m tcp --dport 80&lt;/code>). Matching traffic has
it&amp;rsquo;s destination set to the address of our docker container (&lt;code>-j DNAT --to-destination 172.17.0.4:80&lt;/code>).&lt;/p>
&lt;p>From a host elsewhere on the network, we can now access the web server
at our selected ip address:&lt;/p>
&lt;pre>&lt;code>$ curl http://10.12.0.117/hello.html
Hello world
&lt;/code>&lt;/pre>
&lt;p>If our container were to initiate a network connection with another
system, that connection would appear to originate with ip address of
our &lt;em>host&lt;/em>. We can fix that my adding a &lt;code>SNAT&lt;/code> rule to the
&lt;code>POSTROUTING&lt;/code> chain to modify the source address:&lt;/p>
&lt;pre>&lt;code># iptables -t nat -I POSTROUTING -s $(docker-ip web) \
-j SNAT --to-source 10.12.0.117
&lt;/code>&lt;/pre>
&lt;p>Note here the use of &lt;code>-I POSTROUTING&lt;/code>, which places the rule at the
&lt;em>top&lt;/em> of the &lt;code>POSTROUTING&lt;/code> chain. This is necessary because, by
default, Docker has already added the following rule to the top of the
&lt;code>POSTROUTING&lt;/code> chain:&lt;/p>
&lt;pre>&lt;code>-A POSTROUTING -s 172.17.0.0/16 ! -d 172.17.0.0/16 -j MASQUERADE
&lt;/code>&lt;/pre>
&lt;p>Because this &lt;code>MASQUERADE&lt;/code> rule matches traffic from any container, we
need to place our rule earlier in the &lt;code>POSTROUTING&lt;/code> chain for it to
have any affect.&lt;/p>
&lt;p>With these rules in place, traffic to 10.12.0.117 (port 80) is
directed to our &lt;code>web&lt;/code> container, and traffic &lt;em>originating&lt;/em> in the web
container will appear to come from 10.12.0.117.&lt;/p>
&lt;h2 id="with-linux-bridge-devices">With Linux Bridge devices&lt;/h2>
&lt;p>The previous example was relatively easy to configure, but has a few
shortcomings. If you need to configure an interface using DHCP, or if
you have an application that needs to be on the same layer 2 broadcast
domain as other devices on your network, NAT rules aren&amp;rsquo;t going to
work out.&lt;/p>
&lt;p>This solution uses a Linux bridge device, created using &lt;code>brctl&lt;/code>, to
connect your containers directly to a physical network.&lt;/p>
&lt;p>Start by creating a new bridge device. In this example, we&amp;rsquo;ll create
one called &lt;code>br-em1&lt;/code>:&lt;/p>
&lt;pre>&lt;code># brctl addbr br-em1
# ip link set br-em1 up
&lt;/code>&lt;/pre>
&lt;p>We&amp;rsquo;re going to add &lt;code>em1&lt;/code> to this bridge, and move the ip address from
&lt;code>em1&lt;/code> onto the bridge.&lt;/p>
&lt;p>&lt;strong>WARNING&lt;/strong>: This is not something you should do remotely, especially
for the first time, and making this persistent varies from
distribution to distribution, so this will not be a persistent
configuration.&lt;/p>
&lt;p>Look at the configuration of interface &lt;code>em1&lt;/code> and note the existing ip
address:&lt;/p>
&lt;pre>&lt;code># ip addr show em1
2: em1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc mq master br-em1 state UP group default qlen 1000
link/ether 00:1d:09:63:71:30 brd ff:ff:ff:ff:ff:ff
inet 10.12.0.76/21 scope global br-em1
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>Look at your current routes and note the default route:&lt;/p>
&lt;pre>&lt;code># ip route
default via 10.12.7.254 dev em1
10.12.0.0/21 dev em1 proto kernel scope link src 10.12.0.76
&lt;/code>&lt;/pre>
&lt;p>Now, add this device to your bridge:&lt;/p>
&lt;pre>&lt;code># brctl addif br-em1 em1
&lt;/code>&lt;/pre>
&lt;p>Configure the bridge with the address that used to belong to
&lt;code>em1&lt;/code>:&lt;/p>
&lt;pre>&lt;code># ip addr del 10.12.0.76/21 dev em1
# ip addr add 10.12.0.76/21 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>And move the default route to the bridge:&lt;/p>
&lt;pre>&lt;code># ip route del default
# ip route add default via 10.12.7.254 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>If you were doing this remotely; you would do this all in one line
like this:&lt;/p>
&lt;pre>&lt;code># ip addr add 10.12.0.76/21 dev br-em1; \
ip addr del 10.12.0.76/21 dev em1; \
brctl addif br-em1 em1; \
ip route del default; \
ip route add default via 10.12.7.254 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>At this point, verify that you still have network connectivity:&lt;/p>
&lt;pre>&lt;code># curl http://google.com/
&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html;charset=utf-8&amp;quot;&amp;gt;
[...]
&lt;/code>&lt;/pre>
&lt;p>Start up the web container:&lt;/p>
&lt;pre>&lt;code># docker run -d --name web larsks/simpleweb
&lt;/code>&lt;/pre>
&lt;p>This will give us the normal &lt;code>eth0&lt;/code> interface inside the container,
but we&amp;rsquo;re going to ignore that and add a new one.&lt;/p>
&lt;p>Create a &lt;a href="http://lwn.net/Articles/232688/">veth&lt;/a> interface pair:&lt;/p>
&lt;pre>&lt;code># ip link add web-int type veth peer name web-ext
&lt;/code>&lt;/pre>
&lt;p>Add the &lt;code>web-ext&lt;/code> link to the &lt;code>br-eth0&lt;/code> bridge:&lt;/p>
&lt;pre>&lt;code># brctl addif br-em1 web-ext
&lt;/code>&lt;/pre>
&lt;p>And add the &lt;code>web-int&lt;/code> interface to the namespace of the container:&lt;/p>
&lt;pre>&lt;code># ip link set netns $(docker-pid web) dev web-int
&lt;/code>&lt;/pre>
&lt;p>Next, we&amp;rsquo;ll use the &lt;a href="http://man7.org/linux/man-pages/man1/nsenter.1.html">nsenter&lt;/a> command (part of the &lt;code>util-linux&lt;/code> package) to run some commands inside the &lt;code>web&lt;/code> container. Start by bringing up the link inside the container:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip link set web-int up
&lt;/code>&lt;/pre>
&lt;p>Assign our target ip address to the interface:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip addr add 10.12.0.117/21 dev web-int
&lt;/code>&lt;/pre>
&lt;p>And set a new default route inside the container:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip route del default
# nsenter -t $(docker-pid web) -n ip route add default via 10.12.7.254 dev web-int
&lt;/code>&lt;/pre>
&lt;p>Again, we can verify from another host that the web server is
available at 10.12.0.117:&lt;/p>
&lt;pre>&lt;code>$ curl http://10.12.0.117/hello.html
Hello world
&lt;/code>&lt;/pre>
&lt;p>Note that in this example we have assigned a static ip address, but we
could just have easily acquired an address using DHCP. After running:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip link set web-int up
&lt;/code>&lt;/pre>
&lt;p>We can run:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n -- dhclient -d web-int
Internet Systems Consortium DHCP Client 4.2.6
Copyright 2004-2014 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
Listening on LPF/web-int/6e:f0:a8:c6:f0:43
Sending on LPF/web-int/6e:f0:a8:c6:f0:43
Sending on Socket/fallback
DHCPDISCOVER on web-int to 255.255.255.255 port 67 interval 4 (xid=0x3aaab45b)
DHCPREQUEST on web-int to 255.255.255.255 port 67 (xid=0x3aaab45b)
DHCPOFFER from 10.12.7.253
DHCPACK from 10.12.7.253 (xid=0x3aaab45b)
bound to 10.12.6.151 -- renewal in 714 seconds.
&lt;/code>&lt;/pre>
&lt;h2 id="with-open-vswitch-bridge-devices">With Open vSwitch Bridge devices&lt;/h2>
&lt;p>This process is largely the same as in the previous example, but we
use &lt;a href="http://openvswitch.org/">Open vSwitch&lt;/a> instead of the legacy Linux bridge devices.
These instructions assume that you have already installed and started
Open vSwitch on your system.&lt;/p>
&lt;p>Create an OVS bridge using the &lt;code>ovs-vsctl&lt;/code> command:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-br br-em1
# ip link set br-em1 up
&lt;/code>&lt;/pre>
&lt;p>And add your external interface:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-port br-em1 em1
&lt;/code>&lt;/pre>
&lt;p>And then proceed as in the previous set of instructions.&lt;/p>
&lt;p>The equivalent all-in-one command is:&lt;/p>
&lt;pre>&lt;code># ip addr add 10.12.0.76/21 dev br-em1; \
ip addr del 10.12.0.76/21 dev em1; \
ovs-vsctl add-port br-em1 em1; \
ip route del default; \
ip route add default via 10.12.7.254 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>Once that completes, your openvswitch configuration should look like
this:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl show
0b1d5895-88e6-42e5-a1da-ad464c75198c
Bridge &amp;quot;br-em1&amp;quot;
Port &amp;quot;br-em1&amp;quot;
Interface &amp;quot;br-em1&amp;quot;
type: internal
Port &amp;quot;em1&amp;quot;
Interface &amp;quot;em1&amp;quot;
ovs_version: &amp;quot;2.1.2&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>To add the &lt;code>web-ext&lt;/code> interface to the bridge, run:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-port br-em1 web-ext
&lt;/code>&lt;/pre>
&lt;p>Instead of:&lt;/p>
&lt;pre>&lt;code># brctl addif br-em1 web-ext
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>WARNING&lt;/strong>: The Open vSwitch configuration persists between reboots.
This means that when your system comes back up, &lt;code>em1&lt;/code> will still be a
member of &lt;code>br-em&lt;/code>, which will probably result in no network
connectivity for your host.&lt;/p>
&lt;p>Before rebooting your system, make sure to &lt;code>ovs-vsctl del-port br-em1 em1&lt;/code>.&lt;/p>
&lt;h2 id="with-macvlan-devices">With macvlan devices&lt;/h2>
&lt;p>This process is similar to the previous two, but instead of using a
bridge device we will create a &lt;a href="http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/">macvlan&lt;/a>, which is a virtual network
interface associated with a physical interface. Unlike the previous
two solutions, this does not require any interruption to your primary
network interface.&lt;/p>
&lt;p>Start by creating a docker container as in the previous examples:&lt;/p>
&lt;pre>&lt;code># docker run -d --name web larsks/simpleweb
&lt;/code>&lt;/pre>
&lt;p>Create a &lt;code>macvlan&lt;/code> interface associated with your physical interface:&lt;/p>
&lt;pre>&lt;code># ip link add em1p0 link em1 type macvlan mode bridge
&lt;/code>&lt;/pre>
&lt;p>This creates a new &lt;code>macvlan&lt;/code> interface named &lt;code>em1p0&lt;/code> (but you can
name it anything you want) associated with interface &lt;code>em1&lt;/code>. We are
setting it up in &lt;code>bridge&lt;/code> mode, which permits all &lt;code>macvlan&lt;/code> interfaces
to communicate with eachother.&lt;/p>
&lt;p>Add this interface to the container&amp;rsquo;s network namespace:&lt;/p>
&lt;pre>&lt;code># ip link set netns $(docker-pid web) em1p0
&lt;/code>&lt;/pre>
&lt;p>Bring up the link:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip link set em1p0 up
&lt;/code>&lt;/pre>
&lt;p>And configure the ip address and routing:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip route del default
# nsenter -t $(docker-pid web) -n ip addr add 10.12.0.117/21 dev em1p0
# nsenter -t $(docker-pid web) -n ip route add default via 10.12.7.254 dev em1p0
&lt;/code>&lt;/pre>
&lt;p>And demonstrate that &lt;em>from another host&lt;/em> the web server is available
at 10.12.0.117:&lt;/p>
&lt;pre>&lt;code>$ curl http://10.12.0.117/hello.html
Hello world
&lt;/code>&lt;/pre>
&lt;p>But note that if you were to try the same thing on the host, you would
get:&lt;/p>
&lt;pre>&lt;code>curl: (7) Failed connect to 10.12.0.117:80; No route to host
&lt;/code>&lt;/pre>
&lt;p>The &lt;em>host&lt;/em> is unable to communicate with &lt;code>macvlan&lt;/code> devices via the
primary interface. You can create &lt;em>another&lt;/em> &lt;code>macvlan&lt;/code> interface on
the host, give it an address on the appropriate network, and then set
up routes to your containers via that interface:&lt;/p>
&lt;pre>&lt;code># ip link add em1p1 link em1 type macvlan mode bridge
# ip addr add 10.12.6.144/21 dev em1p1
# ip route add 10.12.0.117 dev em1p1
&lt;/code>&lt;/pre></content></item><item><title>Booting an instance with multiple fixed addresses</title><link>https://blog.oddbit.com/post/2014-05-28-booting-an-instance-with-multi/</link><pubDate>Wed, 28 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-28-booting-an-instance-with-multi/</guid><description>&lt;p>This article expands on my answer to &lt;a href="https://ask.openstack.org/en/question/30690/add-multiple-specific-ips-to-instance/">Add multiple specific IPs to
instance&lt;/a>, a question posted to &lt;a href="https://ask.openstack.org/">ask.openstack.org&lt;/a>.&lt;/p>
&lt;p>In order to serve out SSL services from an OpenStack instance, you
will generally want one local ip address for each SSL virtual host you
support. It is possible to create an instance with multiple fixed
addresses, but there are a few complications to watch out for.&lt;/p>
&lt;h1 id="assumptions">Assumptions&lt;/h1>
&lt;p>This article assumes that the following resources exist:&lt;/p></description><content>&lt;p>This article expands on my answer to &lt;a href="https://ask.openstack.org/en/question/30690/add-multiple-specific-ips-to-instance/">Add multiple specific IPs to
instance&lt;/a>, a question posted to &lt;a href="https://ask.openstack.org/">ask.openstack.org&lt;/a>.&lt;/p>
&lt;p>In order to serve out SSL services from an OpenStack instance, you
will generally want one local ip address for each SSL virtual host you
support. It is possible to create an instance with multiple fixed
addresses, but there are a few complications to watch out for.&lt;/p>
&lt;h1 id="assumptions">Assumptions&lt;/h1>
&lt;p>This article assumes that the following resources exist:&lt;/p>
&lt;ul>
&lt;li>a private network &lt;code>net0&lt;/code>.&lt;/li>
&lt;li>a private network &lt;code>net0-subnet0&lt;/code>, associated with &lt;code>net0&lt;/code>, assigned
the range &lt;code>10.0.0.0/24&lt;/code>.&lt;/li>
&lt;li>a public network &lt;code>external&lt;/code> assigned the range &lt;code>192.168.200.0/24&lt;/code>.&lt;/li>
&lt;li>an image named &lt;code>fedora-20-x86_64&lt;/code>, with hopefully self-evident
contents.&lt;/li>
&lt;/ul>
&lt;h1 id="creating-a-port">Creating a port&lt;/h1>
&lt;p>Start by creating a port in Neutron:&lt;/p>
&lt;pre>&lt;code>$ neutron port-create net0 \
--fixed-ip subnet_id=net0-subnet0 \
--fixed-ip subnet_id=net0-subnet0
&lt;/code>&lt;/pre>
&lt;p>This will create a neutron port to which have been allocated to fixed
ip addresses from &lt;code>net0-subnet0&lt;/code>:&lt;/p>
&lt;pre>&lt;code>+-----------------------+----------------------------------------------------------------------------------+
| Field | Value |
+-----------------------+----------------------------------------------------------------------------------+
| admin_state_up | True |
| allowed_address_pairs | |
| binding:vnic_type | normal |
| device_id | |
| device_owner | |
| fixed_ips | {&amp;quot;subnet_id&amp;quot;: &amp;quot;f8ca90fd-cb82-4218-9627-6fa66e4c9c3c&amp;quot;, &amp;quot;ip_address&amp;quot;: &amp;quot;10.0.0.18&amp;quot;} |
| | {&amp;quot;subnet_id&amp;quot;: &amp;quot;f8ca90fd-cb82-4218-9627-6fa66e4c9c3c&amp;quot;, &amp;quot;ip_address&amp;quot;: &amp;quot;10.0.0.19&amp;quot;} |
| id | 3c564dd5-fd45-4f61-88df-715f71667b3b |
| mac_address | fa:16:3e:e1:15:7f |
| name | |
| network_id | bb4e5e37-74e1-41bd-880e-b59e94236c5e |
| security_groups | 52f7a87c-380f-4a07-a6ff-d64be495f25b |
| status | DOWN |
| tenant_id | 4dfe8e38f68449b6a0c9cd73037726f7 |
+-----------------------+----------------------------------------------------------------------------------+
&lt;/code>&lt;/pre>
&lt;p>If you want, you can specify an explicit set of addresses rather than
having neutron allocate them for you:&lt;/p>
&lt;pre>&lt;code>$ neutron port-create net0 \
--fixed-ip subnet_id=net0-subnet0,ip_address=10.0.0.18 \
--fixed-ip subnet_id=net0-subnet0,ip_address=10.0.0.19
&lt;/code>&lt;/pre>
&lt;h1 id="boot-an-instance">Boot an instance&lt;/h1>
&lt;p>You can boot an instance using this port using the &lt;code>port-id=...&lt;/code>
parameter to the &lt;code>--nic&lt;/code> option:&lt;/p>
&lt;pre>&lt;code>$ nova boot \
--nic port-id=3c564dd5-fd45-4f61-88df-715f71667b3b \
--flavor m1.tiny \
--image fedora-20-x86_64 \
--key-name lars test0
&lt;/code>&lt;/pre>
&lt;p>This is where the first complication arises: the instance will boot
and receive a DHCP lease for one of the fixed addresses you created,
but you don&amp;rsquo;t know which one. This isn&amp;rsquo;t an insurmountable problem;
you can assign floating ips to each one and then try logging in to
both and see which works.&lt;/p>
&lt;p>Rather than playing network roulette, you can pass in a script via the
&lt;code>--user-data&lt;/code> option that will take care of configuring the network
correctly. For example, something like this:&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
cat &amp;gt; /etc/sysconfig/network-scripts/ifcfg-eth0 &amp;lt;&amp;lt;EOF
DEVICE=eth0
BOOTPROTO=none
IPADDR=10.0.0.18
NETMASK=255.255.255.0
GATEWAY=10.0.0.1
ONBOOT=yes
EOF
cat &amp;gt; /etc/sysconfig/network-scripts/ifcfg-eth0:0 &amp;lt;&amp;lt;EOF
DEVICE=eth0:0
BOOTPROTO=none
IPADDR=10.0.0.19
NETMASK=255.255.255.0
GATEWAY=10.0.0.1
ONBOOT=yes
EOF
ifdown eth0
ifup eth0
ifup eth0:0
&lt;/code>&lt;/pre>
&lt;p>And boot the instance like this:&lt;/p>
&lt;pre>&lt;code>$ nova boot --nic port-id=3c564dd5-fd45-4f61-88df-715f71667b3b \
--flavor m1.tiny --image fedora-20-x86_64 --key-name lars \
--user-data userdata.txt test0
&lt;/code>&lt;/pre>
&lt;p>Assuming that your image uses &lt;a href="http://cloudinit.readthedocs.org/en/latest/">cloud-init&lt;/a> or something similar, it
should execute the &lt;code>user-data&lt;/code> script at boot and set up the
persistent network configuration.&lt;/p>
&lt;p>At this stage, you can verify that both addresses have been assigned
by using the &lt;code>ip netns&lt;/code> command to run &lt;code>ping&lt;/code> inside an appropriate
namespace. Something like:&lt;/p>
&lt;pre>&lt;code>$ sudo ip netns exec qdhcp-bb4e5e37-74e1-41bd-880e-b59e94236c5e ping -c1 10.0.0.18
PING 10.0.0.18 (10.0.0.18) 56(84) bytes of data.
64 bytes from 10.0.0.18: icmp_seq=1 ttl=64 time=1.60 ms
--- 10.0.0.18 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 1.606/1.606/1.606/0.000 ms
$ sudo ip netns exec qdhcp-bb4e5e37-74e1-41bd-880e-b59e94236c5e ping -c1 10.0.0.19
PING 10.0.0.19 (10.0.0.19) 56(84) bytes of data.
64 bytes from 10.0.0.19: icmp_seq=1 ttl=64 time=1.60 ms
--- 10.0.0.19 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 1.701/1.701/1.701/0.000 ms
&lt;/code>&lt;/pre>
&lt;p>This assumes that the UUID of the &lt;code>net0&lt;/code> network is &lt;code>bb4e5e37-74e1-41bd-880e-b59e94236c5e&lt;/code>. On your system, the namespace will be something different.&lt;/p>
&lt;h1 id="assign-floating-ips">Assign floating ips&lt;/h1>
&lt;p>Assign a floating ip address to each of the fixed addresses. You will
need to use the &lt;code>--fixed-address&lt;/code> option to &lt;code>nova add-floating-ip&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ nova add-floating-ip --fixed-address 10.0.0.19 test0 192.168.200.6
$ nova add-floating-ip --fixed-address 10.0.0.18 test0 192.168.200.4
&lt;/code>&lt;/pre>
&lt;p>With these changes in place, the system is accessible via either
address:&lt;/p>
&lt;pre>&lt;code>$ ssh fedora@192.168.200.4 uptime
14:51:52 up 4 min, 0 users, load average: 0.00, 0.02, 0.02
$ ssh fedora@192.168.200.6 uptime
14:51:54 up 4 min, 0 users, load average: 0.00, 0.02, 0.02
&lt;/code>&lt;/pre>
&lt;p>And looking at the network configuration on the system, we can see
that both addresses have been assigned to &lt;code>eth0&lt;/code> as expected:&lt;/p>
&lt;pre>&lt;code>$ ssh fedora@192.168.200.4 /sbin/ip a
[...]
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
link/ether fa:16:3e:bf:f9:6a brd ff:ff:ff:ff:ff:ff
inet 10.0.0.18/24 brd 10.0.0.255 scope global eth0
valid_lft forever preferred_lft forever
inet 10.0.0.19/24 brd 10.0.0.255 scope global secondary eth0:0
valid_lft forever ...
&lt;/code>&lt;/pre></content></item><item><title>Multiple external networks with a single L3 agent</title><link>https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/</link><pubDate>Wed, 28 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/</guid><description>&lt;p>In the old days (so, like, last year), Neutron supported a single
external network per L3 agent. You would run something like this&amp;hellip;&lt;/p>
&lt;pre>&lt;code>$ neutron net-create external --router:external=true
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;and neutron would map this to the bridge defined in
&lt;code>external_network_bridge&lt;/code> in &lt;code>/etc/neutron/l3_agent.ini&lt;/code>. If you
wanted to support more than a single external network, you would need
to run multiple L3 agents, each with a unique value for
&lt;code>external_network_bridge&lt;/code>.&lt;/p>
&lt;p>There is now a better option available.&lt;/p></description><content>&lt;p>In the old days (so, like, last year), Neutron supported a single
external network per L3 agent. You would run something like this&amp;hellip;&lt;/p>
&lt;pre>&lt;code>$ neutron net-create external --router:external=true
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;and neutron would map this to the bridge defined in
&lt;code>external_network_bridge&lt;/code> in &lt;code>/etc/neutron/l3_agent.ini&lt;/code>. If you
wanted to support more than a single external network, you would need
to run multiple L3 agents, each with a unique value for
&lt;code>external_network_bridge&lt;/code>.&lt;/p>
&lt;p>There is now a better option available.&lt;/p>
&lt;h2 id="assumptions">Assumptions&lt;/h2>
&lt;p>In this post, I&amp;rsquo;m assuming:&lt;/p>
&lt;ul>
&lt;li>You&amp;rsquo;re using the ML2 plugin for Neutron.&lt;/li>
&lt;li>You&amp;rsquo;re using the Open vSwitch mechanism driver for the ML2 plugin&lt;/li>
&lt;li>You have &lt;code>eth1&lt;/code> and &lt;code>eth2&lt;/code> connected directly to networks that you
would like to make available as external networks in OpenStack.&lt;/li>
&lt;/ul>
&lt;h2 id="create-your-bridges">Create your bridges&lt;/h2>
&lt;p>For each external network you wish to support, create a new OVS
bridge. For example, assuming that we want to make a network attached
to &lt;code>eth1&lt;/code> and a network attached to &lt;code>eth2&lt;/code> available to tenants:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-br br-eth1
# ovs-vsctl add-port br-eth1 eth1
# ovs-vsctl add-br br-eth2
# ovs-vsctl add-port br-eth2 eth2
&lt;/code>&lt;/pre>
&lt;p>Realistically, you would accomplish this via your system&amp;rsquo;s native
network configuration mechanism, but I&amp;rsquo;m going to gloss over that
detail for now.&lt;/p>
&lt;h2 id="configure-the-l3-agent">Configure the L3 Agent&lt;/h2>
&lt;p>Start with the following comment in &lt;code>l3_agent.ini&lt;/code>:&lt;/p>
&lt;pre>&lt;code># When external_network_bridge is set, each L3 agent can be associated
# with no more than one external network. This value should be set to the UUID
# of that external network. To allow L3 agent support multiple external
# networks, both the external_network_bridge and gateway_external_network_id
# must be left empty.
&lt;/code>&lt;/pre>
&lt;p>Following those instructions, make sure that both
&lt;code>external_network_bridge&lt;/code> and &lt;code>gateway_external_network_id&lt;/code> are unset
in &lt;code>l3_agent.ini&lt;/code>.&lt;/p>
&lt;h2 id="configure-the-ml2-plugin">Configure the ML2 Plugin&lt;/h2>
&lt;p>We are creating &amp;ldquo;flat&amp;rdquo; networks in this example, so we need to make
sure that we can create flat networks. Make sure that the
&lt;code>type_drivers&lt;/code> parameter of the &lt;code>[ml2]&lt;/code> section of your plugin
configuration includes &lt;code>flat&lt;/code>:&lt;/p>
&lt;pre>&lt;code>[ml2]
type_drivers = local,flat,gre,vxlan
&lt;/code>&lt;/pre>
&lt;p>In the &lt;code>[ml2_type_flat]&lt;/code> section, need to create a list of physical
network names that can be used to create flat networks. If you want
all physical networks to be available for flat networks, you can use
&lt;code>*&lt;/code>:&lt;/p>
&lt;pre>&lt;code>[ml2_type_flat]
flat_networks = *
&lt;/code>&lt;/pre>
&lt;p>Both of these changes probably go in &lt;code>/etc/neutron/plugin.ini&lt;/code>, but
&lt;em>may&lt;/em> going elsewhere depending on how your system is configured.&lt;/p>
&lt;h2 id="configure-the-open-vswitch-agent">Configure the Open vSwitch Agent&lt;/h2>
&lt;p>For each bridge, you will need to add entries to both the
&lt;code>network_vlan_ranges&lt;/code> and &lt;code>bridge_mappings&lt;/code> parameters of the &lt;code>[ovs]&lt;/code>
section of your plugin configuration. For the purposes of this post,
that means:&lt;/p>
&lt;pre>&lt;code>[ovs]
network_vlan_ranges = physnet1,physnet2
bridge_mappings = physnet1:br-eth1,physnet2:br-eth2
&lt;/code>&lt;/pre>
&lt;p>This will probably go in &lt;code>/etc/neutron/plugin.ini&lt;/code>. Specifically, it
needs to go wherever your &lt;code>neutron-openvswitch-agent&lt;/code> process is
looking for configuration information. So you if you see this:&lt;/p>
&lt;pre>&lt;code>$ ps -fe | grep openvswitch-agent
neutron 12529 1 0 09:50 ? 00:00:08 /usr/bin/python /usr/bin/neutron-openvswitch-agent --config-file /usr/share/neutron/neutron-dist.conf --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugins/openvswitch/ovs_neutron_plugin.ini --log-file /var/log/neutron/openvswitch-agent.log
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;then you would make the changes to &lt;code>/etc/neutron/plugins/openvswitch/ovs_neutron_plugin.ini&lt;/code>.&lt;/p>
&lt;h2 id="restart-neutron">Restart Neutron&lt;/h2>
&lt;p>You will need to restart both the l3 agent and the openvswitch agent.
If you&amp;rsquo;re on a recent Fedora/RHEL/CentOS, you can restart all Neutron
services like this:&lt;/p>
&lt;pre>&lt;code># openstack-service restart neutron
&lt;/code>&lt;/pre>
&lt;h2 id="inspect-your-open-vswitch-configuration">Inspect your Open vSwitch Configuration&lt;/h2>
&lt;p>As root, run &lt;code>ovs-vsctl show&lt;/code>. You should see something like this:&lt;/p>
&lt;pre>&lt;code>f4a4312b-307e-4c3c-b728-9434000a34ff
Bridge br-int
Port br-int
Interface br-int
type: internal
Port &amp;quot;int-br-eth2&amp;quot;
Interface &amp;quot;int-br-eth2&amp;quot;
Port int-br-ex
Interface int-br-ex
Port &amp;quot;int-br-eth1&amp;quot;
Interface &amp;quot;int-br-eth1&amp;quot;
Bridge &amp;quot;br-eth2&amp;quot;
Port &amp;quot;br-eth2&amp;quot;
Interface &amp;quot;br-eth2&amp;quot;
type: internal
Port &amp;quot;phy-br-eth2&amp;quot;
Interface &amp;quot;phy-br-eth2&amp;quot;
Port &amp;quot;eth2&amp;quot;
Interface &amp;quot;eth2&amp;quot;
Bridge &amp;quot;br-eth1&amp;quot;
Port &amp;quot;br-eth1&amp;quot;
Interface &amp;quot;br-eth1&amp;quot;
type: internal
Port &amp;quot;phy-br-eth1&amp;quot;
Interface &amp;quot;phy-br-eth1&amp;quot;
Port &amp;quot;eth1&amp;quot;
Interface &amp;quot;eth1&amp;quot;
ovs_version: &amp;quot;2.0.1&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Here you can see the OVS bridge &lt;code>br-eth1&lt;/code> and &lt;code>br-eth2&lt;/code>, each with the
appropriate associated physical interface and links to the integration
bridge, &lt;code>br-int&lt;/code>.&lt;/p>
&lt;h2 id="create-your-external-networks">Create your external networks&lt;/h2>
&lt;p>With admin credentials, use the &lt;code>net-create&lt;/code> and &lt;code>subnet-create&lt;/code>
commands to create the appropiate networks:&lt;/p>
&lt;pre>&lt;code>$ neutron net-create external1 -- --router:external=true \
--provider:network_type=flat \
--provider:physical_network=physnet1
+---------------------------+--------------------------------------+
| Field | Value |
+---------------------------+--------------------------------------+
| admin_state_up | True |
| id | 23f4b5f6-14fd-4bab-a8b0-445257bbc0d1 |
| name | external1 |
| provider:network_type | flat |
| provider:physical_network | physnet1 |
| provider:segmentation_id | |
| router:external | True |
| shared | False |
| status | ACTIVE |
| subnets | |
| tenant_id | 6f736b1361b74789a81d4d53d88be3c5 |
+---------------------------+--------------------------------------+
$ neutron subnet-create --disable-dhcp external1 10.1.0.0/24
+------------------+--------------------------------------------+
| Field | Value |
+------------------+--------------------------------------------+
| allocation_pools | {&amp;quot;start&amp;quot;: &amp;quot;10.1.0.2&amp;quot;, &amp;quot;end&amp;quot;: &amp;quot;10.1.0.254&amp;quot;} |
| cidr | 10.1.0.0/24 |
| dns_nameservers | |
| enable_dhcp | False |
| gateway_ip | 10.1.0.1 |
| host_routes | |
| id | 363ba289-a989-4acb-ac3b-ffaeb90796fc |
| ip_version | 4 |
| name | |
| network_id | 23f4b5f6-14fd-4bab-a8b0-445257bbc0d1 |
| tenant_id | 6f736b1361b74789a81d4d53d88be3c5 |
+------------------+--------------------------------------------+
$ neutron net-create external2 -- --router:external=true \
--provider:network_type=flat \
--provider:physical_network=physnet2
+---------------------------+--------------------------------------+
| Field | Value |
+---------------------------+--------------------------------------+
| admin_state_up | True |
| id | 762be5de-31a2-46b8-925c-0967871f8181 |
| name | external2 |
| provider:network_type | flat |
| provider:physical_network | physnet2 |
| provider:segmentation_id | |
| router:external | True |
| shared | False |
| status | ACTIVE |
| subnets | |
| tenant_id | 6f736b1361b74789a81d4d53d88be3c5 |
+---------------------------+--------------------------------------+
$ neutron subnet-create --disable-dhcp external2 10.2.0.0/24
+------------------+--------------------------------------------+
| Field | Value |
+------------------+--------------------------------------------+
| allocation_pools | {&amp;quot;start&amp;quot;: &amp;quot;10.2.0.2&amp;quot;, &amp;quot;end&amp;quot;: &amp;quot;10.2.0.254&amp;quot;} |
| cidr | 10.2.0.0/24 |
| dns_nameservers | |
| enable_dhcp | False |
| gateway_ip | 10.2.0.1 |
| host_routes | |
| id | edffc5c6-0e16-4da0-8eba-9d79ab9fd2fe |
| ip_version | 4 |
| name | |
| network_id | 762be5de-31a2-46b8-925c-0967871f8181 |
| tenant_id | 6f736b1361b74789a81d4d53d88be3c5 |
+------------------+--------------------------------------------+
&lt;/code>&lt;/pre>
&lt;p>This assumes that &lt;code>eth1&lt;/code> is connected to a network using
&lt;code>10.1.0.0/24&lt;/code> and &lt;code>eth2&lt;/code> is connected to a network using
&lt;code>10.2.0.0/24&lt;/code>, and that each network has a gateway sitting at the
corresponding &lt;code>.1&lt;/code> address.&lt;/p>
&lt;p>And you&amp;rsquo;re all set!&lt;/p></content></item><item><title>Video: Configuring OpenStack's external bridge on a single-interface system</title><link>https://blog.oddbit.com/post/2014-05-27-configuring-openstacks-externa/</link><pubDate>Tue, 27 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-27-configuring-openstacks-externa/</guid><description>&lt;p>I&amp;rsquo;ve just put a video on Youtube that looks at the steps required to
set up the external bridge (&lt;code>br-ex&lt;/code>) on a single-interface system:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/8zFQG5mKwPk?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div></description><content>&lt;p>I&amp;rsquo;ve just put a video on Youtube that looks at the steps required to
set up the external bridge (&lt;code>br-ex&lt;/code>) on a single-interface system:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/8zFQG5mKwPk?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div></content></item><item><title>Open vSwitch and persistent MAC addresses</title><link>https://blog.oddbit.com/post/2014-05-23-open-vswitch-and-persistent-ma/</link><pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-23-open-vswitch-and-persistent-ma/</guid><description>&lt;p>Normally I like to post solutions, but today&amp;rsquo;s post is about a
vexing problem to which I have not been able to find a solution.&lt;/p>
&lt;p>This started as a simple attempt to set up external connectivity on
an all-in-one Icehouse install deployed on an OpenStack instance. I
wanted to add &lt;code>eth0&lt;/code> to &lt;code>br-ex&lt;/code> in order to model a typical method for
providing external connectivity, but I ran into a very odd problem:
the system would boot and work fine for a few seconds, but would then
promptly lose network connectivity.&lt;/p></description><content>&lt;p>Normally I like to post solutions, but today&amp;rsquo;s post is about a
vexing problem to which I have not been able to find a solution.&lt;/p>
&lt;p>This started as a simple attempt to set up external connectivity on
an all-in-one Icehouse install deployed on an OpenStack instance. I
wanted to add &lt;code>eth0&lt;/code> to &lt;code>br-ex&lt;/code> in order to model a typical method for
providing external connectivity, but I ran into a very odd problem:
the system would boot and work fine for a few seconds, but would then
promptly lose network connectivity.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>The immediate cause was that the MAC address on &lt;code>br-ex&lt;/code> was changing.
I was setting the MAC explicitly in the configuration file:&lt;/p>
&lt;pre>&lt;code># cat ifcfg-br-ex
DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
OVSBOOTPROTO=dhcp
OVSDHCPINTERFACES=eth0
MACADDR=fa:16:3e:ef:91:ec
&lt;/code>&lt;/pre>
&lt;p>This was required in this case in order to make the MAC-address
filters on the host happy. When booting an instance, Neutron sets up
a rule like this:&lt;/p>
&lt;pre>&lt;code>-A neutron-openvswi-s55439d7d-a -s 10.0.0.8/32 -m mac --mac-source FA:16:3E:EF:91:EC -j RETURN
-A neutron-openvswi-s55439d7d-a -j DROP
&lt;/code>&lt;/pre>
&lt;p>But things quickly got weird. Some testing demonstrated that the MAC
address was changing when starting &lt;code>neutron-openvswitch-agent&lt;/code>, but a
thorough inspection of the code didn&amp;rsquo;t yield any obvious culprits for
this behavior.&lt;/p>
&lt;p>I liberally sprinkled the agent with the following (incrementing the
argument to &lt;code>echo&lt;/code> each time to uniquely identify each message):&lt;/p>
&lt;pre>&lt;code>os.system('echo 1 &amp;gt;&amp;gt; /tmp/ovs.log; ip link show dev br-ex &amp;gt;&amp;gt; /tmp/ovs.log')
&lt;/code>&lt;/pre>
&lt;p>It turns out that the MAC address on &lt;code>br-ex&lt;/code> was changing&amp;hellip;when
Neutron was deleting a port on &lt;code>br-int&lt;/code>. Specifically, at &lt;a href="https://github.com/openstack/neutron/blob/423ca756af10e10398636d6d34a7594a4fd4bc87/neutron/plugins/openvswitch/agent/ovs_neutron_agent.py#L909">this
line&lt;/a> in &lt;code>ovs_neutron_agent.py&lt;/code>:&lt;/p>
&lt;pre>&lt;code>self.int_br.delete_port(int_veth_name)
&lt;/code>&lt;/pre>
&lt;p>After some additional testing, it turns out that just about &lt;em>any&lt;/em> OVS
operation causes an explicit MAC address to disappear. For example,
create a new OVS bridge:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-br br-test0
# ip link show dev br-test0
9: br-test0: &amp;lt;BROADCAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether ba:cb:48:b9:6a:43 brd ff:ff:ff:ff:ff:ff
&lt;/code>&lt;/pre>
&lt;p>Then set the MAC address:&lt;/p>
&lt;pre>&lt;code># ip link set br-test0 addr c0:ff:ee:ee:ff:0c
# ip link show br-test0
8: br-test0: &amp;lt;BROADCAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether c0:ff:ee:ee:ff:0c brd ff:ff:ff:ff:ff:ff
&lt;/code>&lt;/pre>
&lt;p>Now create a new bridge:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-br br-test1
&lt;/code>&lt;/pre>
&lt;p>And inspect the MAC address on the first bridge:&lt;/p>
&lt;pre>&lt;code># ip link show dev br-test0
9: br-test0: &amp;lt;BROADCAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether ba:cb:48:b9:6a:43 brd ff:ff:ff:ff:ff:ff
&lt;/code>&lt;/pre>
&lt;p>In other words, creating a new bridge caused the MAC address on
&lt;code>br-ex&lt;/code> to revert. Other operations (e.g., deleting a port on an
unrelated switch) will cause the same behavior.&lt;/p>
&lt;p>I&amp;rsquo;ve seen this behavior on both versions &lt;code>1.11.0&lt;/code> and &lt;code>2.0.1&lt;/code>.&lt;/p>
&lt;p>So far everyone I&amp;rsquo;ve asked about this behavior has been stumped. If I
am able to figure out what&amp;rsquo;s going on I will update this post. Thanks
for reading!&lt;/p></content></item><item><title>Solved: Open vSwitch and persistent MAC addresses</title><link>https://blog.oddbit.com/post/2014-05-23-solved-open-vswitch-and-persis/</link><pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-23-solved-open-vswitch-and-persis/</guid><description>&lt;p>In my &lt;a href="https://blog.oddbit.com/2014/05/23/open-vswitch-and-persistent-ma/">previous post&lt;/a> I discussed a problem I was having setting a
persistent MAC address on an OVS bridge device. It looks like the
short answer is, &amp;ldquo;don&amp;rsquo;t use &lt;code>ip link set ...&lt;/code>&amp;rdquo; for this purpose.&lt;/p>
&lt;p>You can set the bridge MAC address via &lt;code>ovs-vsctl&lt;/code> like this:&lt;/p>
&lt;pre>&lt;code>ovs-vsctl set bridge br-ex other-config:hwaddr=$MACADDR
&lt;/code>&lt;/pre>
&lt;p>So I&amp;rsquo;ve updated my &lt;code>ifconfig-br-ex&lt;/code> to look like this:&lt;/p>
&lt;pre>&lt;code>DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
OVSBOOTPROTO=dhcp
OVSDHCPINTERFACES=eth0
MACADDR=fa:16:3e:ef:91:ec
OVS_EXTRA=&amp;quot;set bridge br-ex other-config:hwaddr=$MACADDR&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>OVS_EXTRA&lt;/code> parameter gets passed to the &lt;code>add-br&lt;/code> call like this:&lt;/p></description><content>&lt;p>In my &lt;a href="https://blog.oddbit.com/2014/05/23/open-vswitch-and-persistent-ma/">previous post&lt;/a> I discussed a problem I was having setting a
persistent MAC address on an OVS bridge device. It looks like the
short answer is, &amp;ldquo;don&amp;rsquo;t use &lt;code>ip link set ...&lt;/code>&amp;rdquo; for this purpose.&lt;/p>
&lt;p>You can set the bridge MAC address via &lt;code>ovs-vsctl&lt;/code> like this:&lt;/p>
&lt;pre>&lt;code>ovs-vsctl set bridge br-ex other-config:hwaddr=$MACADDR
&lt;/code>&lt;/pre>
&lt;p>So I&amp;rsquo;ve updated my &lt;code>ifconfig-br-ex&lt;/code> to look like this:&lt;/p>
&lt;pre>&lt;code>DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
OVSBOOTPROTO=dhcp
OVSDHCPINTERFACES=eth0
MACADDR=fa:16:3e:ef:91:ec
OVS_EXTRA=&amp;quot;set bridge br-ex other-config:hwaddr=$MACADDR&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>OVS_EXTRA&lt;/code> parameter gets passed to the &lt;code>add-br&lt;/code> call like this:&lt;/p>
&lt;pre>&lt;code>ovs-vsctl --may-exist add-br br-ex -- set bridge br-ex other-config:hwaddr=$MACADDR
&lt;/code>&lt;/pre>
&lt;p>And unlike using &lt;code>ip link set&lt;/code>, this seems to stick.&lt;/p></content></item><item><title>Fedora and OVS Bridge Interfaces</title><link>https://blog.oddbit.com/post/2014-05-20-fedora-and-ovs-bridge-interfac/</link><pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-20-fedora-and-ovs-bridge-interfac/</guid><description>&lt;p>I run OpenStack on my laptop, and I&amp;rsquo;ve been chasing down a pernicious
problem with OVS bridge interfaces under both F19 and F20. My
OpenStack environment relies on an OVS bridge device named &lt;code>br-ex&lt;/code> for
external connectivity and for making services available to OpenStack
instances, but after rebooting, &lt;code>br-ex&lt;/code> was consistently unconfigured,
which caused a variety of problems.&lt;/p>
&lt;p>This is the network configuration file for &lt;code>br-ex&lt;/code> on my system:&lt;/p>
&lt;pre>&lt;code>DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
BOOTPROT=static
IPADDR=192.168.200.1
NETMASK=255.255.255.0
ONBOOT=yes
NM_CONTROLLED=no
ZONE=openstack
&lt;/code>&lt;/pre>
&lt;p>Running &lt;code>ifup br-ex&lt;/code> would also fail to configure the interface, but
running &lt;code>ifdown br-ex; ifup br-ex&lt;/code> would configure things
appropriately.&lt;/p></description><content>&lt;p>I run OpenStack on my laptop, and I&amp;rsquo;ve been chasing down a pernicious
problem with OVS bridge interfaces under both F19 and F20. My
OpenStack environment relies on an OVS bridge device named &lt;code>br-ex&lt;/code> for
external connectivity and for making services available to OpenStack
instances, but after rebooting, &lt;code>br-ex&lt;/code> was consistently unconfigured,
which caused a variety of problems.&lt;/p>
&lt;p>This is the network configuration file for &lt;code>br-ex&lt;/code> on my system:&lt;/p>
&lt;pre>&lt;code>DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
BOOTPROT=static
IPADDR=192.168.200.1
NETMASK=255.255.255.0
ONBOOT=yes
NM_CONTROLLED=no
ZONE=openstack
&lt;/code>&lt;/pre>
&lt;p>Running &lt;code>ifup br-ex&lt;/code> would also fail to configure the interface, but
running &lt;code>ifdown br-ex; ifup br-ex&lt;/code> would configure things
appropriately.&lt;/p>
&lt;p>I finally got fed up with this behavior and spent some time chasing
down the problem, and this is what I found:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Calling &lt;code>ifup br-ex&lt;/code> passes control to
&lt;code>/etc/sysconfig/network-scripts/ifup-ovs&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ifup-ovs&lt;/code> calls the &lt;code>check_device_down&lt;/code> function from
&lt;code>network-functions&lt;/code>, which looks like:&lt;/p>
&lt;pre>&lt;code> check_device_down ()
{
[ ! -d /sys/class/net/$1 ] &amp;amp;&amp;amp; return 0
if LC_ALL=C ip -o link show dev $1 2&amp;gt;/dev/null | grep -q &amp;quot;,UP&amp;quot; ; then
return 1
else
return 0
fi
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>This returns failure (=1) if the interface flags contain &lt;code>,UP&lt;/code>.
Unfortunately, since information about this device is stored
persistently in &lt;code>ovsdb&lt;/code>, the device is already &lt;code>UP&lt;/code> when &lt;code>ifup&lt;/code> is
called, which causes &lt;code>ifup-ovs&lt;/code> to skip further device
configuration. The logic that calls &lt;code>check_device_down&lt;/code> looks like
this:&lt;/p>
&lt;pre>&lt;code>if check_device_down &amp;quot;${DEVICE}&amp;quot;; then
ovs-vsctl -t ${TIMEOUT} -- --may-exist add-br &amp;quot;$DEVICE&amp;quot; $OVS_OPTIONS \
${OVS_EXTRA+-- $OVS_EXTRA} \
${STP+-- set bridge &amp;quot;$DEVICE&amp;quot; stp_enable=&amp;quot;${STP}&amp;quot;}
else
OVSBRIDGECONFIGURED=&amp;quot;yes&amp;quot;
fi
&lt;/code>&lt;/pre>
&lt;p>This sets &lt;code>OVSBRIDGECONFIGURED&lt;/code> if it believes the device is &lt;code>UP&lt;/code>,
which causes &lt;code>ifup-ovs&lt;/code> to skip the call to &lt;code>ifup-eth&lt;/code> to configure
the interface:&lt;/p>
&lt;pre>&lt;code>if [ &amp;quot;${OVSBOOTPROTO}&amp;quot; != &amp;quot;dhcp&amp;quot; ] &amp;amp;&amp;amp; [ -z &amp;quot;${OVSINTF}&amp;quot; ] &amp;amp;&amp;amp; \
[ &amp;quot;${OVSBRIDGECONFIGURED}&amp;quot; != &amp;quot;yes&amp;quot; ]; then
${OTHERSCRIPT} ${CONFIG}
fi
&lt;/code>&lt;/pre>
&lt;p>I have found that the simplest solution to this problem is to disable
the logic that sets &lt;code>OVSBRIDGECONFIGURED&lt;/code>, by changing this:&lt;/p>
&lt;pre>&lt;code>else
OVSBRIDGECONFIGURED=&amp;quot;yes&amp;quot;
fi
&lt;/code>&lt;/pre>
&lt;p>To this:&lt;/p>
&lt;pre>&lt;code>else
: OVSBRIDGECONFIGURED=&amp;quot;yes&amp;quot;
fi
&lt;/code>&lt;/pre>
&lt;p>With this change in place, &lt;code>br-ex&lt;/code> is correctly configured after a
reboot.&lt;/p></content></item><item><title>Firewalld, NetworkManager, and OpenStack</title><link>https://blog.oddbit.com/post/2014-05-20-firewalld-and-openstack/</link><pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-20-firewalld-and-openstack/</guid><description>&lt;p>These are my notes on making OpenStack play well with &lt;a href="https://fedoraproject.org/wiki/FirewallD">firewalld&lt;/a>
and &lt;a href="https://wiki.gnome.org/Projects/NetworkManager">NetworkManager&lt;/a>.&lt;/p>
&lt;h2 id="networkmanager">NetworkManager&lt;/h2>
&lt;p>By default, NetworkManager attempts to start a DHCP client on every
new available interface. Since booting a single instance in OpenStack
can result in the creation of several virtual interfaces, this results
in a lot of:&lt;/p>
&lt;pre>&lt;code>May 19 11:58:24 pk115wp-lkellogg NetworkManager[1357]: &amp;lt;info&amp;gt;
Activation (qvb512640bd-ee) starting connection 'Wired connection 2'
&lt;/code>&lt;/pre>
&lt;p>You can disable this behavior by adding the following to
&lt;code>/etc/NetworkManager/NetworkManager.conf&lt;/code>:&lt;/p></description><content>&lt;p>These are my notes on making OpenStack play well with &lt;a href="https://fedoraproject.org/wiki/FirewallD">firewalld&lt;/a>
and &lt;a href="https://wiki.gnome.org/Projects/NetworkManager">NetworkManager&lt;/a>.&lt;/p>
&lt;h2 id="networkmanager">NetworkManager&lt;/h2>
&lt;p>By default, NetworkManager attempts to start a DHCP client on every
new available interface. Since booting a single instance in OpenStack
can result in the creation of several virtual interfaces, this results
in a lot of:&lt;/p>
&lt;pre>&lt;code>May 19 11:58:24 pk115wp-lkellogg NetworkManager[1357]: &amp;lt;info&amp;gt;
Activation (qvb512640bd-ee) starting connection 'Wired connection 2'
&lt;/code>&lt;/pre>
&lt;p>You can disable this behavior by adding the following to
&lt;code>/etc/NetworkManager/NetworkManager.conf&lt;/code>:&lt;/p>
&lt;pre>&lt;code>[main]
no-auto-default=*
&lt;/code>&lt;/pre>
&lt;p>From &lt;code>NetworkManager.conf(5)&lt;/code>:&lt;/p>
&lt;blockquote>
&lt;p>Comma-separated list of devices for which NetworkManager shouldn&amp;rsquo;t
create default wired connection (Auto eth0). By default,
NetworkManager creates a temporary wired connection for any
Ethernet device that is managed and doesn&amp;rsquo;t have a connection
configured. List a device in this option to inhibit creating the
default connection for the device. May have the special value * to
apply to all devices.&lt;/p>
&lt;/blockquote>
&lt;h2 id="firewalld">FirewallD&lt;/h2>
&lt;p>&lt;a href="https://fedoraproject.org/wiki/FirewallD">FirewallD&lt;/a> is the firewall manager recently introduced in Fedora
(and soon to be appearing in RHEL 7).&lt;/p>
&lt;p>I start by creating a new zone named &lt;code>openstack&lt;/code> by creating the file
&lt;code>/etc/firewalld/zones/openstack.xml&lt;/code> with the following content:&lt;/p>
&lt;pre>&lt;code>&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;zone&amp;gt;
&amp;lt;short&amp;gt;OpenStack&amp;lt;/short&amp;gt;
&amp;lt;description&amp;gt;For OpenStack services&amp;lt;/description&amp;gt;
&amp;lt;/zone&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>After populating this file, you need to run &lt;code>firewall-cmd --reload&lt;/code>
to make the zone available. Note that if you&amp;rsquo;re already running
OpenStack this will hose any rules set up by Neutron or Nova, so
you&amp;rsquo;ll probably want to restart those services:&lt;/p>
&lt;pre>&lt;code># openstack-service restart nova neutron
&lt;/code>&lt;/pre>
&lt;p>I then add &lt;code>br-ex&lt;/code> to this zone, where &lt;code>br-ex&lt;/code> is the OVS bridge my
OpenStack environment uses for external connectivity:&lt;/p>
&lt;pre>&lt;code># echo ZONE=openstack &amp;gt;&amp;gt; /etc/sysconfig/network-scripts/ifcfg-br-ex
&lt;/code>&lt;/pre>
&lt;p>I run a &lt;code>dnsmasq&lt;/code> instance on my laptop to which I expect OpenStack
instances to connect, so I need to add the &lt;code>dns&lt;/code> service to this zone:&lt;/p>
&lt;pre>&lt;code># firewall-cmd --zone openstack --add-service dns
# firewall-cmd --zone openstack --add-service dns --permanent
&lt;/code>&lt;/pre>
&lt;p>I&amp;rsquo;m running &lt;code>firewall-cmd&lt;/code> twice here: the first time modifies the
currently running configuration, while the second makes the change
persistent across reboots.&lt;/p>
&lt;p>On my laptop, I handle external connectivity through NAT rather than
placing floating ips on a &amp;ldquo;real&amp;rdquo; network. To make this work, I add my
ethernet and wireless interfaces to the &lt;code>external&lt;/code> zone, which already
has ip masquerading enabled, by adding a &lt;code>ZONE&lt;/code> directive to the
appropriate interface configuration file:&lt;/p>
&lt;pre>&lt;code># echo ZONE=external &amp;gt;&amp;gt; /etc/sysconfig/network-scripts/ifcfg-em1
&lt;/code>&lt;/pre>
&lt;p>After a reboot, things look like this:&lt;/p>
&lt;pre>&lt;code># firewall-cmd --get-active-zones
openstack
interfaces: br-ex
external
interfaces: em1
public
interfaces: int-br-ex phy-br-ex qvb58cc67ca-06 qvo58cc67ca-06
# firewall-cmd --zone openstack --list-services
dns
&lt;/code>&lt;/pre></content></item><item><title>Visualizing Neutron Networking with GraphViz</title><link>https://blog.oddbit.com/post/2013-12-23-visualizing-network-with-graph/</link><pubDate>Mon, 23 Dec 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-12-23-visualizing-network-with-graph/</guid><description>&lt;p>I&amp;rsquo;ve put together a few tools to help gather information about your
Neutron and network configuration and visualize it in different ways.
All of these tools are available as part of my &lt;a href="http://github.com/larsks/neutron-diag/">neutron-diag&lt;/a>
repository on GitHub.&lt;/p>
&lt;p>In this post I&amp;rsquo;m going to look at a tool that will help you visualize
the connectivity of network devices on your system.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="mk-network-dot">mk-network-dot&lt;/h2>
&lt;p>There are a lot of devices involved in your Neutron network
configuration. Information originating in one of your instances has
two traverse &lt;em>at least&lt;/em> seven network devices before seeing the light
of day. Understanding how everything connects is critical if you&amp;rsquo;re
trying to debug problems in your envionment.&lt;/p></description><content>&lt;p>I&amp;rsquo;ve put together a few tools to help gather information about your
Neutron and network configuration and visualize it in different ways.
All of these tools are available as part of my &lt;a href="http://github.com/larsks/neutron-diag/">neutron-diag&lt;/a>
repository on GitHub.&lt;/p>
&lt;p>In this post I&amp;rsquo;m going to look at a tool that will help you visualize
the connectivity of network devices on your system.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="mk-network-dot">mk-network-dot&lt;/h2>
&lt;p>There are a lot of devices involved in your Neutron network
configuration. Information originating in one of your instances has
two traverse &lt;em>at least&lt;/em> seven network devices before seeing the light
of day. Understanding how everything connects is critical if you&amp;rsquo;re
trying to debug problems in your envionment.&lt;/p>
&lt;p>The &lt;code>mk-network-dot&lt;/code> tool interrogates your system for information
about network devices and generates &lt;a href="http://en.wikipedia.org/wiki/DOT_%28graph_description_language%29">dot format&lt;/a> output showing how
everything connects. You can use &lt;a href="http://www.graphviz.org/">GraphViz&lt;/a> to render this into a
variety of output formats. The script must be run as &lt;code>root&lt;/code>, so I
usually do something like this:&lt;/p>
&lt;pre>&lt;code>sudo sh mk-network-dot | dot -Tsvg -o network.svg
&lt;/code>&lt;/pre>
&lt;p>The &lt;em>dot&lt;/em> language is a language designed for describing graphs, and
the syntax looks something like this:&lt;/p>
&lt;pre>&lt;code>digraph example {
A -&amp;gt; B
A -&amp;gt; C
C -&amp;gt; D
B -&amp;gt; D
}
&lt;/code>&lt;/pre>
&lt;p>Which would produce output like this:&lt;/p>
&lt;p>&lt;img alt="Dot output example" src="https://blog.oddbit.com/post/2013-12-23-visualizing-network-with-graph/dot-example.svg">&lt;/p>
&lt;p>When run on my laptop, with a simple all-in-one configuration and five
instances across two networks, the result of running &lt;code>mk-network-dot&lt;/code>
looks like this:&lt;/p>
&lt;figure class="left" >
&lt;img src="network.svg" />
&lt;/figure>
&lt;p>There are a few caveats with this tool:&lt;/p>
&lt;ul>
&lt;li>As of this writing, it doesn&amp;rsquo;t know about either bond interfaces or
VLAN interfaces.&lt;/li>
&lt;li>It&amp;rsquo;s had only limited testing.&lt;/li>
&lt;/ul>
&lt;p>If you try this out and something doesn&amp;rsquo;t work as you expect, please
open a new issues on the &lt;a href="https://github.com/larsks/neutron-diag/issues">GitHub issues page&lt;/a>.&lt;/p></content></item><item><title>Quantum in Too Much Detail</title><link>https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/</link><pubDate>Thu, 14 Nov 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/</guid><description>&lt;blockquote>
&lt;p>I originally posted this article on
the &lt;a href="http://openstack.redhat.com/Networking_in_too_much_detail">RDO&lt;/a>
website.&lt;/p>
&lt;/blockquote>
&lt;h1 id="the-players">The players&lt;/h1>
&lt;p>This document describes the architecture that results from a
particular OpenStack configuration, specifically:&lt;/p>
&lt;ul>
&lt;li>Quantum networking using GRE tunnels;&lt;/li>
&lt;li>A dedicated network controller;&lt;/li>
&lt;li>A single instance running on a compute host&lt;/li>
&lt;/ul>
&lt;p>Much of the document will be relevant to other configurations, but
details will vary based on your choice of layer 2 connectivity, number
of running instances, and so forth.&lt;/p>
&lt;p>The examples in this document were generated on a system with Quantum
networking but will generally match what you see under Neutron as
well, if you replace &lt;code>quantum&lt;/code> by &lt;code>neutron&lt;/code> in names. The OVS flow
rules under Neutron are somewhat more complex and I will cover those
in another post.&lt;/p></description><content>&lt;blockquote>
&lt;p>I originally posted this article on
the &lt;a href="http://openstack.redhat.com/Networking_in_too_much_detail">RDO&lt;/a>
website.&lt;/p>
&lt;/blockquote>
&lt;h1 id="the-players">The players&lt;/h1>
&lt;p>This document describes the architecture that results from a
particular OpenStack configuration, specifically:&lt;/p>
&lt;ul>
&lt;li>Quantum networking using GRE tunnels;&lt;/li>
&lt;li>A dedicated network controller;&lt;/li>
&lt;li>A single instance running on a compute host&lt;/li>
&lt;/ul>
&lt;p>Much of the document will be relevant to other configurations, but
details will vary based on your choice of layer 2 connectivity, number
of running instances, and so forth.&lt;/p>
&lt;p>The examples in this document were generated on a system with Quantum
networking but will generally match what you see under Neutron as
well, if you replace &lt;code>quantum&lt;/code> by &lt;code>neutron&lt;/code> in names. The OVS flow
rules under Neutron are somewhat more complex and I will cover those
in another post.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h1 id="the-lay-of-the-land">The lay of the land&lt;/h1>
&lt;p>This is a simplified architecture diagram of network connectivity in a
quantum/neutron managed world:&lt;/p>
&lt;figure class="left" >
&lt;img src="quantum-gre.svg" />
&lt;/figure>
&lt;p>Section names in this document include
parenthetical references to the nodes on the map relevant to that
particular section.&lt;/p>
&lt;h1 id="compute-host-instance-networking-abc">Compute host: instance networking (A,B,C)&lt;/h1>
&lt;p>An outbound packet starts on &lt;code>eth0&lt;/code> of the virtual instance, which is
connected to a &lt;code>tap&lt;/code> device on the host, &lt;code>tap7c7ae61e-05&lt;/code>. This &lt;code>tap&lt;/code>
device is attached to a Linux bridge device, &lt;code>qbr7c7ae61e-05&lt;/code>. What is
this bridge device for? From the &lt;a href="http://docs.openstack.org/network-admin/admin/content/under_the_hood_openvswitch.html">OpenStack Networking Administration
Guide&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Ideally, the TAP device vnet0 would be connected directly to the
integration bridge, br-int. Unfortunately, this isn&amp;rsquo;t possible because
of how OpenStack security groups are currently implemented. OpenStack
uses iptables rules on the TAP devices such as vnet0 to implement
security groups, and Open vSwitch is not compatible with iptables
rules that are applied directly on TAP devices that are connected to
an Open vSwitch port.&lt;/p>
&lt;/blockquote>
&lt;p>Because this bridge device exists primarily to support firewall rules,
I&amp;rsquo;m going to refer to it as the &amp;ldquo;firewall bridge&amp;rdquo;.&lt;/p>
&lt;p>If you examine the firewall rules on your compute host, you will find
that there are several rules associated with this &lt;code>tap&lt;/code> device:&lt;/p>
&lt;pre>&lt;code># iptables -S | grep tap7c7ae61e-05
-A quantum-openvswi-FORWARD -m physdev --physdev-out tap7c7ae61e-05 --physdev-is-bridged -j quantum-openvswi-sg-chain
-A quantum-openvswi-FORWARD -m physdev --physdev-in tap7c7ae61e-05 --physdev-is-bridged -j quantum-openvswi-sg-chain
-A quantum-openvswi-INPUT -m physdev --physdev-in tap7c7ae61e-05 --physdev-is-bridged -j quantum-openvswi-o7c7ae61e-0
-A quantum-openvswi-sg-chain -m physdev --physdev-out tap7c7ae61e-05 --physdev-is-bridged -j quantum-openvswi-i7c7ae61e-0
-A quantum-openvswi-sg-chain -m physdev --physdev-in tap7c7ae61e-05 --physdev-is-bridged -j quantum-openvswi-o7c7ae61e-0
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>quantum-openvswi-sg-chain&lt;/code> is where &lt;code>neutron&lt;/code>-managed security
groups are realized. The &lt;code>quantum-openvswi-o7c7ae61e-0&lt;/code> chain
controls outbound traffic FROM the instance, and by default looks like
this:&lt;/p>
&lt;pre>&lt;code>-A quantum-openvswi-o7c7ae61e-0 -m mac ! --mac-source FA:16:3E:03:00:E7 -j DROP
-A quantum-openvswi-o7c7ae61e-0 -p udp -m udp --sport 68 --dport 67 -j RETURN
-A quantum-openvswi-o7c7ae61e-0 ! -s 10.1.0.2/32 -j DROP
-A quantum-openvswi-o7c7ae61e-0 -p udp -m udp --sport 67 --dport 68 -j DROP
-A quantum-openvswi-o7c7ae61e-0 -m state --state INVALID -j DROP
-A quantum-openvswi-o7c7ae61e-0 -m state --state RELATED,ESTABLISHED -j RETURN
-A quantum-openvswi-o7c7ae61e-0 -j RETURN
-A quantum-openvswi-o7c7ae61e-0 -j quantum-openvswi-sg-fallback
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>quantum-openvswi-i7c7ae61e-0&lt;/code> chain controls inbound traffic TO
the instance. After opening up port 22 in the default security group:&lt;/p>
&lt;pre>&lt;code># neutron security-group-rule-create --protocol tcp \
--port-range-min 22 --port-range-max 22 --direction ingress default
&lt;/code>&lt;/pre>
&lt;p>The rules look like this:&lt;/p>
&lt;pre>&lt;code>-A quantum-openvswi-i7c7ae61e-0 -m state --state INVALID -j DROP
-A quantum-openvswi-i7c7ae61e-0 -m state --state RELATED,ESTABLISHED -j RETURN
-A quantum-openvswi-i7c7ae61e-0 -p icmp -j RETURN
-A quantum-openvswi-i7c7ae61e-0 -p tcp -m tcp --dport 22 -j RETURN
-A quantum-openvswi-i7c7ae61e-0 -p tcp -m tcp --dport 80 -j RETURN
-A quantum-openvswi-i7c7ae61e-0 -s 10.1.0.3/32 -p udp -m udp --sport 67 --dport 68 -j RETURN
-A quantum-openvswi-i7c7ae61e-0 -j quantum-openvswi-sg-fallback
&lt;/code>&lt;/pre>
&lt;p>A second interface attached to the bridge, &lt;code>qvb7c7ae61e-05&lt;/code>, attaches
the firewall bridge to the integration bridge, typically named
&lt;code>br-int&lt;/code>.&lt;/p>
&lt;h1 id="compute-host-integration-bridge-de">Compute host: integration bridge (D,E)&lt;/h1>
&lt;p>The integration bridge, &lt;code>br-int&lt;/code>, performs VLAN tagging and un-tagging
for traffic coming from and to your instances. At this moment,
&lt;code>br-int&lt;/code> looks something like this:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl show
Bridge br-int
Port &amp;quot;qvo7c7ae61e-05&amp;quot;
tag: 1
Interface &amp;quot;qvo7c7ae61e-05&amp;quot;
Port patch-tun
Interface patch-tun
type: patch
options: {peer=patch-int}
Port br-int
Interface br-int
type: internal
&lt;/code>&lt;/pre>
&lt;p>The interface &lt;code>qvo7c7ae61e-05&lt;/code> is the other end of &lt;code>qvb7c7ae61e-05&lt;/code>,
and carries traffic to and from the firewall bridge. The &lt;code>tag: 1&lt;/code> you
see in the above output integrates that this is an access port
attached to VLAN 1. Untagged outbound traffic from this instance will be
assigned VLAN ID 1, and inbound traffic with VLAN ID 1 will
stripped of it&amp;rsquo;s VLAN tag and sent out this port.&lt;/p>
&lt;p>Each network you create (with &lt;code>neutron net-create&lt;/code>) will be assigned a
different VLAN ID.&lt;/p>
&lt;p>The interface named &lt;code>patch-tun&lt;/code> connects the integration bridge to the
tunnel bridge, &lt;code>br-tun&lt;/code>.&lt;/p>
&lt;h1 id="compute-host-tunnel-bridge-fg">Compute host: tunnel bridge (F,G)&lt;/h1>
&lt;p>The tunnel bridge translates VLAN-tagged traffic from the
integration bridge into &lt;code>GRE&lt;/code> tunnels. The translation between VLAN
IDs and tunnel IDs is performed by OpenFlow rules installed on
&lt;code>br-tun&lt;/code>. Before creating any instances, the flow rules on the bridge
look like this:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl dump-flows br-tun
NXST_FLOW reply (xid=0x4):
cookie=0x0, duration=871.283s, table=0, n_packets=4, n_bytes=300, idle_age=862, priority=1 actions=drop
&lt;/code>&lt;/pre>
&lt;p>There is a single rule that causes the bridge to drop all traffic.
Afrer you boot an instance on this compute node, the rules are
modified to look something like:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl dump-flows br-tun
NXST_FLOW reply (xid=0x4):
cookie=0x0, duration=422.158s, table=0, n_packets=2, n_bytes=120, idle_age=55, priority=3,tun_id=0x2,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00 actions=mod_vlan_vid:1,output:1
cookie=0x0, duration=421.948s, table=0, n_packets=64, n_bytes=8337, idle_age=31, priority=3,tun_id=0x2,dl_dst=fa:16:3e:dd:c1:62 actions=mod_vlan_vid:1,NORMAL
cookie=0x0, duration=422.357s, table=0, n_packets=82, n_bytes=10443, idle_age=31, priority=4,in_port=1,dl_vlan=1 actions=set_tunnel:0x2,NORMAL
cookie=0x0, duration=1502.657s, table=0, n_packets=8, n_bytes=596, idle_age=423, priority=1 actions=drop
&lt;/code>&lt;/pre>
&lt;p>In general, these rules are responsible for mapping traffic between
VLAN ID 1, used by the integration bridge, and tunnel id 2, used by
the GRE tunnel.&lt;/p>
&lt;p>The first rule&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cookie=0x0, duration=422.158s, table=0, n_packets=2, n_bytes=120, idle_age=55, priority=3,tun_id=0x2,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00 actions=mod_vlan_vid:1,output:1
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;matches all multicast traffic (see &lt;a href="http://openvswitch.org/cgi-bin/ovsman.cgi?page=utilities%2Fovs-ofctl.8">ovs-ofctl(8)&lt;/a>)
on tunnel id 2 (&lt;code>tun_id=0x2&lt;/code>), tags the ethernet frame with VLAN ID
1 (&lt;code>actions=mod_vlan_vid:1&lt;/code>), and sends it out port 1. We can see
from &lt;code>ovs-ofctl show br-tun&lt;/code> that port 1 is &lt;code>patch-int&lt;/code>:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl show br-tun
OFPT_FEATURES_REPLY (xid=0x2): dpid:0000068df4e44a49
n_tables:254, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: OUTPUT SET_VLAN_VID SET_VLAN_PCP STRIP_VLAN SET_DL_SRC SET_DL_DST SET_NW_SRC SET_NW_DST SET_NW_TOS SET_TP_SRC SET_TP_DST ENQUEUE
1(patch-int): addr:46:3d:59:17:df:62
config: 0
state: 0
speed: 0 Mbps now, 0 Mbps max
2(gre-2): addr:a2:5f:a1:92:29:02
config: 0
state: 0
speed: 0 Mbps now, 0 Mbps max
LOCAL(br-tun): addr:06:8d:f4:e4:4a:49
config: 0
state: 0
speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (xid=0x4): frags=normal miss_send_len=0
&lt;/code>&lt;/pre>
&lt;p>The next rule&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cookie=0x0, duration=421.948s, table=0, n_packets=64, n_bytes=8337, idle_age=31, priority=3,tun_id=0x2,dl_dst=fa:16:3e:dd:c1:62 actions=mod_vlan_vid:1,NORMAL
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;matches traffic coming in on tunnel 2 (&lt;code>tun_id=0x2&lt;/code>) with an
ethernet destination of &lt;code>fa:16:3e:dd:c1:62&lt;/code>
(&lt;code>dl_dst=fa:16:3e:dd:c1:62&lt;/code>) and tags the ethernet frame with VLAN
ID 1 (&lt;code>actions=mod_vlan_vid:1&lt;/code>) before sending it out &lt;code>patch-int&lt;/code>.&lt;/p>
&lt;p>The following rule&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cookie=0x0, duration=422.357s, table=0, n_packets=82, n_bytes=10443, idle_age=31, priority=4,in_port=1,dl_vlan=1 actions=set_tunnel:0x2,NORMAL
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;matches traffic coming in on port 1 (&lt;code>in_port=1&lt;/code>) with VLAN ID 1
(&lt;code>dl_vlan=1&lt;/code>) and set the tunnel id to 2 (&lt;code>actions=set_tunnel:0x2&lt;/code>)
before sending it out the GRE tunnel.&lt;/p>
&lt;h1 id="network-host-tunnel-bridge-hi">Network host: tunnel bridge (H,I)&lt;/h1>
&lt;p>Traffic arrives on the network host via the GRE tunnel attached to
&lt;code>br-tun&lt;/code>. This bridge has a flow table very similar to &lt;code>br-tun&lt;/code> on
the compute host:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl dump-flows br-tun
NXST_FLOW reply (xid=0x4):
cookie=0x0, duration=1239.229s, table=0, n_packets=23, n_bytes=4246, idle_age=15, priority=3,tun_id=0x2,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00 actions=mod_vlan_vid:1,output:1
cookie=0x0, duration=524.477s, table=0, n_packets=15, n_bytes=3498, idle_age=10, priority=3,tun_id=0x2,dl_dst=fa:16:3e:83:69:cc actions=mod_vlan_vid:1,NORMAL
cookie=0x0, duration=1239.157s, table=0, n_packets=50, n_bytes=4565, idle_age=148, priority=3,tun_id=0x2,dl_dst=fa:16:3e:aa:99:3c actions=mod_vlan_vid:1,NORMAL
cookie=0x0, duration=1239.304s, table=0, n_packets=76, n_bytes=9419, idle_age=10, priority=4,in_port=1,dl_vlan=1 actions=set_tunnel:0x2,NORMAL
cookie=0x0, duration=1527.016s, table=0, n_packets=12, n_bytes=880, idle_age=527, priority=1 actions=drop
&lt;/code>&lt;/pre>
&lt;p>As on the compute host, the first rule maps multicast traffic on
tunnel ID 2 to VLAN 1.&lt;/p>
&lt;p>The second rule&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cookie=0x0, duration=524.477s, table=0, n_packets=15, n_bytes=3498, idle_age=10, priority=3,tun_id=0x2,dl_dst=fa:16:3e:83:69:cc actions=mod_vlan_vid:1,NORMAL
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;matches traffic on the tunnel destined for the DHCP server at
&lt;code>fa:16:3e:83:69:cc&lt;/code>. This is a &lt;code>dnsmasq&lt;/code> process running inside a
network namespace, the details of which we will examine shortly.&lt;/p>
&lt;p>The next rule&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cookie=0x0, duration=1239.157s, table=0, n_packets=50, n_bytes=4565, idle_age=148, priority=3,tun_id=0x2,dl_dst=fa:16:3e:aa:99:3c actions=mod_vlan_vid:1,NORMAL
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;matches traffic on tunnel ID 2 destined for the router at &lt;code>fa:16:3e:aa:99:3c&lt;/code>, which is an interface in another network namespace.&lt;/p>
&lt;p>The following rule&amp;hellip;&lt;/p>
&lt;pre>&lt;code> cookie=0x0, duration=1239.304s, table=0, n_packets=76, n_bytes=9419, idle_age=10, priority=4,in_port=1,dl_vlan=1 actions=set_tunnel:0x2,NORMAL
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip;simply maps outbound traffic on VLAN ID 1 to tunnel ID 2.&lt;/p>
&lt;h1 id="network-host-integration-bridge-jkm">Network host: integration bridge (J,K,M)&lt;/h1>
&lt;p>The integration bridge on the network controller serves to connect
instances to network services, such as routers and DHCP servers.&lt;/p>
&lt;pre>&lt;code># ovs-vsctl show
.
.
.
Bridge br-int
Port patch-tun
Interface patch-tun
type: patch
options: {peer=patch-int}
Port &amp;quot;tapf14c598d-98&amp;quot;
tag: 1
Interface &amp;quot;tapf14c598d-98&amp;quot;
Port br-int
Interface br-int
type: internal
Port &amp;quot;tapc2d7dd02-56&amp;quot;
tag: 1
Interface &amp;quot;tapc2d7dd02-56&amp;quot;
.
.
.
&lt;/code>&lt;/pre>
&lt;p>It connects to the tunnel bridge, &lt;code>br-tun&lt;/code>, via a patch interface,
&lt;code>patch-tun&lt;/code>.&lt;/p>
&lt;h1 id="network-host-dhcp-server-m">Network host: DHCP server (M)&lt;/h1>
&lt;p>Each network for which DHCP is enabled has a DHCP server running on
the network controller. The DHCP server is an instance of &lt;a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq&lt;/a>
running inside a &lt;em>network namespace&lt;/em>. A &lt;em>network namespace&lt;/em> is a
Linux kernel facility that allows groups of processes to have a
network stack (interfaces, routing tables, iptables rules) distinct
from that of the host.&lt;/p>
&lt;p>You can see a list of network namespace with the &lt;code>ip netns&lt;/code> command,
which in our configuration will look something like this:&lt;/p>
&lt;pre>&lt;code># ip netns
qdhcp-88b1609c-68e0-49ca-a658-f1edff54a264
qrouter-2d214fde-293c-4d64-8062-797f80ae2d8f
&lt;/code>&lt;/pre>
&lt;p>The first of these (&lt;code>qdhcp...&lt;/code>) is the DHCP server namespace for our private
subnet, while the second (&lt;code>qrouter...&lt;/code>) is the router.&lt;/p>
&lt;p>You can run a command inside a network namespace using the &lt;code>ip netns exec&lt;/code> command. For example, to see the interface configuration inside
the DHCP server namespace (&lt;code>lo&lt;/code> removed for brevity):&lt;/p>
&lt;pre>&lt;code># ip netns exec qdhcp-88b1609c-68e0-49ca-a658-f1edff54a264 ip addr
71: tapf14c598d-98: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
link/ether fa:16:3e:10:2f:03 brd ff:ff:ff:ff:ff:ff
inet 10.1.0.3/24 brd 10.1.0.255 scope global ns-f14c598d-98
inet6 fe80::f816:3eff:fe10:2f03/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>Note the MAC address on interface &lt;code>tapf14c598d-98&lt;/code>; this matches the MAC address in the flow rule we saw on the tunnel bridge.&lt;/p>
&lt;p>You can find the &lt;code>dnsmasq&lt;/code> process associated with this namespace by
search the output of &lt;code>ps&lt;/code> for the id (the number after &lt;code>qdhcp-&lt;/code> in the
namespace name):&lt;/p>
&lt;pre>&lt;code># ps -fe | grep 88b1609c-68e0-49ca-a658-f1edff54a264
nobody 23195 1 0 Oct26 ? 00:00:00 dnsmasq --no-hosts --no-resolv --strict-order --bind-interfaces --interface=ns-f14c598d-98 --except-interface=lo --pid-file=/var/lib/quantum/dhcp/88b1609c-68e0-49ca-a658-f1edff54a264/pid --dhcp-hostsfile=/var/lib/quantum/dhcp/88b1609c-68e0-49ca-a658-f1edff54a264/host --dhcp-optsfile=/var/lib/quantum/dhcp/88b1609c-68e0-49ca-a658-f1edff54a264/opts --dhcp-script=/usr/bin/quantum-dhcp-agent-dnsmasq-lease-update --leasefile-ro --dhcp-range=tag0,10.1.0.0,static,120s --conf-file= --domain=openstacklocal
root 23196 23195 0 Oct26 ? 00:00:00 dnsmasq --no-hosts --no-resolv --strict-order --bind-interfaces --interface=ns-f14c598d-98 --except-interface=lo --pid-file=/var/lib/quantum/dhcp/88b1609c-68e0-49ca-a658-f1edff54a264/pid --dhcp-hostsfile=/var/lib/quantum/dhcp/88b1609c-68e0-49ca-a658-f1edff54a264/host --dhcp-optsfile=/var/lib/quantum/dhcp/88b1609c-68e0-49ca-a658-f1edff54a264/opts --dhcp-script=/usr/bin/quantum-dhcp-agent-dnsmasq-lease-update --leasefile-ro --dhcp-range=tag0,10.1.0.0,static,120s --conf-file= --domain=openstacklocal
&lt;/code>&lt;/pre>
&lt;h1 id="network-host-router-kl">Network host: Router (K,L)&lt;/h1>
&lt;p>A router is a network namespace with a set of routing tables
and iptables rules that performs the routing between subnets. Recall
that we saw two network namespaces in our configuration:&lt;/p>
&lt;pre>&lt;code># ip netns
qdhcp-88b1609c-68e0-49ca-a658-f1edff54a264
qrouter-2d214fde-293c-4d64-8062-797f80ae2d8f
&lt;/code>&lt;/pre>
&lt;p>Using the &lt;code>ip netns exec&lt;/code> command, we can inspect the interfaces
associated with the router (&lt;code>lo&lt;/code> removed for brevity):&lt;/p>
&lt;pre>&lt;code># ip netns exec qrouter-2d214fde-293c-4d64-8062-797f80ae2d8f ip addr
66: qg-d48b49e0-aa: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
link/ether fa:16:3e:5c:a2:ac brd ff:ff:ff:ff:ff:ff
inet 172.24.4.227/28 brd 172.24.4.239 scope global qg-d48b49e0-aa
inet 172.24.4.228/32 brd 172.24.4.228 scope global qg-d48b49e0-aa
inet6 fe80::f816:3eff:fe5c:a2ac/64 scope link
valid_lft forever preferred_lft forever
68: qr-c2d7dd02-56: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
link/ether fa:16:3e:ea:64:6e brd ff:ff:ff:ff:ff:ff
inet 10.1.0.1/24 brd 10.1.0.255 scope global qr-c2d7dd02-56
inet6 fe80::f816:3eff:feea:646e/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>The first interface, &lt;code>qg-d48b49e0-aa&lt;/code>, connects the router to the
gateway set by the &lt;code>router-gateway-set&lt;/code> command. The second
interface, &lt;code>qr-c2d7dd02-56&lt;/code>, is what connects the router to the
integration bridge.&lt;/p>
&lt;p>Looking at the routing tables inside the router, we see that there is
a default gateway pointing to the &lt;code>.1&lt;/code> address of our external
network, and the expected network routes for directly attached
networks:&lt;/p>
&lt;pre>&lt;code># ip netns exec qrouter-2d214fde-293c-4d64-8062-797f80ae2d8f ip route
172.24.4.224/28 dev qg-d48b49e0-aa proto kernel scope link src 172.24.4.227
10.1.0.0/24 dev qr-c2d7dd02-56 proto kernel scope link src 10.1.0.1
default via 172.24.4.225 dev qg-d48b49e0-aa
&lt;/code>&lt;/pre>
&lt;p>The netfilter &lt;code>nat&lt;/code> table inside the router namespace is responsible
for associating floating IP addresses with your instances. For
example, after associating the address &lt;code>172.24.4.228&lt;/code> with our
instance, the &lt;code>nat&lt;/code> table looks like this:&lt;/p>
&lt;pre>&lt;code># ip netns exec qrouter-2d214fde-293c-4d64-8062-797f80ae2d8f iptables -t nat -S
-P PREROUTING ACCEPT
-P POSTROUTING ACCEPT
-P OUTPUT ACCEPT
-N quantum-l3-agent-OUTPUT
-N quantum-l3-agent-POSTROUTING
-N quantum-l3-agent-PREROUTING
-N quantum-l3-agent-float-snat
-N quantum-l3-agent-snat
-N quantum-postrouting-bottom
-A PREROUTING -j quantum-l3-agent-PREROUTING
-A POSTROUTING -j quantum-l3-agent-POSTROUTING
-A POSTROUTING -j quantum-postrouting-bottom
-A OUTPUT -j quantum-l3-agent-OUTPUT
-A quantum-l3-agent-OUTPUT -d 172.24.4.228/32 -j DNAT --to-destination 10.1.0.2
-A quantum-l3-agent-POSTROUTING ! -i qg-d48b49e0-aa ! -o qg-d48b49e0-aa -m conntrack ! --ctstate DNAT -j ACCEPT
-A quantum-l3-agent-PREROUTING -d 169.254.169.254/32 -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 9697
-A quantum-l3-agent-PREROUTING -d 172.24.4.228/32 -j DNAT --to-destination 10.1.0.2
-A quantum-l3-agent-float-snat -s 10.1.0.2/32 -j SNAT --to-source 172.24.4.228
-A quantum-l3-agent-snat -j quantum-l3-agent-float-snat
-A quantum-l3-agent-snat -s 10.1.0.0/24 -j SNAT --to-source 172.24.4.227
-A quantum-postrouting-bottom -j quantum-l3-agent-snat
&lt;/code>&lt;/pre>
&lt;p>There are &lt;code>SNAT&lt;/code> and &lt;code>DNAT&lt;/code> rules to map traffic between the floating
address, &lt;code>172.24.4.228&lt;/code>, and the private address &lt;code>10.1.0.2&lt;/code>:&lt;/p>
&lt;pre>&lt;code>-A quantum-l3-agent-OUTPUT -d 172.24.4.228/32 -j DNAT --to-destination 10.1.0.2
-A quantum-l3-agent-PREROUTING -d 172.24.4.228/32 -j DNAT --to-destination 10.1.0.2
-A quantum-l3-agent-float-snat -s 10.1.0.2/32 -j SNAT --to-source 172.24.4.228
&lt;/code>&lt;/pre>
&lt;p>When you associate a floating ip address with an instance, similar
rules will be created in this table.&lt;/p>
&lt;p>There is also an &lt;code>SNAT&lt;/code> rule that NATs all outbound traffic from our
private network to &lt;code>172.24.4.227&lt;/code>:&lt;/p>
&lt;pre>&lt;code>-A quantum-l3-agent-snat -s 10.1.0.0/24 -j SNAT --to-source 172.24.4.227
&lt;/code>&lt;/pre>
&lt;p>This permits instances to have outbound connectivity even without a
public ip address.&lt;/p>
&lt;h1 id="network-host-external-traffic-l">Network host: External traffic (L)&lt;/h1>
&lt;p>&amp;ldquo;External&amp;rdquo; traffic flows through &lt;code>br-ex&lt;/code> via the &lt;code>qg-d48b49e0-aa&lt;/code>
interface in the router name space.&lt;/p>
&lt;pre>&lt;code>Bridge br-ex
Port &amp;quot;qg-d48b49e0-aa&amp;quot;
Interface &amp;quot;qg-d48b49e0-aa&amp;quot;
Port br-ex
Interface br-ex
type: internal
&lt;/code>&lt;/pre>
&lt;p>What happens when traffic gets this far depends on your local
configuration.&lt;/p>
&lt;h2 id="nat-to-host-address">NAT to host address&lt;/h2>
&lt;p>If you assign the gateway address for your public network to &lt;code>br-ex&lt;/code>:&lt;/p>
&lt;pre>&lt;code># ip addr add 172.24.4.225/28 dev br-ex
&lt;/code>&lt;/pre>
&lt;p>Then you can create forwarding and NAT rules that will cause
&amp;ldquo;external&amp;rdquo; traffic from your instances to get rewritten to your
network controller&amp;rsquo;s ip address and sent out on the network:&lt;/p>
&lt;pre>&lt;code># iptables -A FORWARD -d 172.24.4.224/28 -j ACCEPT
# iptables -A FORWARD -s 172.24.4.224/28 -j ACCEPT
# iptables -t nat -I POSTROUTING 1 -s 172.24.4.224/28 -j MASQUERADE
&lt;/code>&lt;/pre>
&lt;h2 id="direct-network-connection">Direct network connection&lt;/h2>
&lt;p>If you have an external router that will act as a gateway for your
public network, you can add an interface on that network to the
bridge. For example, assuming that &lt;code>eth2&lt;/code> was on the same network as
&lt;code>172.24.4.225&lt;/code>:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-port br-ex eth2
&lt;/code>&lt;/pre></content></item><item><title>Why does the Neutron documentation recommend three interfaces?</title><link>https://blog.oddbit.com/post/2013-10-28-why-does-the-neutron/</link><pubDate>Mon, 28 Oct 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-10-28-why-does-the-neutron/</guid><description>&lt;p>The &lt;a href="http://docs.openstack.org/havana/install-guide/install/yum/content/neutron-install.dedicated-network-node.html">documentation for configuring Neutron&lt;/a> recommends
that a network controller has three physical interfaces:&lt;/p>
&lt;blockquote>
&lt;p>Before you start, set up a machine to be a dedicated network node.
Dedicated network nodes should have the following NICs: the
management NIC (called MGMT_INTERFACE), the data NIC (called
DATA_INTERFACE), and the external NIC (called EXTERNAL_INTERFACE).&lt;/p>
&lt;/blockquote>
&lt;p>People occasionally ask, &amp;ldquo;why three interfaces? What if I only have
two?&amp;rdquo;, so I wanted to provide an extended answer that might help
people understand what the interfaces are for and what trade-offs are
involved in using fewer interfaces.&lt;/p></description><content>&lt;p>The &lt;a href="http://docs.openstack.org/havana/install-guide/install/yum/content/neutron-install.dedicated-network-node.html">documentation for configuring Neutron&lt;/a> recommends
that a network controller has three physical interfaces:&lt;/p>
&lt;blockquote>
&lt;p>Before you start, set up a machine to be a dedicated network node.
Dedicated network nodes should have the following NICs: the
management NIC (called MGMT_INTERFACE), the data NIC (called
DATA_INTERFACE), and the external NIC (called EXTERNAL_INTERFACE).&lt;/p>
&lt;/blockquote>
&lt;p>People occasionally ask, &amp;ldquo;why three interfaces? What if I only have
two?&amp;rdquo;, so I wanted to provide an extended answer that might help
people understand what the interfaces are for and what trade-offs are
involved in using fewer interfaces.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>The &lt;code>MGMT_INTERFACE&lt;/code> is used for communication between nodes. This
can include traffic from services to the messaging server (&lt;code>qpid&lt;/code>,
&lt;code>rabbitmq&lt;/code>, etc), traffic between nova and neutron, connections to the
database, and other traffic used to manage your OpenStack environment.&lt;/p>
&lt;p>The &lt;code>DATA_INTERFACE&lt;/code> is used for instance traffic&amp;hellip;that is, traffic
generated by or inbound to instances running in your OpenStack
environment. If you are using GRE or VXLAN tunnels your tunnel
endpoints will be associated with this interface.&lt;/p>
&lt;p>The &lt;code>EXTERNAL_INTERFACE&lt;/code> is used to provide public access to your
instances. The network attached to this interface is generally open
to external traffic, and ip addresses are managed by the floating-ip
functionality in Neutron or Nova.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>You want your &lt;code>MGMT_INTERFACE&lt;/code> seperate from your &lt;code>DATA_INTERFACE&lt;/code>
in order to avoid accidentally granting management access to your
OpenStack hosts to your tenants. A typical OpenStack environment
may not use authentication in all cases, and a tenant host with
access to the management network could intentionally or accidentally
cause problems.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You want your &lt;code>EXTERNAL_INTERFACE&lt;/code> separate from your
&lt;code>DATA_INTERFACE&lt;/code> because your network controller &lt;em>must&lt;/em> be acting as
a router between these two interfaces in order for the netfilter
&lt;code>PREROUTING&lt;/code> and &lt;code>POSTROUTING&lt;/code> rules to activate. These rules are
used to map floating ip addresses to internal addresses via &lt;code>SNAT&lt;/code>
and &lt;code>DNAT&lt;/code> rules, which only work packets traverse the &lt;code>FORWARD&lt;/code>
chain.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You want your &lt;code>MGMT_INTERFACE&lt;/code> separate from your
&lt;code>EXTERNAL_INTERFACE&lt;/code> because they have dramatically different access
requirements. Your &lt;code>MGMT_INTERFACE&lt;/code> should typically only be
available to other hosts in your OpenStack deployment, while your
&lt;code>EXTERNAL_INTERFACE&lt;/code> will generally require much broader access.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>If you are deploying a proof-of-concept (POC) deployment to which you
are not actually providing public access, you can elect to not have an
&lt;code>EXTERNAL_INTERFACE&lt;/code>. Rather than adding this device to &lt;code>br-ex&lt;/code>, you
will set up outbound NAT rules so that &amp;ldquo;external&amp;rdquo; traffic from your
instances will masquerade using the primary ip address of your network
controller.&lt;/p></content></item><item><title>Waiting for networking using PowerShell</title><link>https://blog.oddbit.com/post/2012-11-04-powershell-wait-for-networking/</link><pubDate>Sun, 04 Nov 2012 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2012-11-04-powershell-wait-for-networking/</guid><description>&lt;p>I&amp;rsquo;ve recently been exploring the world of Windows scripting, and I ran
into a small problem: I was running a script at system startup, and
the script was running before the network interface (which was using
DHCP) was configured.&lt;/p>
&lt;p>There are a number of common solutions proposed to this problem:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Just wait for some period of time.&lt;/p>
&lt;p>This can work but it&amp;rsquo;s ugly, and because it doesn&amp;rsquo;t actually
verify the network state it can result in things breaking if some
problem prevents Windows from pulling a valid DHCP lease.&lt;/p></description><content>&lt;p>I&amp;rsquo;ve recently been exploring the world of Windows scripting, and I ran
into a small problem: I was running a script at system startup, and
the script was running before the network interface (which was using
DHCP) was configured.&lt;/p>
&lt;p>There are a number of common solutions proposed to this problem:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Just wait for some period of time.&lt;/p>
&lt;p>This can work but it&amp;rsquo;s ugly, and because it doesn&amp;rsquo;t actually
verify the network state it can result in things breaking if some
problem prevents Windows from pulling a valid DHCP lease.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use ping to verify the availability of some remote host.&lt;/p>
&lt;p>This works reasonably well if you have a known endpoint you can
test, but it&amp;rsquo;s hard to make a generic solution using this method.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>What I really wanted to do was to have my script wait until a default
gateway appeared on the system (which would indicate that Windows had
successfully acquired a DHCP lease and had configured the interface).&lt;/p>
&lt;p>My first attempts involved traditional batch scripts (&lt;code>.bat&lt;/code>) running
some variant of &lt;code>route print&lt;/code> and searching the output. This can
work, but it&amp;rsquo;s ugly, and I was certain there must be a better way. I
spent some time learning about accessing network configuration
information using PowerShell, and I came up with &lt;a href="https://gist.github.com/4011808">the following
code&lt;/a>:&lt;/p>
&lt;pre>&lt;code># Wait for a DHCP-enabled interface to develop
# a default gateway.
#
# usage: wait-for-network [ &amp;lt;tries&amp;gt; ]
function wait-for-network ($tries) {
while (1) {
# Get a list of DHCP-enabled interfaces that have a
# non-$null DefaultIPGateway property.
$x = gwmi -class Win32_NetworkAdapterConfiguration `
-filter DHCPEnabled=TRUE |
where { $_.DefaultIPGateway -ne $null }
# If there is (at least) one available, exit the loop.
if ( ($x | measure).count -gt 0 ) {
break
}
# If $tries &amp;gt; 0 and we have tried $tries times without
# success, throw an exception.
if ( $tries -gt 0 -and $try++ -ge $tries ) {
throw &amp;quot;Network unavaiable after $try tries.&amp;quot;
}
# Wait one second.
start-sleep -s 1
}
}
&lt;/code>&lt;/pre>
&lt;p>This uses various sort of filtering to get a list of DHCP-enabled
interfaces that have a default gateway (the &lt;code>DefaultIPGateway&lt;/code>
attribute). It will poll the state of things once/second up to &lt;code>$tries&lt;/code>
times, and if nothing is available it will ultimately throw an
exception.&lt;/p></content></item><item><title>Chasing OpenStack idle connection timeouts</title><link>https://blog.oddbit.com/post/2012-07-30-openstack-idle-connection-time/</link><pubDate>Mon, 30 Jul 2012 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2012-07-30-openstack-idle-connection-time/</guid><description>&lt;h2 id="the-original-problem">The original problem&lt;/h2>
&lt;p>I&amp;rsquo;ve recently spent some time working on an OpenStack deployment. I ran into a
problem in which the &lt;a href="http://docs.openstack.org/trunk/openstack-compute/starter/content/Compute_Worker_nova-compute_-d1e232.html">compute service&lt;/a> would frequently stop communicating
with the &lt;a href="http://www.amqp.org/">AMQP&lt;/a> message broker (&lt;code>qpidd&lt;/code>).&lt;/p>
&lt;p>In order to gather some data on the problem, I ran the following simple test:&lt;/p>
&lt;ul>
&lt;li>Wait &lt;code>n&lt;/code> minutes&lt;/li>
&lt;li>Run &lt;code>nova boot ...&lt;/code> to create an instance&lt;/li>
&lt;li>Wait a minute and see if the new instance becomes &lt;code>ACTIVE&lt;/code>&lt;/li>
&lt;li>If it works, delete the instance, set &lt;code>n&lt;/code> = &lt;code>2n&lt;/code> and repeat&lt;/li>
&lt;/ul>
&lt;p>This demonstrated that communication was failing after about an hour, which
correlates rather nicely with the idle connection timeout on the firewall.&lt;/p></description><content>&lt;h2 id="the-original-problem">The original problem&lt;/h2>
&lt;p>I&amp;rsquo;ve recently spent some time working on an OpenStack deployment. I ran into a
problem in which the &lt;a href="http://docs.openstack.org/trunk/openstack-compute/starter/content/Compute_Worker_nova-compute_-d1e232.html">compute service&lt;/a> would frequently stop communicating
with the &lt;a href="http://www.amqp.org/">AMQP&lt;/a> message broker (&lt;code>qpidd&lt;/code>).&lt;/p>
&lt;p>In order to gather some data on the problem, I ran the following simple test:&lt;/p>
&lt;ul>
&lt;li>Wait &lt;code>n&lt;/code> minutes&lt;/li>
&lt;li>Run &lt;code>nova boot ...&lt;/code> to create an instance&lt;/li>
&lt;li>Wait a minute and see if the new instance becomes &lt;code>ACTIVE&lt;/code>&lt;/li>
&lt;li>If it works, delete the instance, set &lt;code>n&lt;/code> = &lt;code>2n&lt;/code> and repeat&lt;/li>
&lt;/ul>
&lt;p>This demonstrated that communication was failing after about an hour, which
correlates rather nicely with the idle connection timeout on the firewall.&lt;/p>
&lt;p>I wanted to continue working with our OpenStack environment while testing
different solutions to this problem, so I put an additional interface on the
controller (the system running the AMQ message broker, &lt;code>qpidd&lt;/code>, as well as
&lt;code>nova-api&lt;/code>, &lt;code>nova-scheduler&lt;/code>, etc) that was on the same network as our
&lt;code>nova-compute&lt;/code> hosts. This would allow the compute service to communicate with
the message broker without traversing the firewall infrastructure.&lt;/p>
&lt;p>As a workaround it worked fine, but it introduced a &lt;em>new&lt;/em> problem that sent us
down a bit of a rabbit hole.&lt;/p>
&lt;h2 id="the-new-problem">The new problem&lt;/h2>
&lt;p>With the compute hosts talking happily to the controller, I started looking at
the connection timeout settings in the firewall. As a first step I cranked the
default connection timeout up to two hours and repeated our earlier test&amp;hellip;only
to find that connections were now failing in a matter of minutes!&lt;/p>
&lt;p>So, what happened?&lt;/p>
&lt;p>By adding an interface on a shared network, I created an asymmetric route
between the two hosts &amp;ndash; that is, the network path taking by packets from the
compute host to the controller was different from the network path taken by
packets in the other direction.&lt;/p>
&lt;p>In the most common configuration, Linux (and other operating systems) only have
a single routing decision to make:&lt;/p>
&lt;ul>
&lt;li>Am I communicating with a host on a directly attached network?&lt;/li>
&lt;/ul>
&lt;p>If the answer is &amp;ldquo;yes&amp;rdquo;, a packet will be routed directly to the destination
host, otherwise it will be routed via the default gateway (and transit the
campus routing/firewall infrastructure).&lt;/p>
&lt;p>On the compute host, with its single interface, the decision is simple. Since
the canonical address of the controller is not on the same network, packets
will be routed via the default gateway. On the controller, the situation is
different. While the packet came in on the canonical interface, the kernel will
realize that the request comes from a host on a network to which there is a
more specific route than the default gateway: the new network interface on the
same network as the compute host. This means that reply packets will be routed
directly.&lt;/p>
&lt;p>Asymmetric routing is not, by itself, a problem. However, throw in a stateful
firewall and you now have a recipe for dropped connections. The firewall
appliances in use at my office maintain a table of established TCP connections.
This is used to reduce the processing necessary for packets associated with
established connections. From the &lt;a href="http://www.cisco.com/en/US/docs/security/asdm/6_2/user/guide/protect.html#wp1291963">Cisco documentation&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>By default, all traffic that goes through the security appliance is inspected
using the Adaptive Security Algorithm and is either allowed through or
dropped based on the security policy. The security appliance maximizes the
firewall performance by checking the state of each packet (is this a new
connection or an established connection?) and assigning it to either the
session management path (a new connection SYN packet), the fast path (an
established connection), or the control plane path (advanced inspection).&lt;/p>
&lt;/blockquote>
&lt;p>In order for two systems to successfully established a TCP connection, they
must complete a &lt;a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment">three-way handshake&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>The initiating systems sends a &lt;code>SYN&lt;/code> packet.&lt;/li>
&lt;li>The receiving system sends &lt;code>SYN-ACK&lt;/code> packet.&lt;/li>
&lt;li>The initiating system sends an &lt;code>ACK&lt;/code> packet.&lt;/li>
&lt;/ul>
&lt;p>The routing structure introduced by our interface change meant that while the
initial &lt;code>SYN&lt;/code> packet was traversing the firewall, the subsequent &lt;code>SYN-ACK&lt;/code>
packet was being routed directly, which means that from the point of view of
the firewall the connection was never successfully established&amp;hellip;and after 20
seconds (the default &amp;ldquo;embryonic connection timeout&amp;rdquo;) the connection gets
dropped by the firewall. The diagram below illustrates exactly what was
happening:&lt;/p>
&lt;p>&lt;img alt="assymetric routing" src="https://blog.oddbit.com/post/2012-07-30-openstack-idle-connection-time/asymmetric-routing.png">&lt;/p>
&lt;p>There are various ways of correcting this situation:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>You could use the advanced &lt;a href="http://www.policyrouting.org/PolicyRoutingBook/ONLINE/TOC.html">policy routing&lt;/a> features available in Linux
to set up a routing policy that would route replies out the same interface
on which a packet was received, thus returning to a more typical symmetric
routing model.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You could use the &lt;a href="http://www.cisco.com/en/US/docs/security/asdm/6_2/user/guide/protect.html#wp1291963">tcp state bypass&lt;/a> feature available in the Cisco
firewall appliance to exempt AMQ packets from the normal TCP state
processing.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>I&amp;rsquo;m not going to look at either of these solution in detail, since this whole
issue was secondary to the initial idle connection timeout problem, which has a
different set of solutions.&lt;/p>
&lt;h2 id="dealing-with-connection-timeouts">Dealing with connection timeouts&lt;/h2>
&lt;p>Returning to the original problem, what am I to do about the idle connection
timeouts?&lt;/p>
&lt;h3 id="disable-idle-connection-timeouts-on-the-firewall">Disable idle connection timeouts on the firewall&lt;/h3>
&lt;p>Once can disable idle connection timeouts on the firewall, either globally &amp;ndash;
which would be a bad idea &amp;ndash; or for certain traffic classes. For example, &amp;ldquo;all
traffic to or from TCP port 5672&amp;rdquo;. This can be done by adding a rule to the
default global policy:&lt;/p>
&lt;pre>&lt;code>class-map amq
description Disable connection timeouts for AMQ connections (for OpenStack)
match port tcp eq 5672
policy-map global_policy
class amq
set connection random-sequence-number disable
set connection timeout embryonic 0:00:20 half-closed 0:00:20 tcp 0:00:00
&lt;/code>&lt;/pre>
&lt;p>While this works fine, it makes successful deployment of OpenStack dependent on
a specific firewall configuration.&lt;/p>
&lt;h3 id="enable-linux-kernel-keepalive-support-for-tcp-connections">Enable Linux kernel keepalive support for TCP connections&lt;/h3>
&lt;p>The Linux kernel supports a &lt;a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/">keepalive&lt;/a> feature intended to deal with this
exact situation. After a connection has been idle for a certain amount of time
(&lt;code>net.ipv4.tcp_keepalive_time&lt;/code>), the kernel will send zero-length packets every
&lt;code>net.ipv4.tcp_keepalive_intvl&lt;/code> seconds in order to keep the connection active.
The kernel defaults to an initial interval of 7200 seconds (aka two hours),
which is longer than the default idle connection timeout on our Cisco
firewalls, but this value is easily tuneable via the
&lt;code>net.ipv4.tcp_keepalive_time&lt;/code> sysctl value.&lt;/p>
&lt;p>This sounds like a great solution, until you pay close attention to the &lt;code>tcp&lt;/code>
man page (or the &lt;code>HOWTO&lt;/code> document):&lt;/p>
&lt;blockquote>
&lt;p>Keep-alives are only sent when the &lt;code>SO_KEEPALIVE&lt;/code> socket option is enabled.&lt;/p>
&lt;/blockquote>
&lt;p>If your application doesn&amp;rsquo;t already set &lt;code>SO_KEEPALIVE&lt;/code> (or give you an option
for doing do), you&amp;rsquo;re mostly out of luck. While it would certainly be possible
to modify either the OpenStack source or the QPID source to set the appropriate
option on AMQ sockets, I don&amp;rsquo;t really want to put myself in the position of
having to maintain this sort of one-off patch.&lt;/p>
&lt;p>But all is not lost! It is possible to override functions in dynamic
executables using a mechanism called &lt;a href="http://www.jayconrod.com/cgi/view_post.py?23">function interposition&lt;/a>. Create a
library that implements the function you want to override, and then preload it
when running an application via the &lt;code>LD_PRELOAD&lt;/code> environment variable (or
&lt;code>/etc/ld.so.preload&lt;/code>, if you want it to affect everything).&lt;/p>
&lt;p>It can be tricky to correctly implement function interposition, so I&amp;rsquo;m
fortunate that the &lt;a href="http://libkeepalive.sourceforge.net">libkeepalive&lt;/a> project has already taken care of this. By
installing &lt;code>libkeepalive&lt;/code> and adding &lt;code>libkeepalive.so&lt;/code> to &lt;code>/etc/ld.so.preload&lt;/code>,
it is possible to have the &lt;code>SO_KEEPALIVE&lt;/code> option set by default on all sockets.
&lt;code>libkeepalive&lt;/code> implements a wrapper to the &lt;code>socket&lt;/code> system call that calls
&lt;code>setsockopt&lt;/code> with the &lt;code>SO_KEEPALIVE&lt;/code> option for all TCP sockets.&lt;/p>
&lt;p>Here&amp;rsquo;s what setting up a listening socket with [netcat][] looks like before
installing &lt;code>libkeepalive&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ strace -e trace=setsockopt nc -l 8080
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
&lt;/code>&lt;/pre>
&lt;p>And here&amp;rsquo;s what things look like after adding &lt;code>libkeepalive.so&lt;/code> to
&lt;code>/etc/ld.so.preload&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ strace -e trace=setsockopt nc -l 8080
setsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [1], 4) = 0
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
&lt;/code>&lt;/pre>
&lt;h3 id="enable-application-level-keepalive">Enable application level keepalive&lt;/h3>
&lt;p>Many applications implement their own keepalive mechanism. For example,
&lt;a href="http://openssh.org/">OpenSSH&lt;/a> provides the &lt;a href="http://dan.hersam.com/2007/03/05/how-to-avoid-ssh-timeouts/">ClientAliveInterval&lt;/a> configuration setting to
control how often keepalive packets are sent by the server to a connected
client. When this option is available it&amp;rsquo;s probably the best choice, since it
has been designed with the particular application in mind.&lt;/p>
&lt;p>OpenStack in theory provides the &lt;a href="http://docs.openstack.org/essex/openstack-compute/admin/content/configuration-qpid.html">qpid_heartbeat&lt;/a> setting, which is meant
to provide a heartbeat for AMQ connections to the &lt;code>qpidd&lt;/code> process. According to
the documentation, the default behavior of QPID clients in the OpenStack
framework is to send heartbeat packets every five seconds.&lt;/p>
&lt;p>When first testing this option it was obvious that things weren&amp;rsquo;t working as
documented. Querying the connection table on the firewall would often should
connections with more than five seconds of idle time:&lt;/p>
&lt;pre>&lt;code>% show conn lport 5672
[...]
TCP ...:630 10.243.16.151:39881 ...:621 openstack-dev-2:5672 idle 0:34:02 Bytes 5218662 FLAGS - UBOI
[...]
&lt;/code>&lt;/pre>
&lt;p>And of course if the &lt;code>qpid_heartbeat&lt;/code> option had been working correctly I would
not have experienced the idle connection timeout issue in the first place.&lt;/p>
&lt;p>A &lt;a href="https://lists.launchpad.net/openstack/msg15191.html">post to the OpenStack mailing list&lt;/a> led to the source of the problem: a
typo in the &lt;code>impl_qpid&lt;/code> Python module:&lt;/p>
&lt;pre>&lt;code>diff --git a/nova/rpc/impl_qpid.py b/nova/rpc/impl_qpid.py
index 289f21b..e19079e 100644
--- a/nova/rpc/impl_qpid.py
+++ b/nova/rpc/impl_qpid.py
@@ -317,7 +317,7 @@ class Connection(object):
FLAGS.qpid_reconnect_interval_min)
if FLAGS.qpid_reconnect_interval:
self.connection.reconnect_interval = FLAGS.qpid_reconnect_interval
- self.connection.hearbeat = FLAGS.qpid_heartbeat
+ self.connection.heartbeat = FLAGS.qpid_heartbeat
self.connection.protocol = FLAGS.qpid_protocol
self.connection.tcp_nodelay = FLAGS.qpid_tcp_nodelay
&lt;/code>&lt;/pre>
&lt;p>If it&amp;rsquo;s not obvious, &lt;code>heartbeat&lt;/code> was mispelled &lt;code>hearbeat&lt;/code> in the above block of
code. Putting this change into production has completely resolved the idle
connection timeout problem.&lt;/p></content></item><item><title>Rate limiting made simple</title><link>https://blog.oddbit.com/post/2011-12-26-simple-rate-limiting/</link><pubDate>Mon, 26 Dec 2011 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2011-12-26-simple-rate-limiting/</guid><description>&lt;p>I use &lt;a href="http://www.crashplan.com/">CrashPlan&lt;/a> as a backup service. It works and is very simple to set
up, but has limited options for controlling bandwidth. In fact, if you&amp;rsquo;re
running it on a headless system (e.g., a fileserver of some sort), your options
are effectively &amp;ldquo;too slow&amp;rdquo; and &amp;ldquo;CONSUME EVERYTHING&amp;rdquo;. There is an &lt;a href="https://crashplan.zendesk.com/entries/446273-throttle-bandwidth-by-hours?page=1#post_20799486">open
request&lt;/a> to add time-based limitations to the application itself, but for
now I&amp;rsquo;ve solved this using a very simple traffic shaping configuration.
Because the learning curve for &amp;ldquo;tc&amp;rdquo; and friends is surprisingly high, I&amp;rsquo;m
putting &lt;a href="https://gist.github.com/larsks/4014881">my script&lt;/a> here in the hopes
that other people might find it useful, and so that I can find it when I need
to do this again someday.&lt;/p></description><content>&lt;p>I use &lt;a href="http://www.crashplan.com/">CrashPlan&lt;/a> as a backup service. It works and is very simple to set
up, but has limited options for controlling bandwidth. In fact, if you&amp;rsquo;re
running it on a headless system (e.g., a fileserver of some sort), your options
are effectively &amp;ldquo;too slow&amp;rdquo; and &amp;ldquo;CONSUME EVERYTHING&amp;rdquo;. There is an &lt;a href="https://crashplan.zendesk.com/entries/446273-throttle-bandwidth-by-hours?page=1#post_20799486">open
request&lt;/a> to add time-based limitations to the application itself, but for
now I&amp;rsquo;ve solved this using a very simple traffic shaping configuration.
Because the learning curve for &amp;ldquo;tc&amp;rdquo; and friends is surprisingly high, I&amp;rsquo;m
putting &lt;a href="https://gist.github.com/larsks/4014881">my script&lt;/a> here in the hopes
that other people might find it useful, and so that I can find it when I need
to do this again someday.&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
# The network device used for backups
dev=p10p1
# The remove address of the CrashPlanserver
crashplan_addr=50.93.246.1
# The port
crashplan_port=443
# The rate limit. See tc(8) for acceptable syntax.
crashplan_limit=2mbit
if [ &amp;quot;$1&amp;quot; = &amp;quot;enable&amp;quot; ]; then
#
# This creates and activates the traffic shaper
# configuration.
#
logger -s -t ratelimit -p user.notice &amp;quot;enabling rate limits&amp;quot;
tc qdisc del dev $dev root &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
tc qdisc add dev $dev root handle 1: htb
tc class add dev $dev parent 1: classid 1:10 htb rate $crashplan_limit
tc filter add dev $dev parent 1: prio 0 protocol ip handle 10 fw flowid 1:10
iptables -t mangle -A OUTPUT -d $crashplan_addr -p tcp --dport $crashplan_port -j MARK --set-mark 10
elif [ &amp;quot;$1&amp;quot; = &amp;quot;disable&amp;quot; ]; then
#
# This removes the traffic shaper
# configuration.
#
logger -s -t ratelimit -p user.notice &amp;quot;disabling rate limits&amp;quot;
tc qdisc del dev $dev root &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
iptables -t mangle -D OUTPUT -d $crashplan_addr -p tcp --dport $crashplan_port -j MARK --set-mark 10
elif [ &amp;quot;$1&amp;quot; = &amp;quot;show&amp;quot; ]; then
#
# Shows the current traffic shaper configuration.
#
tc qdisc show dev $dev
tc class show dev $dev
tc filter show dev $dev
iptables -t mangle -vnL OUTPUT
fi
&lt;/code>&lt;/pre></content></item><item><title>Linux UPnP Gateway</title><link>https://blog.oddbit.com/post/2010-01-29-linux-upnp-gateway/</link><pubDate>Fri, 29 Jan 2010 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2010-01-29-linux-upnp-gateway/</guid><description>&lt;p>Like many other folks out there, I have several computers in my house connected to the outside world via a Linux box acting as a NAT gateway. I often want to use application such as BitTorrent and Freenet, which require that a number of ports be forwarded from my external connection to the particular computer on which I happen to be working. It turns out there&amp;rsquo;s a protocol for this, called &lt;a href="http://en.wikipedia.org/wiki/Universal_Plug_and_Play">UPnP&lt;/a>. From Wikipedia:&lt;/p></description><content>&lt;p>Like many other folks out there, I have several computers in my house connected to the outside world via a Linux box acting as a NAT gateway. I often want to use application such as BitTorrent and Freenet, which require that a number of ports be forwarded from my external connection to the particular computer on which I happen to be working. It turns out there&amp;rsquo;s a protocol for this, called &lt;a href="http://en.wikipedia.org/wiki/Universal_Plug_and_Play">UPnP&lt;/a>. From Wikipedia:&lt;/p>
&lt;blockquote>
&lt;p>Universal Plug and Play (UPnP) is a set of networking protocols
promulgated by the UPnP Forum. The goals of UPnP are to allow
devices to connect seamlessly and to simplify the implementation of
networks in the home (data sharing, communications, and
entertainment) and in corporate environments for simplified
installation of computer components.&lt;/p>
&lt;/blockquote>
&lt;p>The practical use of UPnP, from my perspective, is that it allows a device or application &lt;em>inside&lt;/em> the network to request specific ports to be forwarded on the gateway. This means that what used to be a manual process &amp;ndash; adding the necessary forwarding rules to my iptables configuration &amp;ndash; is now performed automatically, and only when necessary.&lt;/p>
&lt;p>The &lt;a href="http://linux-igd.sourceforge.net/">Linux UPnP Internet Gateway Device&lt;/a> project implements a Linux UPnP service. You can download the source from the project web page.&lt;/p>
&lt;p>Using the gateway service is really simple:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Start upnpd:&lt;/p>
&lt;pre>&lt;code> # /etc/init.d/upnpd
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Start your application. You will see messages like the following in syslog (if you are logging DEBUG level messages):&lt;/p>
&lt;pre>&lt;code> Aug 6 20:10:12 arcadia upnpd[19816]: Failure in
GateDeviceDeletePortMapping: DeletePortMap: Proto:UDP Port:57875
Aug 6 20:10:12 arcadia upnpd[19816]: AddPortMap: DevUDN:
uuid:75802409-bccb-40e7-8e6c-fa095ecce13e ServiceID: urn:upnp-org:serviceId:WANIPConn1
RemoteHost: (null) Prot: UDP ExtPort: 57875 Int: 192.168.1.118.57875
Aug 6 20:10:12 arcadia upnpd[19816]: Failure in
GateDeviceDeletePortMapping: DeletePortMap: Proto:UDP Port:11657
Aug 6 20:10:12 arcadia upnpd[19816]: AddPortMap: DevUDN:
uuid:75802409-bccb-40e7-8e6c-fa095ecce13e ServiceID: urn:upnp-org:serviceId:WANIPConn1
RemoteHost: (null) Prot: UDP ExtPort: 11657 Int: 192.168.1.118.11657
&lt;/code>&lt;/pre>
&lt;p>For each forwarding requested by the client, upnpd first attempts to remove the mapping and then creates a new rule. Exactly how upnp implements these rules on your system is controlled by &lt;code>/etc/upnpd.conf&lt;/code> &amp;ndash; if you want to use something other than &lt;em>iptables&lt;/em>, or use custom chains, this is where you would make your changes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Look at your firewall rules. Upnpd modifies the &lt;em>FORWARD&lt;/em> chain in the &lt;em>filter&lt;/em> table and the &lt;em>PREROUTING&lt;/em> chain in the &lt;em>nat&lt;/em> table. You can change this behavior by editing &lt;code>/etc/upnpd.conf&lt;/code>.&lt;/p>
&lt;p>To see forwarding rules:&lt;/p>
&lt;pre>&lt;code> # iptables -nL FORWARD
&lt;/code>&lt;/pre>
&lt;p>The rules might look something like this:&lt;/p>
&lt;pre>&lt;code> Chain FORWARD (policy DROP)
target prot opt source destination
ACCEPT udp -- 0.0.0.0/0 192.168.1.118 udp dpt:57875
ACCEPT udp -- 0.0.0.0/0 192.168.1.118 udp dpt:11657
&lt;/code>&lt;/pre>
&lt;p>To see prerouting rules:&lt;/p>
&lt;pre>&lt;code> # iptables -t nat -vnL PREROUTING
&lt;/code>&lt;/pre>
&lt;p>The rules might look something like this:&lt;/p>
&lt;pre>&lt;code> Chain PREROUTING (policy ACCEPT)
target prot opt source destination
DNAT udp -- 0.0.0.0/0 0.0.0.0/0 udp dpt:11657 to:192.168.1.118:11657
DNAT udp -- 0.0.0.0/0 0.0.0.0/0 udp dpt:57875 to:192.168.1.118:57875
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Upnpd will delete the mappings when they expire. The expiration time may be set by the client, or, if the client specifies no expiration, than by the &amp;ldquo;duration&amp;rdquo; configuration item in /etc/upnpd.conf.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="configuration-file">Configuration file&lt;/h1>
&lt;p>The upnpd configuration file (&lt;code>/etc/upnpd.conf&lt;/code>) allows you to change various aspects of upnpd&amp;rsquo;s behavior. Of particular interest:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>insert_forward_rules&lt;/code>&lt;br>
Default: &lt;code>yes&lt;/code>&lt;/p>
&lt;p>Whether or not upnpd needs to create entries in the &lt;code>FORWARD&lt;/code> chain of the &lt;code>filter&lt;/code> table. If your &lt;code>FORWARD&lt;/code> chain has a policy of &lt;code>DROP&lt;/code> you need set to yes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>forward_chain_name&lt;/code>&lt;br>
Default: &lt;code>FORWARD&lt;/code>&lt;/p>
&lt;p>Normally, upnpd creates entries in the &lt;code>FORWARD&lt;/code> chain. If you have a more advanced firewall setup this may not be the appropriate place to make changes. If you enter a custom name here, you will need to create the corresponding chain:&lt;/p>
&lt;pre>&lt;code> iptables -N my-forward-chain
&lt;/code>&lt;/pre>
&lt;p>You will also need to call this chain from the &lt;em>FORWARD&lt;/em> chain:&lt;/p>
&lt;pre>&lt;code> iptables -A FORWARD -j my-forward-chain
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;code>prerouting_chain_name&lt;/code>&lt;br>
Default: &lt;code>PREROUTING&lt;/code>&lt;/p>
&lt;p>Like &lt;code>forward&lt;/code>chain&lt;code>name&lt;/code>, but for entries in the &lt;code>nat&lt;/code> table.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="security-considerations">Security considerations&lt;/h1>
&lt;p>Consider the following, from the &lt;a href="http://linux-igd.sourceforge.net/documentation.php">Linux IGD documentation&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>UPnP version 1.0, on which this program is based, is inherently flawed&amp;hellip;what appears to have happened is that in Microsoft&amp;rsquo;s first UPnP implementation they weren&amp;rsquo;t concerned with security &amp;hellip;. Simply all they wanted was connectivity&amp;hellip;. The UPnP server, by itself, does no security checking. If it recieves a UPnP request to add a portmapping for some ip address inside the firewall, it just does it. This program will attempt to verify the source ip contained in the UPnP request against the source ip of the actual packet, but as always, these can be forged. The UPnP server makes no attempt to verify this connection with the caller, and therefore it just assumes that whoever asked is the person really wanting it.&lt;/p>
&lt;/blockquote>
&lt;p>In other words, in the battle between security and convenience, UPnP is weighs in heavily on the convenience side. You will have to decide whether this meets your particular requirements.&lt;/p></content></item></channel></rss>