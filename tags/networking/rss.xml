<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Networking on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/networking/</link><description>Recent content in Networking on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Sat, 18 Feb 2023 17:08:43 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/networking/rss.xml" rel="self" type="application/rss+xml"/><item><title>NAT between identical networks using VRF</title><link>https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/</link><pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/</guid><description>&lt;p&gt;Last week, Oskar Stenberg asked on &lt;a href="https://unix.stackexchange.com/q/735931/4989"&gt;Unix &amp;amp; Linux&lt;/a&gt; if it were possible to configure connectivity between two networks, both using the same address range, without involving network namespaces. That is, given this high level view of the network&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://excalidraw.com/#json=uuXRRZ2ybaAXiUvbQVkNO,krx3lsbf12c-tDhuWtRjbg"&gt;&lt;img src="https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/the-problem.svg" alt="two networks with the same address range connected by a host named “middleman”"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;hellip;can we set things up so that hosts on the &amp;ldquo;inner&amp;rdquo; network can communicate with hosts on the &amp;ldquo;outer&amp;rdquo; network using the range &lt;code&gt;192.168.3.0/24&lt;/code&gt;, and similarly for communication in the other direction?&lt;/p&gt;</description></item><item><title>Packet, packet, who's got the packet?</title><link>https://blog.oddbit.com/post/2023-02-14-whos-got-the-packet/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-02-14-whos-got-the-packet/</guid><description>&lt;p&gt;In &lt;a href="https://unix.stackexchange.com/q/735522/4989"&gt;this question&lt;/a&gt;, August Vrubel has some C code that sets up a &lt;a href="https://docs.kernel.org/networking/tuntap.html"&gt;tun&lt;/a&gt; interface and then injects a packet, but the packet seemed to disappear into the ether. In this post, I&amp;rsquo;d like to take a slightly extended look at &lt;a href="https://unix.stackexchange.com/a/735534/4989"&gt;my answer&lt;/a&gt; because I think it&amp;rsquo;s a great opportunity for learning a bit more about performing network diagnostics.&lt;/p&gt;
&lt;p&gt;The original code looked like this:&lt;/p&gt;



 &lt;div class="collapsable-code"&gt;
 &lt;input id="761923458" type="checkbox" /&gt;
 &lt;label for="761923458"&gt;
 &lt;span class="collapsable-code__language"&gt;c&lt;/span&gt;
 &lt;span class="collapsable-code__title"&gt;original sendpacket.c&lt;/span&gt;
 &lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽"&gt;&lt;/span&gt;
 &lt;/label&gt;
 &lt;pre class="language-c" &gt;&lt;code&gt;

#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/if.h&amp;gt;
#include &amp;lt;linux/if_tun.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

static int tunAlloc(void) {
 int fd;
 struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;, .ifr_flags = IFF_TUN | IFF_NO_PI};

 fd = open(&amp;#34;/dev/net/tun&amp;#34;, O_RDWR);
 ioctl(fd, TUNSETIFF, (void *)&amp;amp;ifr);
 ioctl(fd, TUNSETOWNER, geteuid());
 return fd;
}

// this is a test
static void bringInterfaceUp(void) {
 int sock;
 struct sockaddr_in addr = {.sin_family = AF_INET};
 struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;};

 inet_aton(&amp;#34;172.30.0.1&amp;#34;, &amp;amp;addr.sin_addr);
 memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));

 sock = socket(AF_INET, SOCK_DGRAM, 0);
 ioctl(sock, SIOCSIFADDR, &amp;amp;ifr);
 ioctl(sock, SIOCGIFFLAGS, &amp;amp;ifr);
 ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
 ioctl(sock, SIOCSIFFLAGS, &amp;amp;ifr);
 close(sock);
}

static void emitPacket(int tap_fd) {
 unsigned char packet[] = {
 0x45, 0x00, 0x00, 0x3c, 0xd8, 0x6f, 0x40, 0x00, 0x3f, 0x06, 0x08, 0x91,
 172, 30, 0, 1, 192, 168, 255, 8, 0xa2, 0x9a, 0x27, 0x11,
 0x80, 0x0b, 0x63, 0x79, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xfa, 0xf0,
 0x89, 0xd8, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a,
 0x5b, 0x76, 0x5f, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07};

 write(tap_fd, packet, sizeof(packet));
}

int main() {
 int tap_fd;

 tap_fd = tunAlloc();
 bringInterfaceUp();
 emitPacket(tap_fd);
 close(tap_fd);

 return 0;
}



&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;


&lt;p&gt;A problem with the original code is that it creates the interface, sends the packet, and tears down the interface with no delays, making it very difficult to inspect the interface configuration, perform packet captures, or otherwise figure out what&amp;rsquo;s going on.&lt;/p&gt;</description></item><item><title>Setting up an IPv6 VLAN</title><link>https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/</guid><description>&lt;p&gt;My internet service provider (&lt;a href="https://www.verizon.com/home/fios/"&gt;FIOS&lt;/a&gt;) doesn&amp;rsquo;t yet (sad face) offer IPv6 capable service, so I&amp;rsquo;ve set up an IPv6 tunnel using the &lt;a href="https://www.tunnelbroker.net/"&gt;Hurricane Electric&lt;/a&gt; tunnel broker. I want to provide IPv6 connectivity to multiple systems in my house, but not to &lt;strong&gt;all&lt;/strong&gt; systems in my house &lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;. In order to meet those requirements, I&amp;rsquo;m going to set up the tunnel on the router, and then expose connectivity over an IPv6-only VLAN. In this post, we&amp;rsquo;ll walk through the steps necessary to set that up.&lt;/p&gt;</description></item><item><title>Creating a VXLAN overlay network with Open vSwitch</title><link>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</guid><description>&lt;p&gt;In this post, we&amp;rsquo;ll walk through the process of getting virtual
machines on two different hosts to communicate over an overlay network
created using the support for VXLAN in &lt;a href="https://www.openvswitch.org/"&gt;Open vSwitch&lt;/a&gt; (or OVS).&lt;/p&gt;
&lt;h2 id="the-test-environment"&gt;The test environment&lt;/h2&gt;
&lt;p&gt;For this post, I&amp;rsquo;ll be working with two systems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;node0.ovs.virt&lt;/code&gt; at address 192.168.122.107&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node1.ovs.virt&lt;/code&gt; at address 192.168.122.174&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These hosts are running CentOS 8, although once we get past the
package installs the instructions will be similar for other
distributions.&lt;/p&gt;</description></item><item><title>OpenShift and CNV: Exposing virtualized services</title><link>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/</link><pubDate>Thu, 30 Jul 2020 01:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/</guid><description>&lt;p&gt;This is the second in a &lt;a href="https://blog.oddbit.com/tag/openshift-and-cnv"&gt;series of posts&lt;/a&gt; about my experience working
with &lt;a href="https://www.openshift.com/"&gt;OpenShift&lt;/a&gt; and &lt;a href="https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization"&gt;CNV&lt;/a&gt;. In this post, I&amp;rsquo;ll be taking a look
at how to expose services on a virtual machine once you&amp;rsquo;ve git it up
and running.&lt;/p&gt;
&lt;nav id="TableOfContents"&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href="#tldr"&gt;TL;DR&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#overview"&gt;Overview&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#connectivity-options"&gt;Connectivity options&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#direct-attachment"&gt;Direct attachment&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#using-an-openshift-service"&gt;Using an OpenShift Service&lt;/a&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href="#exposing-services-on-nodeports"&gt;Exposing services on NodePorts&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#exposing-services-on-cluster-external-ipso"&gt;Exposing services on cluster external IPso&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#exposing-services-using-a-loadbalancer"&gt;Exposing services using a LoadBalancer&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/li&gt;
 &lt;/ul&gt;
&lt;/nav&gt;

&lt;h2 id="tldr"&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Networking seems to be a weak area for CNV right now. Out of the box,
your options for exposing a service on a virtual machine on a public
address at a well known port are slim.&lt;/p&gt;</description></item><item><title>Configuring Open vSwitch with nmcli</title><link>https://blog.oddbit.com/post/2020-02-15-configuring-open-vswitch-with/</link><pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-02-15-configuring-open-vswitch-with/</guid><description>&lt;p&gt;I recently acquired a managed switch for my home office in order to segment a few devices off onto their own isolated vlan. As part of this, I want to expose these vlans on my desktop using Open vSwitch (OVS), and I wanted to implement the configuration using NetworkManager rather than either relying on the legacy &lt;code&gt;/etc/sysconfig/network-scripts&lt;/code&gt; scripts or rolling my own set of services. These are my notes in case I ever have to do this again.&lt;/p&gt;</description></item><item><title>OVN and DHCP: A minimal example</title><link>https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/</guid><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A long time ago, I wrote an article &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/"&gt;all about OpenStack Neutron&lt;/a&gt; (which at that time was called Quantum). That served as an excellent reference for a number of years, but if you&amp;rsquo;ve deployed a recent version of OpenStack you may have noticed that the network architecture looks completely different. The network namespaces previously used to implement routers and dhcp servers are gone (along with iptables rules and other features), and have been replaced by OVN (&amp;ldquo;Open Virtual Network&amp;rdquo;). What is OVN? How does it work? In this article, I&amp;rsquo;d like to explore a minimal OVN installation to help answer these questions.&lt;/p&gt;</description></item><item><title>Configuring a static address for wlan0 on Raspbian Stretch</title><link>https://blog.oddbit.com/post/2018-06-14-configuring-a-static-address-f/</link><pubDate>Thu, 14 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-06-14-configuring-a-static-address-f/</guid><description>&lt;p&gt;Recent releases of Raspbian have adopted the use of &lt;a href="http://manpages.ubuntu.com/manpages/trusty/man8/dhcpcd5.8.html"&gt;dhcpcd&lt;/a&gt; to
manage both dynamic and static interface configuration. If you would
prefer to use the traditional &lt;code&gt;/etc/network/interfaces&lt;/code&gt; mechanism
instead, follow these steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, disable &lt;code&gt;dhcpcd&lt;/code&gt; and &lt;code&gt;wpa_supplicant&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; systemctl disable --now dhdpcd wpa_supplicant
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You will need a &lt;code&gt;wpa_supplicant&lt;/code&gt; configuration for &lt;code&gt;wlan0&lt;/code&gt; in
&lt;code&gt;/etc/wpa_supplicant/wpa_supplicant-wlan0.conf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you already have an appropriate configuration in
&lt;code&gt;/etc/wpa_supplicant/wpa_supplicant.conf&lt;/code&gt;, you can just symlink the
file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; cd /etc/wpa_supplicant
 ln -s wpa_supplicant.conf wpa_supplicant-wlan0.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Enable the &lt;code&gt;wpa_supplicant&lt;/code&gt; service for &lt;code&gt;wlan0&lt;/code&gt;:&lt;/p&gt;</description></item><item><title>Using Docker macvlan networks</title><link>https://blog.oddbit.com/post/2018-03-12-using-docker-macvlan-networks/</link><pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-03-12-using-docker-macvlan-networks/</guid><description>&lt;p&gt;A question that crops up regularly on &lt;a href="https://docs.docker.com/opensource/ways/#docker-users"&gt;#docker&lt;/a&gt; is &amp;ldquo;How do I attach
a container directly to my local network?&amp;rdquo; One possible answer to that
question is the &lt;a href="https://docs.docker.com/network/macvlan/"&gt;macvlan&lt;/a&gt; network type, which lets you create
&amp;ldquo;clones&amp;rdquo; of a physical interface on your host and use that to attach
containers directly to your local network. For the most part it works
great, but it does come with some minor caveats and limitations. I
would like to explore those here.&lt;/p&gt;</description></item><item><title>Listening for connections on all ports/any port</title><link>https://blog.oddbit.com/post/2018-02-27-listening-for-connections-on-a/</link><pubDate>Tue, 27 Feb 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-02-27-listening-for-connections-on-a/</guid><description>&lt;p&gt;On &lt;a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat"&gt;IRC&lt;/a&gt; &amp;ndash; and other online communities &amp;ndash; it is common to use a
&amp;ldquo;pastebin&amp;rdquo; service to share snippets of code, logs, and other
material, rather than pasting them directly into a conversation.
These services will typically return a URL that you can share with
others so that they can see the content in their browser.&lt;/p&gt;
&lt;p&gt;One of my favorite pastebin services is &lt;a href="http://termbin.com"&gt;termbin.com&lt;/a&gt;, because it
works from the command line using tools you probably already have
installed. Termbin runs the &lt;a href="https://github.com/solusipse/fiche"&gt;fiche&lt;/a&gt; service, which listens for TCP
connections on port 9999, reads any content that you provide, and then
returns a URL. For example, if I wanted to share my &lt;code&gt;iptables&lt;/code&gt;
configuration with someone I could just run:&lt;/p&gt;</description></item><item><title>Provider external networks (in an appropriate amount of detail)</title><link>https://blog.oddbit.com/post/2015-08-13-provider-external-networks-det/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2015-08-13-provider-external-networks-det/</guid><description>&lt;p&gt;In &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/"&gt;Quantum in Too Much Detail&lt;/a&gt;, I discussed the architecture of a
Neutron deployment in detail. Since that article was published,
Neutron gained the ability to handle multiple external networks with a
single L3 agent. While I &lt;a href="https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/"&gt;wrote about that&lt;/a&gt; back in 2014, I
covered the configuration side of it in much more detail than I
discussed the underlying network architecture. This post addresses
the architecture side.&lt;/p&gt;
&lt;h2 id="the-players"&gt;The players&lt;/h2&gt;
&lt;p&gt;This document describes the architecture that results from a
particular OpenStack configuration, specifically:&lt;/p&gt;</description></item><item><title>Docker networking with dedicated network containers</title><link>https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/</link><pubDate>Mon, 06 Oct 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/</guid><description>&lt;p&gt;The current version of Docker has a very limited set of networking
options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bridge&lt;/code&gt; &amp;ndash; connect a container to the Docker bridge&lt;/li&gt;
&lt;li&gt;&lt;code&gt;host&lt;/code&gt; &amp;ndash; run the container in the global network namespace&lt;/li&gt;
&lt;li&gt;&lt;code&gt;container:xxx&lt;/code&gt; &amp;ndash; connect a container to the network namespace of
another container&lt;/li&gt;
&lt;li&gt;&lt;code&gt;none&lt;/code&gt; &amp;ndash; do not configure any networking&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you need something more than that, you can use a tool like
&lt;a href="https://github.com/jpetazzo/pipework"&gt;pipework&lt;/a&gt; to provision additional network interfaces inside the
container, but this leads to a synchronization problem: &lt;code&gt;pipework&lt;/code&gt; can
only be used after your container is running. This means that when
starting your container, you must have logic that will wait until the
necessary networking is available before starting your service.&lt;/p&gt;</description></item><item><title>Four ways to connect a docker container to a local network</title><link>https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/</link><pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/</guid><description>&lt;p&gt;&lt;strong&gt;Update (2018-03-22)&lt;/strong&gt; Since I wrote this document back in 2014,
Docker has developed the &lt;a href="https://docs.docker.com/network/macvlan/"&gt;macvlan network
driver&lt;/a&gt;. That gives you a
&lt;em&gt;supported&lt;/em&gt; mechanism for direct connectivity to a local layer 2
network. I&amp;rsquo;ve &lt;a href="https://blog.oddbit.com/2018/03/12/using-docker-macvlan-networks/"&gt;written an article about working with the macvlan
driver&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;This article discusses four ways to make a Docker container appear on
a local network. These are not suggested as practical solutions, but
are meant to illustrate some of the underlying network technology
available in Linux.&lt;/p&gt;</description></item><item><title>Booting an instance with multiple fixed addresses</title><link>https://blog.oddbit.com/post/2014-05-28-booting-an-instance-with-multi/</link><pubDate>Wed, 28 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-28-booting-an-instance-with-multi/</guid><description>&lt;p&gt;This article expands on my answer to &lt;a href="https://ask.openstack.org/en/question/30690/add-multiple-specific-ips-to-instance/"&gt;Add multiple specific IPs to
instance&lt;/a&gt;, a question posted to &lt;a href="https://ask.openstack.org/"&gt;ask.openstack.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In order to serve out SSL services from an OpenStack instance, you
will generally want one local ip address for each SSL virtual host you
support. It is possible to create an instance with multiple fixed
addresses, but there are a few complications to watch out for.&lt;/p&gt;
&lt;h1 id="assumptions"&gt;Assumptions&lt;/h1&gt;
&lt;p&gt;This article assumes that the following resources exist:&lt;/p&gt;</description></item><item><title>Multiple external networks with a single L3 agent</title><link>https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/</link><pubDate>Wed, 28 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/</guid><description>&lt;p&gt;In the old days (so, like, last year), Neutron supported a single
external network per L3 agent. You would run something like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ neutron net-create external --router:external=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;hellip;and neutron would map this to the bridge defined in
&lt;code&gt;external_network_bridge&lt;/code&gt; in &lt;code&gt;/etc/neutron/l3_agent.ini&lt;/code&gt;. If you
wanted to support more than a single external network, you would need
to run multiple L3 agents, each with a unique value for
&lt;code&gt;external_network_bridge&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is now a better option available.&lt;/p&gt;</description></item><item><title>Video: Configuring OpenStack's external bridge on a single-interface system</title><link>https://blog.oddbit.com/post/2014-05-27-configuring-openstacks-externa/</link><pubDate>Tue, 27 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-27-configuring-openstacks-externa/</guid><description>&lt;p&gt;I&amp;rsquo;ve just put a video on Youtube that looks at the steps required to
set up the external bridge (&lt;code&gt;br-ex&lt;/code&gt;) on a single-interface system:&lt;/p&gt;
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;"&gt;
 &lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/8zFQG5mKwPk?autoplay=0&amp;amp;controls=1&amp;amp;end=0&amp;amp;loop=0&amp;amp;mute=0&amp;amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"&gt;&lt;/iframe&gt;
 &lt;/div&gt;</description></item><item><title>Open vSwitch and persistent MAC addresses</title><link>https://blog.oddbit.com/post/2014-05-23-open-vswitch-and-persistent-ma/</link><pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-23-open-vswitch-and-persistent-ma/</guid><description>&lt;p&gt;Normally I like to post solutions, but today&amp;rsquo;s post is about a
vexing problem to which I have not been able to find a solution.&lt;/p&gt;
&lt;p&gt;This started as a simple attempt to set up external connectivity on
an all-in-one Icehouse install deployed on an OpenStack instance. I
wanted to add &lt;code&gt;eth0&lt;/code&gt; to &lt;code&gt;br-ex&lt;/code&gt; in order to model a typical method for
providing external connectivity, but I ran into a very odd problem:
the system would boot and work fine for a few seconds, but would then
promptly lose network connectivity.&lt;/p&gt;</description></item><item><title>Solved: Open vSwitch and persistent MAC addresses</title><link>https://blog.oddbit.com/post/2014-05-23-solved-open-vswitch-and-persis/</link><pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-23-solved-open-vswitch-and-persis/</guid><description>&lt;p&gt;In my &lt;a href="https://blog.oddbit.com/2014/05/23/open-vswitch-and-persistent-ma/"&gt;previous post&lt;/a&gt; I discussed a problem I was having setting a
persistent MAC address on an OVS bridge device. It looks like the
short answer is, &amp;ldquo;don&amp;rsquo;t use &lt;code&gt;ip link set ...&lt;/code&gt;&amp;rdquo; for this purpose.&lt;/p&gt;
&lt;p&gt;You can set the bridge MAC address via &lt;code&gt;ovs-vsctl&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ovs-vsctl set bridge br-ex other-config:hwaddr=$MACADDR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So I&amp;rsquo;ve updated my &lt;code&gt;ifconfig-br-ex&lt;/code&gt; to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
OVSBOOTPROTO=dhcp
OVSDHCPINTERFACES=eth0
MACADDR=fa:16:3e:ef:91:ec
OVS_EXTRA=&amp;quot;set bridge br-ex other-config:hwaddr=$MACADDR&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;OVS_EXTRA&lt;/code&gt; parameter gets passed to the &lt;code&gt;add-br&lt;/code&gt; call like this:&lt;/p&gt;</description></item><item><title>Fedora and OVS Bridge Interfaces</title><link>https://blog.oddbit.com/post/2014-05-20-fedora-and-ovs-bridge-interfac/</link><pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-20-fedora-and-ovs-bridge-interfac/</guid><description>&lt;p&gt;I run OpenStack on my laptop, and I&amp;rsquo;ve been chasing down a pernicious
problem with OVS bridge interfaces under both F19 and F20. My
OpenStack environment relies on an OVS bridge device named &lt;code&gt;br-ex&lt;/code&gt; for
external connectivity and for making services available to OpenStack
instances, but after rebooting, &lt;code&gt;br-ex&lt;/code&gt; was consistently unconfigured,
which caused a variety of problems.&lt;/p&gt;
&lt;p&gt;This is the network configuration file for &lt;code&gt;br-ex&lt;/code&gt; on my system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
BOOTPROT=static
IPADDR=192.168.200.1
NETMASK=255.255.255.0
ONBOOT=yes
NM_CONTROLLED=no
ZONE=openstack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running &lt;code&gt;ifup br-ex&lt;/code&gt; would also fail to configure the interface, but
running &lt;code&gt;ifdown br-ex; ifup br-ex&lt;/code&gt; would configure things
appropriately.&lt;/p&gt;</description></item><item><title>Firewalld, NetworkManager, and OpenStack</title><link>https://blog.oddbit.com/post/2014-05-20-firewalld-and-openstack/</link><pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-20-firewalld-and-openstack/</guid><description>&lt;p&gt;These are my notes on making OpenStack play well with &lt;a href="https://fedoraproject.org/wiki/FirewallD"&gt;firewalld&lt;/a&gt;
and &lt;a href="https://wiki.gnome.org/Projects/NetworkManager"&gt;NetworkManager&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="networkmanager"&gt;NetworkManager&lt;/h2&gt;
&lt;p&gt;By default, NetworkManager attempts to start a DHCP client on every
new available interface. Since booting a single instance in OpenStack
can result in the creation of several virtual interfaces, this results
in a lot of:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;May 19 11:58:24 pk115wp-lkellogg NetworkManager[1357]: &amp;lt;info&amp;gt;
 Activation (qvb512640bd-ee) starting connection 'Wired connection 2'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can disable this behavior by adding the following to
&lt;code&gt;/etc/NetworkManager/NetworkManager.conf&lt;/code&gt;:&lt;/p&gt;</description></item><item><title>Visualizing Neutron Networking with GraphViz</title><link>https://blog.oddbit.com/post/2013-12-23-visualizing-network-with-graph/</link><pubDate>Mon, 23 Dec 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-12-23-visualizing-network-with-graph/</guid><description>&lt;p&gt;I&amp;rsquo;ve put together a few tools to help gather information about your
Neutron and network configuration and visualize it in different ways.
All of these tools are available as part of my &lt;a href="http://github.com/larsks/neutron-diag/"&gt;neutron-diag&lt;/a&gt;
repository on GitHub.&lt;/p&gt;
&lt;p&gt;In this post I&amp;rsquo;m going to look at a tool that will help you visualize
the connectivity of network devices on your system.&lt;/p&gt;
&lt;h2 id="mk-network-dot"&gt;mk-network-dot&lt;/h2&gt;
&lt;p&gt;There are a lot of devices involved in your Neutron network
configuration. Information originating in one of your instances has
two traverse &lt;em&gt;at least&lt;/em&gt; seven network devices before seeing the light
of day. Understanding how everything connects is critical if you&amp;rsquo;re
trying to debug problems in your envionment.&lt;/p&gt;</description></item><item><title>Quantum in Too Much Detail</title><link>https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/</link><pubDate>Thu, 14 Nov 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/</guid><description>&lt;blockquote&gt;
&lt;p&gt;I originally posted this article on
the &lt;a href="http://openstack.redhat.com/Networking_in_too_much_detail"&gt;RDO&lt;/a&gt;
website.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id="the-players"&gt;The players&lt;/h1&gt;
&lt;p&gt;This document describes the architecture that results from a
particular OpenStack configuration, specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quantum networking using GRE tunnels;&lt;/li&gt;
&lt;li&gt;A dedicated network controller;&lt;/li&gt;
&lt;li&gt;A single instance running on a compute host&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Much of the document will be relevant to other configurations, but
details will vary based on your choice of layer 2 connectivity, number
of running instances, and so forth.&lt;/p&gt;</description></item><item><title>Why does the Neutron documentation recommend three interfaces?</title><link>https://blog.oddbit.com/post/2013-10-28-why-does-the-neutron/</link><pubDate>Mon, 28 Oct 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-10-28-why-does-the-neutron/</guid><description>&lt;p&gt;The &lt;a href="http://docs.openstack.org/havana/install-guide/install/yum/content/neutron-install.dedicated-network-node.html"&gt;documentation for configuring Neutron&lt;/a&gt; recommends
that a network controller has three physical interfaces:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Before you start, set up a machine to be a dedicated network node.
Dedicated network nodes should have the following NICs: the
management NIC (called MGMT_INTERFACE), the data NIC (called
DATA_INTERFACE), and the external NIC (called EXTERNAL_INTERFACE).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;People occasionally ask, &amp;ldquo;why three interfaces? What if I only have
two?&amp;rdquo;, so I wanted to provide an extended answer that might help
people understand what the interfaces are for and what trade-offs are
involved in using fewer interfaces.&lt;/p&gt;</description></item><item><title>Waiting for networking using PowerShell</title><link>https://blog.oddbit.com/post/2012-11-04-powershell-wait-for-networking/</link><pubDate>Sun, 04 Nov 2012 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2012-11-04-powershell-wait-for-networking/</guid><description>&lt;p&gt;I&amp;rsquo;ve recently been exploring the world of Windows scripting, and I ran
into a small problem: I was running a script at system startup, and
the script was running before the network interface (which was using
DHCP) was configured.&lt;/p&gt;
&lt;p&gt;There are a number of common solutions proposed to this problem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Just wait for some period of time.&lt;/p&gt;
&lt;p&gt;This can work but it&amp;rsquo;s ugly, and because it doesn&amp;rsquo;t actually
verify the network state it can result in things breaking if some
problem prevents Windows from pulling a valid DHCP lease.&lt;/p&gt;</description></item><item><title>Chasing OpenStack idle connection timeouts</title><link>https://blog.oddbit.com/post/2012-07-30-openstack-idle-connection-time/</link><pubDate>Mon, 30 Jul 2012 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2012-07-30-openstack-idle-connection-time/</guid><description>&lt;h2 id="the-original-problem"&gt;The original problem&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve recently spent some time working on an OpenStack deployment. I ran into a
problem in which the &lt;a href="http://docs.openstack.org/trunk/openstack-compute/starter/content/Compute_Worker_nova-compute_-d1e232.html"&gt;compute service&lt;/a&gt; would frequently stop communicating
with the &lt;a href="http://www.amqp.org/"&gt;AMQP&lt;/a&gt; message broker (&lt;code&gt;qpidd&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In order to gather some data on the problem, I ran the following simple test:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wait &lt;code&gt;n&lt;/code&gt; minutes&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;nova boot ...&lt;/code&gt; to create an instance&lt;/li&gt;
&lt;li&gt;Wait a minute and see if the new instance becomes &lt;code&gt;ACTIVE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If it works, delete the instance, set &lt;code&gt;n&lt;/code&gt; = &lt;code&gt;2n&lt;/code&gt; and repeat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This demonstrated that communication was failing after about an hour, which
correlates rather nicely with the idle connection timeout on the firewall.&lt;/p&gt;</description></item><item><title>Rate limiting made simple</title><link>https://blog.oddbit.com/post/2011-12-26-simple-rate-limiting/</link><pubDate>Mon, 26 Dec 2011 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2011-12-26-simple-rate-limiting/</guid><description>&lt;p&gt;I use &lt;a href="http://www.crashplan.com/"&gt;CrashPlan&lt;/a&gt; as a backup service. It works and is very simple to set
up, but has limited options for controlling bandwidth. In fact, if you&amp;rsquo;re
running it on a headless system (e.g., a fileserver of some sort), your options
are effectively &amp;ldquo;too slow&amp;rdquo; and &amp;ldquo;CONSUME EVERYTHING&amp;rdquo;. There is an &lt;a href="https://crashplan.zendesk.com/entries/446273-throttle-bandwidth-by-hours?page=1#post_20799486"&gt;open
request&lt;/a&gt; to add time-based limitations to the application itself, but for
now I&amp;rsquo;ve solved this using a very simple traffic shaping configuration.
Because the learning curve for &amp;ldquo;tc&amp;rdquo; and friends is surprisingly high, I&amp;rsquo;m
putting &lt;a href="https://gist.github.com/larsks/4014881"&gt;my script&lt;/a&gt; here in the hopes
that other people might find it useful, and so that I can find it when I need
to do this again someday.&lt;/p&gt;</description></item><item><title>Linux UPnP Gateway</title><link>https://blog.oddbit.com/post/2010-01-29-linux-upnp-gateway/</link><pubDate>Fri, 29 Jan 2010 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2010-01-29-linux-upnp-gateway/</guid><description>&lt;p&gt;Like many other folks out there, I have several computers in my house connected to the outside world via a Linux box acting as a NAT gateway. I often want to use application such as BitTorrent and Freenet, which require that a number of ports be forwarded from my external connection to the particular computer on which I happen to be working. It turns out there&amp;rsquo;s a protocol for this, called &lt;a href="http://en.wikipedia.org/wiki/Universal_Plug_and_Play"&gt;UPnP&lt;/a&gt;. From Wikipedia:&lt;/p&gt;</description></item></channel></rss>