<!doctype html><html lang=en><head><title>Networking :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/tags/networking/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Networking"><meta property="og:description" content><meta property="og:url" content="https://blog.oddbit.com/tags/networking/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/networking/rss.xml rel=alternate type=application/rss+xml title=blog.oddbit.com></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><h1>Posts for: #Networking</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/>NAT between identical networks using VRF</a></h1><div class=post-meta><time class=post-date>2023-02-19</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/mininet/>mininet</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/nat/>nat</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/routing/>routing</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/stackexchange/>stackexchange</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/vrf/>vrf</a>&nbsp;
</span><img src=/post/2023-02-19-vrf-and-nat/cover.jpg class=post-cover alt="NAT between identical networks using VRF" title="Cover Image"><div class=post-content><p>Last week, Oskar Stenberg asked on <a href=https://unix.stackexchange.com/q/735931/4989>Unix & Linux</a> if it were possible to configure connectivity between two networks, both using the same address range, without involving network namespaces. That is, given this high level view of the network&mldr;</p><p><a href="https://excalidraw.com/#json=uuXRRZ2ybaAXiUvbQVkNO,krx3lsbf12c-tDhuWtRjbg"><img src=/post/2023-02-19-vrf-and-nat/the-problem.svg alt="two networks with the same address range connected by a host named “middleman”"></a></p><p>&mldr;can we set things up so that hosts on the &ldquo;inner&rdquo; network can communicate with hosts on the &ldquo;outer&rdquo; network using the range <code>192.168.3.0/24</code>, and similarly for communication in the other direction?</p></div><div><a class="read-more button inline" href=/post/2023-02-19-vrf-and-nat/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2023-02-14-whos-got-the-packet/>Packet, packet, who&rsquo;s got the packet?</a></h1><div class=post-meta><time class=post-date>2023-02-14</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/kernel/>kernel</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/routing/>routing</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ebpf/>ebpf</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/pwru/>pwru</a>&nbsp;
</span><img src=/post/2023-02-14-whos-got-the-packet/cover.jpg class=post-cover alt="Packet, packet, who's got the packet?" title="Cover Image"><div class=post-content><p>In <a href=https://unix.stackexchange.com/q/735522/4989>this question</a>, August Vrubel has some C code that sets up a <a href=https://docs.kernel.org/networking/tuntap.html>tun</a> interface and then injects a packet, but the packet seemed to disappear into the ether. In this post, I&rsquo;d like to take a slightly extended look at <a href=https://unix.stackexchange.com/a/735534/4989>my answer</a> because I think it&rsquo;s a great opportunity for learning a bit more about performing network diagnostics.</p><p>The original code looked like this:</p><div class=collapsable-code><input id=835974162 type=checkbox>
<label for=835974162><span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>original sendpacket.c</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-c><code>

#include &lt;arpa/inet.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;linux/if.h&gt;
#include &lt;linux/if_tun.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;poll.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static int tunAlloc(void) {
  int fd;
  struct ifreq ifr = {.ifr_name = &#34;tun0&#34;, .ifr_flags = IFF_TUN | IFF_NO_PI};

  fd = open(&#34;/dev/net/tun&#34;, O_RDWR);
  ioctl(fd, TUNSETIFF, (void *)&amp;ifr);
  ioctl(fd, TUNSETOWNER, geteuid());
  return fd;
}

// this is a test
static void bringInterfaceUp(void) {
  int sock;
  struct sockaddr_in addr = {.sin_family = AF_INET};
  struct ifreq ifr = {.ifr_name = &#34;tun0&#34;};

  inet_aton(&#34;172.30.0.1&#34;, &amp;addr.sin_addr);
  memcpy(&amp;ifr.ifr_addr, &amp;addr, sizeof(struct sockaddr));

  sock = socket(AF_INET, SOCK_DGRAM, 0);
  ioctl(sock, SIOCSIFADDR, &amp;ifr);
  ioctl(sock, SIOCGIFFLAGS, &amp;ifr);
  ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
  ioctl(sock, SIOCSIFFLAGS, &amp;ifr);
  close(sock);
}

static void emitPacket(int tap_fd) {
  unsigned char packet[] = {
      0x45, 0x00, 0x00, 0x3c, 0xd8, 0x6f, 0x40, 0x00, 0x3f, 0x06, 0x08, 0x91,
      172,  30,   0,    1,    192,  168,  255,  8,    0xa2, 0x9a, 0x27, 0x11,
      0x80, 0x0b, 0x63, 0x79, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xfa, 0xf0,
      0x89, 0xd8, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a,
      0x5b, 0x76, 0x5f, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07};

  write(tap_fd, packet, sizeof(packet));
}

int main() {
  int tap_fd;

  tap_fd = tunAlloc();
  bringInterfaceUp();
  emitPacket(tap_fd);
  close(tap_fd);

  return 0;
}



</code></pre></div><p>A problem with the original code is that it creates the interface, sends the packet, and tears down the interface with no delays, making it very difficult to inspect the interface configuration, perform packet captures, or otherwise figure out what&rsquo;s going on.</p></div><div><a class="read-more button inline" href=/post/2023-02-14-whos-got-the-packet/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2022-11-16-home-ipv6-vlan/>Setting up an IPv6 VLAN</a></h1><div class=post-meta><time class=post-date>2022-11-16</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ipv6/>ipv6</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/vlan/>vlan</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/edgerouter/>edgerouter</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/nmcli/>nmcli</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networkmanager/>networkmanager</a>&nbsp;
</span><img src=/post/2022-11-16-home-ipv6-vlan/cover.jpg class=post-cover alt="Setting up an IPv6 VLAN" title="Cover Image"><div class=post-content><p>My internet service provider (<a href=https://www.verizon.com/home/fios/>FIOS</a>) doesn&rsquo;t yet (sad face) offer IPv6 capable service, so I&rsquo;ve set up an IPv6 tunnel using the <a href=https://www.tunnelbroker.net/>Hurricane Electric</a> tunnel broker. I want to provide IPv6 connectivity to multiple systems in my house, but not to <strong>all</strong> systems in my house <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. In order to meet those requirements, I&rsquo;m going to set up the tunnel on the router, and then expose connectivity over an IPv6-only VLAN. In this post, we&rsquo;ll walk through the steps necessary to set that up.</p></div><div><a class="read-more button inline" href=/post/2022-11-16-home-ipv6-vlan/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/>Creating a VXLAN overlay network with Open vSwitch</a></h1><div class=post-meta><time class=post-date>2021-04-17</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/virtualization/>virtualization</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openvswitch/>openvswitch</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/vxlan/>vxlan</a>&nbsp;</span><div class=post-content><p>In this post, we&rsquo;ll walk through the process of getting virtual
machines on two different hosts to communicate over an overlay network
created using the support for VXLAN in <a href=https://www.openvswitch.org/>Open vSwitch</a> (or OVS).</p><h2 id=the-test-environment>The test environment</h2><p>For this post, I&rsquo;ll be working with two systems:</p><ul><li><code>node0.ovs.virt</code> at address 192.168.122.107</li><li><code>node1.ovs.virt</code> at address 192.168.122.174</li></ul><p>These hosts are running CentOS 8, although once we get past the
package installs the instructions will be similar for other
distributions.</p></div><div><a class="read-more button inline" href=/post/2021-04-17-vm-ovs-vxlan/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/>OpenShift and CNV: Exposing virtualized services</a></h1><div class=post-meta><time class=post-date>2020-07-30</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/cnv/>cnv</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift-and-cnv/>openshift-and-cnv</a>&nbsp;</span><div class=post-content><p>This is the second in a <a href=/tag/openshift-and-cnv>series of posts</a> about my experience working
with <a href=https://www.openshift.com/>OpenShift</a> and <a href=https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization>CNV</a>. In this post, I&rsquo;ll be taking a look
at how to expose services on a virtual machine once you&rsquo;ve git it up
and running.</p><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#overview>Overview</a></li><li><a href=#connectivity-options>Connectivity options</a></li><li><a href=#direct-attachment>Direct attachment</a></li><li><a href=#using-an-openshift-service>Using an OpenShift Service</a><ul><li><a href=#exposing-services-on-nodeports>Exposing services on NodePorts</a></li><li><a href=#exposing-services-on-cluster-external-ipso>Exposing services on cluster external IPso</a></li><li><a href=#exposing-services-using-a-loadbalancer>Exposing services using a LoadBalancer</a></li></ul></li></ul></nav><h2 id=tldr>TL;DR</h2><p>Networking seems to be a weak area for CNV right now. Out of the box,
your options for exposing a service on a virtual machine on a public
address at a well known port are slim.</p></div><div><a class="read-more button inline" href=/post/2020-07-30-openshift-and-cnv-part-2-expos/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2020-02-15-configuring-open-vswitch-with/>Configuring Open vSwitch with nmcli</a></h1><div class=post-meta><time class=post-date>2020-02-15</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networkmanager/>networkmanager</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/nmcli/>nmcli</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openvswitch/>openvswitch</a>&nbsp;</span><div class=post-content><p>I recently acquired a managed switch for my home office in order to segment a few devices off onto their own isolated vlan. As part of this, I want to expose these vlans on my desktop using Open vSwitch (OVS), and I wanted to implement the configuration using NetworkManager rather than either relying on the legacy <code>/etc/sysconfig/network-scripts</code> scripts or rolling my own set of services. These are my notes in case I ever have to do this again.</p></div><div><a class="read-more button inline" href=/post/2020-02-15-configuring-open-vswitch-with/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/>OVN and DHCP: A minimal example</a></h1><div class=post-meta><time class=post-date>2019-12-19</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ovn/>ovn</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openvswitch/>openvswitch</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;</span><div class=post-content><h1 id=introduction>Introduction</h1><p>A long time ago, I wrote an article <a href=https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/>all about OpenStack Neutron</a> (which at that time was called Quantum). That served as an excellent reference for a number of years, but if you&rsquo;ve deployed a recent version of OpenStack you may have noticed that the network architecture looks completely different. The network namespaces previously used to implement routers and dhcp servers are gone (along with iptables rules and other features), and have been replaced by OVN (&ldquo;Open Virtual Network&rdquo;). What is OVN? How does it work? In this article, I&rsquo;d like to explore a minimal OVN installation to help answer these questions.</p></div><div><a class="read-more button inline" href=/post/2019-12-19-ovn-and-dhcp/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2018-06-14-configuring-a-static-address-f/>Configuring a static address for wlan0 on Raspbian Stretch</a></h1><div class=post-meta><time class=post-date>2018-06-14</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/raspberrypi/>raspberrypi</a>&nbsp;</span><div class=post-content><p>Recent releases of Raspbian have adopted the use of <a href=http://manpages.ubuntu.com/manpages/trusty/man8/dhcpcd5.8.html>dhcpcd</a> to
manage both dynamic and static interface configuration. If you would
prefer to use the traditional <code>/etc/network/interfaces</code> mechanism
instead, follow these steps.</p><ol><li><p>First, disable <code>dhcpcd</code> and <code>wpa_supplicant</code>.</p><pre><code> systemctl disable --now dhdpcd wpa_supplicant
</code></pre></li><li><p>You will need a <code>wpa_supplicant</code> configuration for <code>wlan0</code> in
<code>/etc/wpa_supplicant/wpa_supplicant-wlan0.conf</code>.</p><p>If you already have an appropriate configuration in
<code>/etc/wpa_supplicant/wpa_supplicant.conf</code>, you can just symlink the
file:</p><pre><code>  cd /etc/wpa_supplicant
  ln -s wpa_supplicant.conf wpa_supplicant-wlan0.conf
</code></pre></li><li><p>Enable the <code>wpa_supplicant</code> service for <code>wlan0</code>:</p></div><div><a class="read-more button inline" href=/post/2018-06-14-configuring-a-static-address-f/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2018-03-12-using-docker-macvlan-networks/>Using Docker macvlan networks</a></h1><div class=post-meta><time class=post-date>2018-03-12</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>A question that crops up regularly on <a href=https://docs.docker.com/opensource/ways/#docker-users>#docker</a> is &ldquo;How do I attach
a container directly to my local network?&rdquo; One possible answer to that
question is the <a href=https://docs.docker.com/network/macvlan/>macvlan</a> network type, which lets you create
&ldquo;clones&rdquo; of a physical interface on your host and use that to attach
containers directly to your local network. For the most part it works
great, but it does come with some minor caveats and limitations. I
would like to explore those here.</p></div><div><a class="read-more button inline" href=/post/2018-03-12-using-docker-macvlan-networks/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2018-02-27-listening-for-connections-on-a/>Listening for connections on all ports/any port</a></h1><div class=post-meta><time class=post-date>2018-02-27</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;</span><div class=post-content><p>On <a href=https://en.wikipedia.org/wiki/Internet_Relay_Chat>IRC</a> &ndash; and other online communities &ndash; it is common to use a
&ldquo;pastebin&rdquo; service to share snippets of code, logs, and other
material, rather than pasting them directly into a conversation.
These services will typically return a URL that you can share with
others so that they can see the content in their browser.</p><p>One of my favorite pastebin services is <a href=http://termbin.com>termbin.com</a>, because it
works from the command line using tools you probably already have
installed. Termbin runs the <a href=https://github.com/solusipse/fiche>fiche</a> service, which listens for TCP
connections on port 9999, reads any content that you provide, and then
returns a URL. For example, if I wanted to share my <code>iptables</code>
configuration with someone I could just run:</p></div><div><a class="read-more button inline" href=/post/2018-02-27-listening-for-connections-on-a/>[read more]</a></div></article><div class=pagination><div class=pagination__buttons><a href=/tags/networking/page/2/ class="button inline next">[<span class=button__text>Older posts</span>] ></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>