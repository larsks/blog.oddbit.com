<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/git/</link><description>Recent content in Git on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 10:58:10 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/git/rss.xml" rel="self" type="application/rss+xml"/><item><title>Delete GitHub workflow runs using the gh cli</title><link>https://blog.oddbit.com/post/2022-09-22-delete-workflow-runs/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2022-09-22-delete-workflow-runs/</guid><description>&lt;p&gt;Hello, future me. This is for you next time you want to do this.&lt;/p&gt;
&lt;p&gt;When setting up the CI for a project I will sometimes end up with a tremendous clutter of workflow runs. Sometimes they have embarrassing mistakes. Who wants to show that to people? I was trying to figure out how to bulk delete workflow runs from the CLI, and I came up with something that works:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;gh run list --json databaseId -q &amp;#39;.[].databaseId&amp;#39; |
 xargs -IID gh api \
 &amp;#34;repos/$(gh repo view --json nameWithOwner -q .nameWithOwner)/actions/runs/ID&amp;#34; \
 -X DELETE
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will delete &lt;em&gt;all&lt;/em&gt; (well, up to 20, or whatever you set in &lt;code&gt;--limit&lt;/code&gt;) your workflow runs. You can add flags to &lt;code&gt;gh run list&lt;/code&gt; to filter runs by workflow or by triggering user.&lt;/p&gt;</description></item><item><title>Tools for writing about Git</title><link>https://blog.oddbit.com/post/2021-02-27-git-doc-tools/</link><pubDate>Sat, 27 Feb 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-02-27-git-doc-tools/</guid><description>&lt;p&gt;I sometimes find myself writing articles or documentation about
&lt;a href="https://git-scm.org"&gt;git&lt;/a&gt;, so I put together a couple of terrible hacks for generating
reproducible histories and pretty graphs of those histories.&lt;/p&gt;
&lt;h2 id="git-synth"&gt;git synth&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://github.com/larsks/git-snippets/blob/master/git-synth"&gt;&lt;code&gt;git synth&lt;/code&gt;&lt;/a&gt; command reads a &lt;a href="https://yaml.org/"&gt;YAML&lt;/a&gt; description of a
repository and executes the necessary commands to reproduce that
history. It allows you set the name and email address of the author
and committer as well as static date, so you every time you generate
the repository you can identical commit ids.&lt;/p&gt;</description></item><item><title>Editing a commit message without git rebase</title><link>https://blog.oddbit.com/post/2021-02-18-editing-a-commit-message-witho/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-02-18-editing-a-commit-message-witho/</guid><description>&lt;p&gt;While working on a pull request I will make liberal use of &lt;a href="https://git-scm.com/docs/git-rebase"&gt;git
rebase&lt;/a&gt; to clean up a series of commits: squashing typos,
re-ordering changes for logical clarity, and so forth. But there are
some times when all I want to do is change a commit message somewhere
down the stack, and I was wondering if I had any options for doing
that without reaching for &lt;code&gt;git rebase&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It turns out the answer is &amp;ldquo;yes&amp;rdquo;, as long as you have a linear
history.&lt;/p&gt;</description></item><item><title>Avoid rebase hell: squashing without rebasing</title><link>https://blog.oddbit.com/post/2019-06-17-avoid-rebase-hell-squashing-wi/</link><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-06-17-avoid-rebase-hell-squashing-wi/</guid><description>&lt;p&gt;You&amp;rsquo;re working on a pull request. You&amp;rsquo;ve been working on a pull request for a while, and due to lack of sleep or inebriation you&amp;rsquo;ve been merging changes into your feature branch rather than rebasing. You now have a pull request that looks like this (I&amp;rsquo;ve marked merge commits with the text &lt;code&gt;[merge]&lt;/code&gt;):&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;7e181479 Adds methods for widget sales
0487162 [merge] Merge remote-tracking branch &amp;#39;origin/master&amp;#39; into my_feature
76ee81c [merge] Merge branch &amp;#39;my_feature&amp;#39; of https://github.com/my_user_name/widgets into my_feature
981aab4 Adds api for the widget service.
b048836 Includes fixes suggested by reviewer.
3dd0c22 adds changes requested by reviewer
5891db2 [merge] fixing merge conflicts
2e226e4 fixes suggestions given by the reviewer
da1e85c Adds gadget related API spec
c555cc1 Adds doodad related API spec
e5beb3e Adds api for update and delete of widgets
c43bade Adds api for creating widgets
deaa962 Adds all get methods for listing widgets
9de79ab Adds api for showing a widget and simple data model
8288ab1 Adds api framework for widget service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You know that&amp;rsquo;s a mess, so you try to fix it by running &lt;code&gt;git rebase -i master&lt;/code&gt; and squashing everything together&amp;hellip;and you find yourself stuck in an endless maze of merge conflicts. There has to be a better way!&lt;/p&gt;</description></item><item><title>Git Etiquette: Commit messages and pull requests</title><link>https://blog.oddbit.com/post/2019-06-14-git-etiquette-commit-messages/</link><pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-06-14-git-etiquette-commit-messages/</guid><description>&lt;h2 id="always-work-on-a-branch-never-commit-on-master"&gt;Always work on a branch (never commit on master)&lt;/h2&gt;
&lt;p&gt;When working with an upstream codebase, always make your changes on a feature branch rather than your local &lt;code&gt;master&lt;/code&gt; branch. This will make it easier to keep your local &lt;code&gt;master&lt;/code&gt; branch current with respect to upstream, and can help avoid situations in which you accidentally overwrite your local changes or introduce unnecessary merge commits into your history.&lt;/p&gt;
&lt;h2 id="rebase-instead-of-merge"&gt;Rebase instead of merge&lt;/h2&gt;
&lt;p&gt;If you need to incorporate changes from the upstream &lt;code&gt;master&lt;/code&gt; branch in the feature branch on which you are currently doing, bring in those changes using &lt;code&gt;git rebase&lt;/code&gt; rather than &lt;code&gt;git merge&lt;/code&gt;. This process will generally start by ensuring that your local copy of the upstream &lt;code&gt;master&lt;/code&gt; is current:&lt;/p&gt;</description></item><item><title>Making sure your Gerrit changes aren't broken</title><link>https://blog.oddbit.com/post/2017-01-22-making-sure-your-gerrit-change/</link><pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2017-01-22-making-sure-your-gerrit-change/</guid><description>&lt;p&gt;It&amp;rsquo;s a bit of an embarrassment when you submit a review to Gerrit only
to have it fail CI checks immediately because of something as simple
as a syntax error or pep8 failure that you should have caught yourself
before submitting&amp;hellip;but you forgot to run your validations before
submitting the change.&lt;/p&gt;
&lt;p&gt;In many cases you can alleviate this through the use of the git
&lt;code&gt;pre-commit&lt;/code&gt; hook, which will run every time you commit changes
locally. You can have the hook run &lt;code&gt;tox&lt;/code&gt; or whatever tool your
project uses for validation on every commit. This works okay for
simple cases, but if the validation takes more than a couple of
seconds the delay can be disruptive to the flow of your work.&lt;/p&gt;</description></item><item><title>A collection of git tips</title><link>https://blog.oddbit.com/post/2016-02-19-a-collection-of-git-tips/</link><pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2016-02-19-a-collection-of-git-tips/</guid><description>&lt;p&gt;This is a small collection of simple &lt;code&gt;git&lt;/code&gt; tips and tricks I use to
make my life easier.&lt;/p&gt;
&lt;h2 id="quickly-amend-an-existing-commit-with-new-files"&gt;Quickly amend an existing commit with new files&lt;/h2&gt;
&lt;p&gt;I have this alias in place that will amend the current commit while
automatically re-using the existing commit message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias.fix=commit --amend -C HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, fixing a review becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim some/file/somewhere
$ git add -u
$ git fix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which I find much more convenient than &lt;code&gt;git commit --amend&lt;/code&gt;, following
by saving the commit message.&lt;/p&gt;</description></item><item><title>Automatic git cache</title><link>https://blog.oddbit.com/post/2015-10-19-automatic-git-cache/</link><pubDate>Mon, 19 Oct 2015 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2015-10-19-automatic-git-cache/</guid><description>&lt;p&gt;This post is in response to a comment someone made on irc earlier
today:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[I] would really like a git lookaside cache which operated on an upstream
repo, but pulled objects locally when they&amp;rsquo;re available&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this post I present a proof-of-concept solution to this request.
Please note that thisand isn&amp;rsquo;t something that has actually been used
or tested anywhere!&lt;/p&gt;
&lt;p&gt;If you access a git repository via &lt;code&gt;ssh&lt;/code&gt;, it&amp;rsquo;s easy to provide a
wrapper for git operations via the &lt;code&gt;command=&lt;/code&gt; option in an
&lt;code&gt;authorized_keys&lt;/code&gt; file. We can take advantage of this to update a a
local &amp;ldquo;cache&amp;rdquo; repository prior to responding to a &lt;code&gt;clone&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt;/etc.
operation.&lt;/p&gt;</description></item><item><title>Teach git about GIT_SSL_CIPHER_LIST</title><link>https://blog.oddbit.com/post/2015-05-08-git-ssl-cipher-list/</link><pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2015-05-08-git-ssl-cipher-list/</guid><description>&lt;p&gt;Someone named &lt;a href="https://stackoverflow.com/users/4713895/hithard"&gt;hithard&lt;/a&gt; on &lt;a href="https://stackoverflow.com/"&gt;StackOverflow&lt;/a&gt; was trying to clone a git repository via https, and was &lt;a href="https://stackoverflow.com/a/30090725/147356"&gt;running into an odd error&lt;/a&gt;: &amp;ldquo;Cannot communicate securely with peer: no common encryption algorithm(s).&amp;rdquo;. This was due to the fact that the server (&lt;code&gt;openhatch.org&lt;/code&gt;) was configured to use a cipher suite that was not supported by default in the underlying SSL library (which could be either &lt;a href="https://www.openssl.org/"&gt;OpenSSL&lt;/a&gt; or &lt;a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS"&gt;NSS&lt;/a&gt;, depending on how git was built).&lt;/p&gt;
&lt;p&gt;Many applications allow the user to configure an explicit list of ciphers to consider when negotiating a secure connection. For example, &lt;a href="https://curl.haxx.se/"&gt;curl&lt;/a&gt; has the &lt;a href="https://curl.haxx.se/libcurl/c/CURLOPT_SSL_CIPHER_LIST.html"&gt;CURLOPT_SSL_CIPHER_LIST&lt;/a&gt; option. This turns out to be especially relevant because git relies on &lt;a href="https://curl.haxx.se/libcurl/"&gt;libcurl&lt;/a&gt; for all of its http operations, which means all we need to do is (a) create a new configuration option for git, and then (b) pass that value through to libcurl.&lt;/p&gt;</description></item><item><title>Using tools badly: time shifting git commits with Workinghours</title><link>https://blog.oddbit.com/post/2015-04-10-workinghours-time-shifting-git/</link><pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2015-04-10-workinghours-time-shifting-git/</guid><description>&lt;p&gt;This is a terrible hack. If you are easily offended by bad ideas
implemented poorly, move along!&lt;/p&gt;
&lt;p&gt;You are working on a wonderful open source project&amp;hellip;but you are not
&lt;em&gt;supposed&lt;/em&gt; to be working on that project! You&amp;rsquo;re supposed to be doing
your &lt;em&gt;real&lt;/em&gt; work! Unfortunately, your extra-curricular activity is
well documented in the git history of your project for all to see:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.oddbit.com/post/2015-04-10-workinghours-time-shifting-git/repo-before.png" alt="Heatmap of original commit history"&gt;&lt;/p&gt;
&lt;p&gt;And now your boss knows why the TPS reports are late. You need
&lt;a href="https://github.com/larsks/workinghours.git"&gt;workinghours&lt;/a&gt;, a terrible utility for doing awful things to your
repository history. &lt;a href="https://github.com/larsks/workinghours.git"&gt;Workinghours&lt;/a&gt; will programatically time shift
your git commits so that they appear to have happened within specified
time intervals (for example, &amp;ldquo;between 7PM and midnight&amp;rdquo;).&lt;/p&gt;</description></item><item><title>Tracking down a kernel bug with git bisect</title><link>https://blog.oddbit.com/post/2014-07-21-tracking-down-a-kernel-bug-wit/</link><pubDate>Mon, 21 Jul 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-07-21-tracking-down-a-kernel-bug-wit/</guid><description>&lt;p&gt;After a recent upgrade of my Fedora 20 system to kernel 3.15.mumble, I
started running into a problem (&lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=1121345"&gt;BZ 1121345&lt;/a&gt;) with my &lt;a href="https://www.docker.com/"&gt;Docker&lt;/a&gt;
containers. Operations such as &lt;code&gt;su&lt;/code&gt; or &lt;code&gt;runuser&lt;/code&gt; would fail with the
singularly unhelpful &lt;code&gt;System error&lt;/code&gt; message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -ti fedora /bin/bash
bash-4.2# su -c 'uptime'
su: System error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hooking up something (like, say, &lt;code&gt;socat unix-listen:/dev/log -&lt;/code&gt;) to
&lt;code&gt;/dev/log&lt;/code&gt; revealed that the system was logging:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Jul 19 14:31:18 su: PAM audit_log_acct_message() failed: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Downgrading the kernel to 3.14 immediately resolved the problem,
suggesting that this was at least partly a kernel issue. This seemed
like a great opportunity to play with the &lt;a href="http://git-scm.com/docs/git-bisect"&gt;git bisect&lt;/a&gt; command,
which uses a binary search to find which commit introduced a
particular problem.&lt;/p&gt;</description></item><item><title>Automatic maintenance of tag feeds</title><link>https://blog.oddbit.com/post/2013-11-22-automatic-maintenanc/</link><pubDate>Fri, 22 Nov 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-11-22-automatic-maintenanc/</guid><description>&lt;p&gt;I recently added some scripts to automatically generate tag feeds for
my blog when pushing new content. I&amp;rsquo;m using GitHub Pages to publish
everything, so it seemed easiest to make tag generation part of a
&lt;code&gt;pre-push&lt;/code&gt; hook (new in Git 1.8.2). This hook is run automatically as
part of the &lt;code&gt;git push&lt;/code&gt; operation, so it&amp;rsquo;s the perfect place to insert
generated content that must be kept in sync with posts on the blog.&lt;/p&gt;</description></item><item><title>Git fetch, tags, remotes, and more</title><link>https://blog.oddbit.com/post/2012-07-27-git-fetch-tags-et-al/</link><pubDate>Fri, 27 Jul 2012 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2012-07-27-git-fetch-tags-et-al/</guid><description>&lt;p&gt;I’ve been playing around with Git, Puppet, and GPG verification of our
Puppet configuration repository, and these are some random facts about
Git that have come to light as part of the process.&lt;/p&gt;
&lt;p&gt;If you want to pull both changes &lt;em&gt;and&lt;/em&gt; new tags from a remote
repository, you can do this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git fetch
$ git fetch --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or you can do this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git fetch --tags
$ git fetch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What’s the difference? &lt;code&gt;git fetch&lt;/code&gt; will leave &lt;code&gt;FETCH_HEAD&lt;/code&gt; pointing at
the remote &lt;code&gt;HEAD&lt;/code&gt;, whereas &lt;code&gt;git fetch --tags&lt;/code&gt; will leave &lt;code&gt;FETCH_HEAD&lt;/code&gt;
pointing at the most recent tag.&lt;/p&gt;</description></item><item><title>Pushing a Git repository to Subversion</title><link>https://blog.oddbit.com/post/2010-05-11-pushing-git-repository-to-subv/</link><pubDate>Tue, 11 May 2010 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2010-05-11-pushing-git-repository-to-subv/</guid><description>&lt;p&gt;I recently set up a git repository server (using &lt;a href="http://scie.nti.st/2007/11/14/hosting-git-repositories-the-easy-and-secure-way"&gt;gitosis&lt;/a&gt; and &lt;a href="https://git.wiki.kernel.org/index.php/Gitweb"&gt;gitweb&lt;/a&gt;). Among the required features of the system was the ability to publish the git repository to a read-only Subversion repository. This sounds simple in principle but in practice proved to be a bit tricky.&lt;/p&gt;
&lt;p&gt;Git makes an excellent Subversion client. You can use the git svn &amp;hellip; series of commands to pull a remote Subversion repository into a local git working tree and then have all the local advantages of git forcing the central code repository to change version control software. An important aspect of this model is that:&lt;/p&gt;</description></item><item><title>Cleaning up Subversion with Git</title><link>https://blog.oddbit.com/post/2010-01-29-cleaning-up-subversion-with-gi/</link><pubDate>Fri, 29 Jan 2010 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2010-01-29-cleaning-up-subversion-with-gi/</guid><description>&lt;h1 id="overview"&gt;Overview&lt;/h1&gt;
&lt;p&gt;At my office, we have a crufty &lt;a href="http://subversion.tigris.org/"&gt;Subversion&lt;/a&gt; repository (dating back to early 2006) that contains a jumble of unrelated projects. We would like to split this single repository up into a number of smaller repositories, each following the recommended trunk/tags/branches repository organization.&lt;/p&gt;
&lt;p&gt;What we want to do is move a project from a path that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.../projects/some-project-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To a new repository using the recommended Subversion repository layout, like this:&lt;/p&gt;</description></item></channel></rss>