<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>openvswitch on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/openvswitch/</link><description>Recent content in openvswitch on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Sat, 17 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/openvswitch/rss.xml" rel="self" type="application/rss+xml"/><item><title>Creating a VXLAN overlay network with Open vSwitch</title><link>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</guid><description>In this post, we&amp;rsquo;ll walk through the process of getting virtual machines on two different hosts to communicate over an overlay network created using the support for VXLAN in Open vSwitch (or OVS).
The test environment For this post, I&amp;rsquo;ll be working with two systems:
node0.ovs.virt at address 192.168.122.107 node1.ovs.virt at address 192.168.122.174 These hosts are running CentOS 8, although once we get past the package installs the instructions will be similar for other distributions.</description><content>&lt;p>In this post, we&amp;rsquo;ll walk through the process of getting virtual
machines on two different hosts to communicate over an overlay network
created using the support for VXLAN in &lt;a href="https://www.openvswitch.org/">Open vSwitch&lt;/a> (or OVS).&lt;/p>
&lt;h2 id="the-test-environment">The test environment&lt;/h2>
&lt;p>For this post, I&amp;rsquo;ll be working with two systems:&lt;/p>
&lt;ul>
&lt;li>&lt;code>node0.ovs.virt&lt;/code> at address 192.168.122.107&lt;/li>
&lt;li>&lt;code>node1.ovs.virt&lt;/code> at address 192.168.122.174&lt;/li>
&lt;/ul>
&lt;p>These hosts are running CentOS 8, although once we get past the
package installs the instructions will be similar for other
distributions.&lt;/p>
&lt;p>While reading through this post, remember that unless otherwise
specified we&amp;rsquo;re going to be running the indicated commands on &lt;em>both&lt;/em>
hosts.&lt;/p>
&lt;h2 id="install-packages">Install packages&lt;/h2>
&lt;p>Before we can get started configuring things we&amp;rsquo;ll need to install OVS
and &lt;a href="https://libvirt.org/">libvirt&lt;/a>. While &lt;code>libvirt&lt;/code> is included with the base CentOS
distribution, for OVS we&amp;rsquo;ll need to add both the &lt;a href="https://fedoraproject.org/wiki/EPEL">EPEL&lt;/a> repository
as well as a recent CentOS &lt;a href="https://www.openstack.org/">OpenStack&lt;/a> repository (OVS is included
in the CentOS OpenStack repositories because it is required by
OpenStack&amp;rsquo;s networking service):&lt;/p>
&lt;pre tabindex="0">&lt;code>yum -y install epel-release centos-release-openstack-victoria
&lt;/code>&lt;/pre>&lt;p>With these additional repositories enabled we can now install the
required packages:&lt;/p>
&lt;pre tabindex="0">&lt;code>yum -y install \
libguestfs-tools-c \
libvirt \
libvirt-daemon-kvm \
openvswitch2.15 \
tcpdump \
virt-install
&lt;/code>&lt;/pre>&lt;h2 id="enable-services">Enable services&lt;/h2>
&lt;p>We need to start both the &lt;code>libvirtd&lt;/code> and &lt;code>openvswitch&lt;/code> services:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable --now openvswitch libvirtd
&lt;/code>&lt;/pre>&lt;p>This command will (a) mark the services to start automatically when
the system boots and (b) immediately start the service.&lt;/p>
&lt;h2 id="configure-libvirt">Configure libvirt&lt;/h2>
&lt;p>When &lt;code>libvirt&lt;/code> is first installed it doesn&amp;rsquo;t have any configured
storage pools. Let&amp;rsquo;s create one in the default location,
&lt;code>/var/lib/libvirt/images&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>virsh pool-define-as default --type dir --target /var/lib/libvirt/images
&lt;/code>&lt;/pre>&lt;p>We need to mark the pool active, and we might as well configure it to
activate automatically next time the system boots:&lt;/p>
&lt;pre tabindex="0">&lt;code>virsh pool-start default
virsh pool-autostart default
&lt;/code>&lt;/pre>&lt;h2 id="configure-open-vswitch">Configure Open vSwitch&lt;/h2>
&lt;h3 id="create-the-bridge">Create the bridge&lt;/h3>
&lt;p>With all the prerequisites out of the way we can finally start working
with Open vSwitch. Our first task is to create the OVS bridge that
will host our VXLAN tunnels. To create a bridge named &lt;code>br0&lt;/code>, we run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-br br0
&lt;/code>&lt;/pre>&lt;p>We can inspect the OVS configuration by running &lt;code>ovs-vsctl show&lt;/code>,
which should output something like:&lt;/p>
&lt;pre tabindex="0">&lt;code>cc1e7217-e393-4e21-97c1-92324d47946d
Bridge br0
Port br0
Interface br0
type: internal
ovs_version: &amp;#34;2.15.1&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s not forget to mark the interface &amp;ldquo;up&amp;rdquo;:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link set br0 up
&lt;/code>&lt;/pre>&lt;h3 id="create-the-vxlan-tunnels">Create the VXLAN tunnels&lt;/h3>
&lt;p>Up until this point we&amp;rsquo;ve been running identical commands on both
&lt;code>node0&lt;/code> and &lt;code>node1&lt;/code>. In order to create our VXLAN tunnels, we need to
provide a remote endpoint for the VXLAN connection, which is going to
be &amp;ldquo;the other host&amp;rdquo;. On &lt;code>node0&lt;/code>, we run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br0 vx_node1 -- set interface vx_node1 \
type=vxlan options:remote_ip=192.168.122.174
&lt;/code>&lt;/pre>&lt;p>This creates a VXLAN interface named &lt;code>vx_node1&lt;/code> (named that way
because the remote endpoint is &lt;code>node1&lt;/code>). The OVS configuration now
looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>cc1e7217-e393-4e21-97c1-92324d47946d
Bridge br0
Port vx_node1
Interface vx_node1
type: vxlan
options: {remote_ip=&amp;#34;192.168.122.174&amp;#34;}
Port br0
Interface br0
type: internal
ovs_version: &amp;#34;2.15.1&amp;#34;
&lt;/code>&lt;/pre>&lt;p>On &lt;code>node1&lt;/code> we will run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br0 vx_node0 -- set interface vx_node0 \
type=vxlan options:remote_ip=192.168.122.107
&lt;/code>&lt;/pre>&lt;p>Which results in:&lt;/p>
&lt;pre tabindex="0">&lt;code>58451994-e0d1-4bf1-8f91-7253ddf4c016
Bridge br0
Port br0
Interface br0
type: internal
Port vx_node0
Interface vx_node0
type: vxlan
options: {remote_ip=&amp;#34;192.168.122.107&amp;#34;}
ovs_version: &amp;#34;2.15.1&amp;#34;
&lt;/code>&lt;/pre>&lt;p>At this point, we have a functional overlay network: anything attached
to &lt;code>br0&lt;/code> on either system will appear to share the same layer 2
network. Let&amp;rsquo;s take advantage of this to connect a pair of virtual
machines.&lt;/p>
&lt;h2 id="create-virtual-machines">Create virtual machines&lt;/h2>
&lt;h3 id="download-a-base-image">Download a base image&lt;/h3>
&lt;p>We&amp;rsquo;ll need a base image for our virtual machines. I&amp;rsquo;m going to use the
CentOS 8 Stream image, which we can download to our storage directory
like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -L -o /var/lib/libvirt/images/centos-8-stream.qcow2 \
https://cloud.centos.org/centos/8-stream/x86_64/images/CentOS-Stream-GenericCloud-8-20210210.0.x86_64.qcow2
&lt;/code>&lt;/pre>&lt;p>We need to make sure &lt;code>libvirt&lt;/code> is aware of the new image:&lt;/p>
&lt;pre tabindex="0">&lt;code>virsh pool-refresh default
&lt;/code>&lt;/pre>&lt;p>Lastly, we&amp;rsquo;ll want to set a root password on the image so that we can
log in to our virtual machines:&lt;/p>
&lt;pre tabindex="0">&lt;code>virt-customize -a /var/lib/libvirt/images/centos-8-stream.qcow2 \
--root-password password:secret
&lt;/code>&lt;/pre>&lt;h3 id="create-the-virtual-machine">Create the virtual machine&lt;/h3>
&lt;p>We&amp;rsquo;re going to create a pair of virtual machines (one on each host).
We&amp;rsquo;ll be creating each vm with two network interfaces:&lt;/p>
&lt;ul>
&lt;li>One will be attached to the libvirt &lt;code>default&lt;/code> network; this will
allow us to &lt;code>ssh&lt;/code> into the vm in order to configure things.&lt;/li>
&lt;li>The second will be attached to the OVS bridge&lt;/li>
&lt;/ul>
&lt;p>To create a virtual machine on &lt;code>node0&lt;/code> named &lt;code>vm0.0&lt;/code>, run the
following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>virt-install \
-r 3000 \
--network network=default \
--network bridge=br0,virtualport.type=openvswitch \
--os-variant centos8 \
--disk pool=default,size=10,backing_store=centos-8-stream.qcow2,backing_format=qcow2 \
--import \
--noautoconsole \
-n vm0.0
&lt;/code>&lt;/pre>&lt;p>The most interesting option in the above command line is probably the
one used to create the virtual disk:&lt;/p>
&lt;pre tabindex="0">&lt;code>--disk pool=default,size=10,backing_store=centos-8-stream.qcow2,backing_format=qcow2 \
&lt;/code>&lt;/pre>&lt;p>This creates a 10GB &amp;ldquo;&lt;a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write&lt;/a>&amp;rdquo; disk that uses
&lt;code>centos-8-stream.qcow2&lt;/code> as a backing store. That means that reads will
generally come from the &lt;code>centos-8-stream.qcow2&lt;/code> image, but writes will
be stored in the new image. This makes it easy for us to quickly
create multiple virtual machines from the same base image.&lt;/p>
&lt;p>On &lt;code>node1&lt;/code> we would run a similar command, although here we&amp;rsquo;re naming
the virtual machine &lt;code>vm1.0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>virt-install \
-r 3000 \
--network network=default \
--network bridge=br0,virtualport.type=openvswitch \
--os-variant centos8 \
--disk pool=default,size=10,backing_store=centos-8-stream.qcow2,backing_format=qcow2 \
--import \
--noautoconsole \
-n vm1.0
&lt;/code>&lt;/pre>&lt;h3 id="configure-networking-for-vm00">Configure networking for vm0.0&lt;/h3>
&lt;p>On &lt;code>node0&lt;/code>, get the address of the new virtual machine on the default
network using the &lt;code>virsh domifaddr&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node0 ~]# virsh domifaddr vm0.0
Name MAC address Protocol Address
-------------------------------------------------------------------------------
vnet2 52:54:00:21:6e:4f ipv4 192.168.124.83/24
&lt;/code>&lt;/pre>&lt;p>Connect to the vm using &lt;code>ssh&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node0 ~]# ssh 192.168.124.83
root@192.168.124.83&amp;#39;s password:
Activate the web console with: systemctl enable --now cockpit.socket
Last login: Sat Apr 17 14:08:17 2021 from 192.168.124.1
[root@localhost ~]#
&lt;/code>&lt;/pre>&lt;p>(Recall that the &lt;code>root&lt;/code> password is &lt;code>secret&lt;/code>.)&lt;/p>
&lt;p>Configure interface &lt;code>eth1&lt;/code> with an address. For this post, we&amp;rsquo;ll use
the &lt;code>10.0.0.0/24&lt;/code> range for our overlay network. To assign this vm the
address &lt;code>10.0.0.10&lt;/code>, we can run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip addr add 10.0.0.10/24 dev eth1
ip link set eth1 up
&lt;/code>&lt;/pre>&lt;h3 id="configure-networking-for-vm10">Configure networking for vm1.0&lt;/h3>
&lt;p>We need to repeat the process for &lt;code>vm1.0&lt;/code> on &lt;code>node1&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node1 ~]# virsh domifaddr vm1.0
Name MAC address Protocol Address
-------------------------------------------------------------------------------
vnet0 52:54:00:e9:6e:43 ipv4 192.168.124.69/24
&lt;/code>&lt;/pre>&lt;p>Connect to the vm using &lt;code>ssh&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node0 ~]# ssh 192.168.124.69
root@192.168.124.69&amp;#39;s password:
Activate the web console with: systemctl enable --now cockpit.socket
Last login: Sat Apr 17 14:08:17 2021 from 192.168.124.1
[root@localhost ~]#
&lt;/code>&lt;/pre>&lt;p>We&amp;rsquo;ll use address 10.0.0.11 for this system:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip addr add 10.0.0.11/24 dev eth1
ip link set eth1 up
&lt;/code>&lt;/pre>&lt;h3 id="verify-connectivity">Verify connectivity&lt;/h3>
&lt;p>At this point, our setup is complete. On &lt;code>vm0.0&lt;/code>, we can connect to
&lt;code>vm1.1&lt;/code> over the overlay network. For example, we can ping the remote
host:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@localhost ~]# ping -c2 10.0.0.11
PING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.
64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=1.79 ms
64 bytes from 10.0.0.11: icmp_seq=2 ttl=64 time=0.719 ms
--- 10.0.0.11 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 0.719/1.252/1.785/0.533 ms
&lt;/code>&lt;/pre>&lt;p>Or connect to it using &lt;code>ssh&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@localhost ~]# ssh 10.0.0.11 uptime
root@10.0.0.11&amp;#39;s password:
14:21:33 up 1:18, 1 user, load average: 0.00, 0.00, 0.00
&lt;/code>&lt;/pre>&lt;p>Using &lt;code>tcpdump&lt;/code>, we can verify that these connections are going over
the overlay network. Let&amp;rsquo;s watch for VXLAN traffic on &lt;code>node1&lt;/code> by
running the following command (VXLAN is a UDP protocol running on port
4789)&lt;/p>
&lt;pre tabindex="0">&lt;code>tcpdump -i eth0 -n port 4789
&lt;/code>&lt;/pre>&lt;p>When we run &lt;code>ping -c2 10.0.0.11&lt;/code> on &lt;code>vm0.0&lt;/code>, we see the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>14:23:50.312574 IP 192.168.122.107.52595 &amp;gt; 192.168.122.174.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.10 &amp;gt; 10.0.0.11: ICMP echo request, id 4915, seq 1, length 64
14:23:50.314896 IP 192.168.122.174.59510 &amp;gt; 192.168.122.107.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.11 &amp;gt; 10.0.0.10: ICMP echo reply, id 4915, seq 1, length 64
14:23:51.314080 IP 192.168.122.107.52595 &amp;gt; 192.168.122.174.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.10 &amp;gt; 10.0.0.11: ICMP echo request, id 4915, seq 2, length 64
14:23:51.314259 IP 192.168.122.174.59510 &amp;gt; 192.168.122.107.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.11 &amp;gt; 10.0.0.10: ICMP echo reply, id 4915, seq 2, length 64
&lt;/code>&lt;/pre>&lt;p>In the output above, we see that each packet in the transaction
results in two lines of output from &lt;code>tcpdump&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>14:23:50.312574 IP 192.168.122.107.52595 &amp;gt; 192.168.122.174.vxlan: VXLAN, flags [I] (0x08), vni 0
IP 10.0.0.10 &amp;gt; 10.0.0.11: ICMP echo request, id 4915, seq 1, length 64
&lt;/code>&lt;/pre>&lt;p>The first line shows the contents of the VXLAN packet, while the
second lines shows the data that was encapsulated in the VXLAN packet.&lt;/p>
&lt;h2 id="thats-all-folks">That&amp;rsquo;s all folks&lt;/h2>
&lt;p>We&amp;rsquo;ve achieved our goal: we have two virtual machines on two different
hosts communicating over a VXLAN overlay network. If you were to do
this &amp;ldquo;for real&amp;rdquo;, you would probably want to make a number of changes:
for example, the network configuration we&amp;rsquo;ve applied in many cases
will not persist across a reboot; handling persistent network
configuration is still very distribution dependent, so I&amp;rsquo;ve left it
out of this post.&lt;/p></content></item><item><title>Configuring Open vSwitch with nmcli</title><link>https://blog.oddbit.com/post/2020-02-15-configuring-open-vswitch-with/</link><pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-02-15-configuring-open-vswitch-with/</guid><description>I recently acquired a managed switch for my home office in order to segment a few devices off onto their own isolated vlan. As part of this, I want to expose these vlans on my desktop using Open vSwitch (OVS), and I wanted to implement the configuration using NetworkManager rather than either relying on the legacy /etc/sysconfig/network-scripts scripts or rolling my own set of services. These are my notes in case I ever have to do this again.</description><content>&lt;p>I recently acquired a managed switch for my home office in order to segment a few devices off onto their own isolated vlan. As part of this, I want to expose these vlans on my desktop using Open vSwitch (OVS), and I wanted to implement the configuration using NetworkManager rather than either relying on the legacy &lt;code>/etc/sysconfig/network-scripts&lt;/code> scripts or rolling my own set of services. These are my notes in case I ever have to do this again.&lt;/p>
&lt;p>First, we need the openvswitch plugin for NetworkManager:&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install NetworkManager-ovs
&lt;/code>&lt;/pre>&lt;p>Without the plugin, &lt;code>nmcli&lt;/code> will happily accept all your configuration commands, but you&amp;rsquo;ll get an error when you try to bring an interface up.&lt;/p>
&lt;h2 id="target-configuration">Target configuration&lt;/h2>
&lt;p>This is what I want when we&amp;rsquo;re done:&lt;/p>
&lt;pre tabindex="0">&lt;code>1e668de8-c2ac-4dd7-9824-95e1cade31ce
Bridge br-house
Port &amp;#34;vlan1&amp;#34;
tag: 1
Interface &amp;#34;vlan1&amp;#34;
type: internal
Port &amp;#34;vlan102&amp;#34;
tag: 102
Interface &amp;#34;vlan102&amp;#34;
type: internal
Port br-house
Interface br-house
type: internal
Port &amp;#34;eth0&amp;#34;
Interface &amp;#34;eth0&amp;#34;
type: system
Port &amp;#34;vlan101&amp;#34;
tag: 101
Interface &amp;#34;vlan101&amp;#34;
type: internal
ovs_version: &amp;#34;2.12.0&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="nmcli-commands">NMCLI commands&lt;/h2>
&lt;p>To create the ovs bridge:&lt;/p>
&lt;pre tabindex="0">&lt;code>nmcli c add type ovs-bridge conn.interface br-house con-name br-house
nmcli c add type ovs-port conn.interface br-house master br-house con-name ovs-port-br-house
nmcli c add type ovs-interface slave-type ovs-port conn.interface br-house master ovs-port-br-house con-name ovs-if-br-house
&lt;/code>&lt;/pre>&lt;p>Unlike &lt;code>ovs-vsctl&lt;/code>, creating the bridge won&amp;rsquo;t automatically create an interface for you. The two additional commands above get us an actual interface named &lt;code>br-house&lt;/code> (configured using DHCP, because we didn&amp;rsquo;t explicitly set &lt;code>ipv4.method&lt;/code> on the interface).&lt;/p>
&lt;p>Next, we add &lt;code>eth0&lt;/code> to the bridge:&lt;/p>
&lt;pre tabindex="0">&lt;code>nmcli c add type ovs-port conn.interface eth0 master br-house con-name ovs-port-eth0
nmcli c add type ethernet conn.interface eth0 master ovs-port-eth0 con-name ovs-if-eth0
&lt;/code>&lt;/pre>&lt;p>And finally, we create some ports to expose specific vlans:&lt;/p>
&lt;pre tabindex="0">&lt;code>nmcli c add type ovs-port conn.interface vlan1 master br-house ovs-port.tag 1 con-name ovs-port-vlan1
nmcli c add type ovs-interface slave-type ovs-port conn.interface vlan1 master ovs-port-vlan1 con-name ovs-if-vlan1 ipv4.method static ipv4.address 192.168.7.1/24
nmcli c add type ovs-port conn.interface vlan101 master br-house ovs-port.tag 101 con-name ovs-port-vlan101
nmcli c add type ovs-interface slave-type ovs-port conn.interface vlan101 master ovs-port-vlan101 con-name ovs-if-vlan101 ipv4.method static ipv4.address 192.168.11.1/24
nmcli c add type ovs-port conn.interface vlan102 master br-house ovs-port.tag 102 con-name ovs-port-vlan102
nmcli c add type ovs-interface slave-type ovs-port conn.interface vlan102 master ovs-port-vlan102 con-name ovs-if-vlan102 ipv4.method static ipv4.address 192.168.13.1/24
&lt;/code>&lt;/pre></content></item><item><title>OVN and DHCP: A minimal example</title><link>https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/</guid><description>Introduction A long time ago, I wrote an article all about OpenStack Neutron (which at that time was called Quantum). That served as an excellent reference for a number of years, but if you&amp;rsquo;ve deployed a recent version of OpenStack you may have noticed that the network architecture looks completely different. The network namespaces previously used to implement routers and dhcp servers are gone (along with iptables rules and other features), and have been replaced by OVN (&amp;ldquo;Open Virtual Network&amp;rdquo;).</description><content>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>A long time ago, I wrote an article &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">all about OpenStack Neutron&lt;/a> (which at that time was called Quantum). That served as an excellent reference for a number of years, but if you&amp;rsquo;ve deployed a recent version of OpenStack you may have noticed that the network architecture looks completely different. The network namespaces previously used to implement routers and dhcp servers are gone (along with iptables rules and other features), and have been replaced by OVN (&amp;ldquo;Open Virtual Network&amp;rdquo;). What is OVN? How does it work? In this article, I&amp;rsquo;d like to explore a minimal OVN installation to help answer these questions.&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>We&amp;rsquo;re going to create a single OVN logical switch to which we will attach a few ports. We will demonstrate how we can realize a port on a physical node and configure it using DHCP, using a virtual DHCP server provided by OVN.&lt;/p>
&lt;h2 id="so-what-is-ovn-anyway">So what is OVN anyway?&lt;/h2>
&lt;p>If you&amp;rsquo;re just getting started with OVN, you&amp;rsquo;ll find that&amp;rsquo;s a hard question to answer: there is no dedicated OVN website; there&amp;rsquo;s no OVN landing page at &lt;a href="http://openvswitch.org">http://openvswitch.org&lt;/a>; in fact, there&amp;rsquo;s really no documentation for OVN at all other than the man pages. The only high-level description you&amp;rsquo;ll find comes from the &lt;code>ovn-architecture(7)&lt;/code> man page:&lt;/p>
&lt;blockquote>
&lt;p>OVN, the Open Virtual Network, is a system to support virtual network
abstraction. OVN complements the existing capabilities of OVS to add
native support for virtual network abstractions, such as virtual L2 and L3
overlays and security groups.&lt;/p>
&lt;/blockquote>
&lt;p>Where Open vSwitch (OVS) provides a virtual switch on a single host, OVN extends this abstraction to span multiple hosts. You can create virtual switches that span many physical nodes, and OVN will take care of creating overlay networks to support this abstraction. While OVS is primarily just a layer 2 device, OVN also operates at layer 3: you can create virtual routers to connect your virtual networks as well a variety of access control mechanisms such as security groups and ACLs.&lt;/p>
&lt;h2 id="requirements">Requirements&lt;/h2>
&lt;p>You&amp;rsquo;re going to need a recent version of OVN. Packages are available for &lt;a href="http://docs.openvswitch.org/en/latest/intro/install/distributions/">most major distributions&lt;/a>. I used &lt;a href="https://getfedora.org/">Fedora 31&lt;/a> for my testing, which includes OVS and OVN version 2.12.0. You can of course also &lt;a href="http://docs.openvswitch.org/en/latest/intro/install/">install from source&lt;/a>.&lt;/p>
&lt;p>This post assumes that you are logged in to your system as the &lt;code>root&lt;/code> user. Most of the commands require root access in order to function correctly.&lt;/p>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>OVN operates with a pair of databases. The &lt;em>Northbound&lt;/em> database contains the &lt;em>logical&lt;/em> structure of your networks: this is where you define switches, routers, ports, and so on.&lt;/p>
&lt;p>The &lt;em>Southbound&lt;/em> database is concerned with the &lt;em>physical&lt;/em> structure of your network. This database maintains information about which ports are realized on which hosts.&lt;/p>
&lt;p>The &lt;a href="http://www.openvswitch.org/support/dist-docs/ovn-northd.8.html">&lt;code>ovn-northd&lt;/code>&lt;/a> service &amp;ldquo;translates the logical network configuration in terms of conventional network concepts, taken from the OVN North‐ bound Database, into logical datapath flows in the OVN Southbound Database below it.&amp;rdquo; (&lt;a href="http://www.openvswitch.org/support/dist-docs/ovn-architecture.7.html">ovn-architecture(7)&lt;/a>)&lt;/p>
&lt;p>The &lt;a href="http://www.openvswitch.org/support/dist-docs/ovn-controller.8.html">&lt;code>ovn-controller&lt;/code>&lt;/a> service running on each host connects to the Southbound database and is responsible for configuring OVS as instructed by the database configuration.&lt;/p>
&lt;h2 id="test-environment">Test environment&lt;/h2>
&lt;p>This article assumes a test environment with three nodes running Fedora 31. All nodes have a single interface connecting to a shared layer 2 network:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>MAC address&lt;/th>
&lt;th>IP address&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ovn0&lt;/td>
&lt;td>de:ca:ff:00:00:64&lt;/td>
&lt;td>192.168.122.100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ovn1&lt;/td>
&lt;td>de:ca:ff:00:00:65&lt;/td>
&lt;td>192.168.122.101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ovn2&lt;/td>
&lt;td>de:ca:ff:00:00:66&lt;/td>
&lt;td>192.168.122.102&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="setting-up-ovn">Setting up OVN&lt;/h1>
&lt;h2 id="initial-configuration-steps">Initial configuration steps&lt;/h2>
&lt;p>Our first step will be to activate &lt;code>openvswitch&lt;/code> and &lt;code>ovn-controller&lt;/code> on all of the nodes in our test environment. On all nodes, run the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable --now openvswitch ovn-controller
&lt;/code>&lt;/pre>&lt;p>The &lt;code>--now&lt;/code> flag causes &lt;code>systemd&lt;/code> to start the service as well as enabling it in future boots.&lt;/p>
&lt;p>By default, OVN manages an &lt;code>openvswitch&lt;/code> bridge named &lt;code>br-int&lt;/code> (for &amp;ldquo;integration&amp;rdquo;). We&amp;rsquo;ll need to create this on all of our nodes. On all nodes, run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-br br-int
&lt;/code>&lt;/pre>&lt;h2 id="configuring-the-controller">Configuring the controller&lt;/h2>
&lt;p>We will designate the node &lt;code>ovn0&lt;/code> as our controller (which simply means &amp;ldquo;this node will run &lt;code>ovn-northd&lt;/code>). The first thing we need to do is enable the &lt;code>ovn-northd&lt;/code> service. On node &lt;code>ovn0&lt;/code>, run:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable --now ovn-northd
&lt;/code>&lt;/pre>&lt;p>In addition to starting the &lt;code>ovn-northd&lt;/code> service itself, this will also starts two instances of &lt;a href="http://www.openvswitch.org/support/dist-docs/ovsdb-server.1.html">&lt;code>ovsdb-server&lt;/code>&lt;/a>: one serving the Northbound database, listening on &lt;code>/run/ovn/ovnnb_db.sock&lt;/code>, and the second for the Southbound database, listening on &lt;code>/run/ovn/ovnsb_db.sock&lt;/code>. In order for the &lt;code>ovn-controller&lt;/code> service on the other nodes to connect to the Southbound database, we will need to configure that instance of &lt;code>ovsdb-server&lt;/code> to listen for tcp connections. We can do that using the &lt;code>ovn-sbctl set-connection&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-sbctl set-connection ptcp:6642
&lt;/code>&lt;/pre>&lt;p>The &lt;code>ptcp&lt;/code> in the above setting means &amp;ldquo;passive tcp&amp;rdquo;, which means &amp;ldquo;listen on port 6642 for connections&amp;rdquo;. After running the above command, we see that there is now an &lt;code>ovsdb-server&lt;/code> instance listening on port 6642:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ss -tlnp | grep 6642
LISTEN 0 10 0.0.0.0:6642 0.0.0.0:* users:((&amp;#34;ovsdb-server&amp;#34;,pid=1798,fd=21))
&lt;/code>&lt;/pre>&lt;h2 id="connecting-nodes-to-the-controller">Connecting nodes to the controller&lt;/h2>
&lt;p>Now that we have our controller configured, we have to connect the &lt;code>ovn-controller&lt;/code> service on our nodes to the Southbound database. We do this by creating several entries in the &lt;code>external_ids&lt;/code> column of the OVS &lt;code>open_vswitch&lt;/code> database on each host:&lt;/p>
&lt;ul>
&lt;li>&lt;code>ovn-remote&lt;/code> &amp;ndash; this is the address of the controller&lt;/li>
&lt;li>&lt;code>ovn-encap-ip&lt;/code> &amp;ndash; this is the local address that will be used for tunnel endpoints&lt;/li>
&lt;li>&lt;code>ovn-encap-type&lt;/code> &amp;ndash; the encapsulation mechanism to use for tunnels&lt;/li>
&lt;li>&lt;code>system-id&lt;/code> &amp;ndash; a unique identifier for the local host&lt;/li>
&lt;/ul>
&lt;p>On all nodes, run the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl set open_vswitch . \
external_ids:ovn-remote=tcp:192.168.122.100:6642 \
external_ids:ovn-encap-ip=$(ip addr show eth0 | awk &amp;#39;$1 == &amp;#34;inet&amp;#34; {print $2}&amp;#39; | cut -f1 -d/) \
external_ids:ovn-encap-type=geneve \
external_ids:system-id=$(hostname)
&lt;/code>&lt;/pre>&lt;p>This points &lt;code>ovn-remote&lt;/code> at the address of the controller, sets &lt;code>ovn-encap-ip&lt;/code> to the address of &lt;code>eth0&lt;/code> on the local host, sets &lt;code>systemd-id&lt;/code> to the local hostname, and selects &lt;a href="https://tools.ietf.org/html/draft-ietf-nvo3-geneve-08">geneve&lt;/a> encapsulation for tunnels (see &lt;a href="https://blog.russellbryant.net/2017/05/30/ovn-geneve-vs-vxlan-does-it-matter/">this post&lt;/a> for information on why OVN prefers Geneve encapsulation).&lt;/p>
&lt;p>We can verify these settings by using the &lt;code>ovs-vsctl list&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ovs-vsctl --columns external_ids list open_vswitch
external_ids : {hostname=&amp;#34;ovn1.virt&amp;#34;, ovn-encap-ip=&amp;#34;192.168.122.101&amp;#34;, ovn-encap-type=geneve, ovn-remote=&amp;#34;192.168.122.100&amp;#34;, rundir=&amp;#34;/var/run/openvswitch&amp;#34;, system-id=&amp;#34;ovn1&amp;#34;}
&lt;/code>&lt;/pre>&lt;p>After running the above commands, each node should now have tunnels interfaces connecting to the other nodes in the test environment. For example, running &lt;code>ovs-vsctl show&lt;/code> on node &lt;code>ovn1&lt;/code> looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>f0087676-7f93-419c-9da0-32321d2d3668
Bridge br-int
fail_mode: secure
Port &amp;#34;ovn-ovn0-0&amp;#34;
Interface &amp;#34;ovn-ovn0-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.100&amp;#34;}
Port br-int
Interface br-int
type: internal
Port &amp;#34;ovn-ovn2-0&amp;#34;
Interface &amp;#34;ovn-ovn2-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.102&amp;#34;}
ovs_version: &amp;#34;2.12.0&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Due to what appears to be &lt;a href="https://mail.openvswitch.org/pipermail/ovs-discuss/2020-January/049692.html">some sort of race condition in OVN&lt;/a>, you may not see the geneve tunnels in the &lt;code>ovs-vsctl show&lt;/code> output. If this is the case, restart &lt;code>ovn-controller&lt;/code> on all your ovn nodes:&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl restart ovn-controller
&lt;/code>&lt;/pre>&lt;p>The issue with the geneve tunnels appears to be resolved by &lt;a href="https://patchwork.ozlabs.org/patch/1222380/">this patch&lt;/a>, which will hopefully land in OVN in the near future.&lt;/p>
&lt;h1 id="creating-a-virtual-network">Creating a virtual network&lt;/h1>
&lt;p>Now that we have a functioning OVN environment, we&amp;rsquo;re ready to create our virtual network.&lt;/p>
&lt;h2 id="create-a-logical-switch">Create a logical switch&lt;/h2>
&lt;p>We&amp;rsquo;ll start by creating a logical switch, which we will call &lt;code>net0&lt;/code>. We create that using the &lt;code>ovn-nbctl ls-add&lt;/code> command. Run the following on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl ls-add net0
&lt;/code>&lt;/pre>&lt;p>After running the above command, the output of &lt;code>ovn-nbctl show&lt;/code> will look something like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-nbctl show
switch d8d96fb2-e1e7-469d-8c72-b7e891fb16ba (net0)
&lt;/code>&lt;/pre>&lt;p>Next, we need to set some configuration options on the switch that will be used to set the range from which we allocate addresses via DHCP. We&amp;rsquo;re going to have OVN manage the &lt;code>10.0.0.0/24&lt;/code> network, which means we need to set &lt;code>other_config:subnet&lt;/code> to &lt;code>10.0.0.0/24&lt;/code>. I generally like to reserve some addresses from the DHCP range to use for static allocations, so I have also set &lt;code>other_config:exclude_ips&lt;/code> to &lt;code>10.0.0.1..10.0.0.10&lt;/code>. This means that DHCP allocations will come from the range &lt;code>10.0.0.11&lt;/code> - &lt;code>10.0.0.254&lt;/code>.&lt;/p>
&lt;p>To apply these settings, run the following commands on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl set logical_switch net0 \
other_config:subnet=&amp;#34;10.0.0.0/24&amp;#34; \
other_config:exclude_ips=&amp;#34;10.0.0.1..10.0.0.10&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="create-dhcp-options">Create DHCP options&lt;/h2>
&lt;p>Each port that we want to configure using DHCP needs to be associated with a set of DHCP options. We accomplish this by creating a new entry in the Northbound &lt;code>dhcp_options&lt;/code> table, and then set the &lt;code>dhcp_options&lt;/code> column of the port to the id of the object we created in the &lt;code>dhcp_options&lt;/code> table.&lt;/p>
&lt;p>Looking at &lt;a href="https://github.com/ovn-org/ovn/blob/master/northd/ovn-northd.c#L4113">the source&lt;/a>, there are three required options that must be set in order for DHCP to operate:&lt;/p>
&lt;ul>
&lt;li>&lt;code>server_id&lt;/code> &amp;ndash; the ip address of the virtual dhcp server&lt;/li>
&lt;li>&lt;code>server_mac&lt;/code> &amp;ndash; the MAC address of the virtual dhcp server&lt;/li>
&lt;li>&lt;code>lease_time&lt;/code> &amp;ndash; the lifetime of DHCP leases&lt;/li>
&lt;/ul>
&lt;p>While not actually required, we can also set the &lt;code>router&lt;/code> key to provide information about the default gateway. We&amp;rsquo;re not going to make use of it in this example, but in practice you will probably want to set the &lt;code>router&lt;/code> option.&lt;/p>
&lt;p>We also need to set the CIDR range that will be served by the DHCP server.&lt;/p>
&lt;p>We can create the appropriate options using the &lt;code>ovn-nbctl dhcp-options-create&lt;/code> command. Run the following on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl dhcp-options-create 10.0.0.0/24
&lt;/code>&lt;/pre>&lt;p>Despite the name of that command, it doesn&amp;rsquo;t actually let us set DHCP options. For that, we need to first look up the uuid of our newly created entry in the &lt;code>dhcp_options&lt;/code> table. Let&amp;rsquo;s store that in the &lt;code>CIDR_UUID&lt;/code> variable, which we will use in a few places in the remainder of this post:&lt;/p>
&lt;pre tabindex="0">&lt;code>CIDR_UUID=$(ovn-nbctl --bare --columns=_uuid find dhcp_options cidr=&amp;#34;10.0.0.0/24&amp;#34;)
&lt;/code>&lt;/pre>&lt;p>With that uuid in hand, we can now set the required options:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl dhcp-options-set-options ${CIDR_UUID} \
lease_time=3600 \
router=10.0.0.1 \
server_id=10.0.0.1 \
server_mac=c0:ff:ee:00:00:01
&lt;/code>&lt;/pre>&lt;p>We can use the database &lt;code>list&lt;/code> command to inspect the &lt;code>dhcp_options&lt;/code> table to verify that things look as we expect:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-nbctl list dhcp_options
_uuid : f8a6abc5-b8e4-4209-8809-b95435b4d48b
cidr : &amp;#34;10.0.0.0/24&amp;#34;
external_ids : {lease_time=&amp;#34;3600&amp;#34;, router=&amp;#34;10.0.0.1&amp;#34;, server_id=&amp;#34;10.0.0.1&amp;#34;, server_mac=&amp;#34;c0:ff:ee:00:00:01&amp;#34;}
options : {}
&lt;/code>&lt;/pre>&lt;p>Instead of using the &lt;code>dhcp-options-create&lt;/code> command, as we did in this section, we could instead have used the database &lt;code>create&lt;/code> command. The quoting requirements for that command are a little more complex, but unlike the &lt;code>dhcp-options-create&lt;/code> command the &lt;code>create&lt;/code> command returns the id of the row it creates. This can be useful if you&amp;rsquo;re using the command as part of a script. The equivalent &lt;code>create&lt;/code> command would look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>CIDR_UUID=$(ovn-nbctl create dhcp_options \
cidr=10.0.0.0/24 \
options=&amp;#39;&amp;#34;lease_time&amp;#34;=&amp;#34;3600&amp;#34; &amp;#34;router&amp;#34;=&amp;#34;10.0.0.1&amp;#34; &amp;#34;server_id&amp;#34;=&amp;#34;10.0.0.1&amp;#34; &amp;#34;server_mac&amp;#34;=&amp;#34;c0:ff:ee:00:00:01&amp;#34;&amp;#39;)
&lt;/code>&lt;/pre>&lt;h2 id="create-logical-ports">Create logical ports&lt;/h2>
&lt;p>Let&amp;rsquo;s add the following three logical ports to the switch:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>MAC Address&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>port1&lt;/td>
&lt;td>c0:ff:ee:00:00:11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port2&lt;/td>
&lt;td>c0:ff:ee:00:00:12&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port3&lt;/td>
&lt;td>c0:ff:ee:00:00:13&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>For each port, we&amp;rsquo;ll need to run three commands. First, we create the port on the switch:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-add net0 port1
&lt;/code>&lt;/pre>&lt;p>Next, we set the port addresses. For this example, I&amp;rsquo;m using static MAC addresses and dynamic (assigned by DHCP) IP addresses, so the command will look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-set-addresses port1 &amp;#34;c0:ff:ee:00:00:11 dynamic&amp;#34;
&lt;/code>&lt;/pre>&lt;p>If you want OVN to set MAC addresses for the ports as well, you would instead run:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-set-addresses port1 &amp;#34;dynamic&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Finally, we associate the port with the DHCP options we created in the previous section:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-set-dhcpv4-options port1 $CIDR_UUID
&lt;/code>&lt;/pre>&lt;p>Repeat the above sequence for &lt;code>port2&lt;/code> and &lt;code>port3&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-nbctl lsp-add net0 port2
ovn-nbctl lsp-set-addresses port2 &amp;#34;c0:ff:ee:00:00:12 dynamic&amp;#34;
ovn-nbctl lsp-set-dhcpv4-options port2 $CIDR_UUID
ovn-nbctl lsp-add net0 port3
ovn-nbctl lsp-set-addresses port3 &amp;#34;c0:ff:ee:00:00:13 dynamic&amp;#34;
ovn-nbctl lsp-set-dhcpv4-options port3 $CIDR_UUID
&lt;/code>&lt;/pre>&lt;p>When you&amp;rsquo;re done, &lt;code>ovn-nbctl show&lt;/code> should return output similar to the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>switch 3c03342f-f762-410b-9f4e-572d266c8ff7 (net0)
port port2
addresses: [&amp;#34;c0:ff:ee:00:00:12 dynamic&amp;#34;]
port port3
addresses: [&amp;#34;c0:ff:ee:00:00:13 dynamic&amp;#34;]
port port1
addresses: [&amp;#34;c0:ff:ee:00:00:11 dynamic&amp;#34;]
&lt;/code>&lt;/pre>&lt;p>We can see additional details using the database command &lt;code>ovn-nbctl list logical_switch_port&lt;/code>. The entry for &lt;code>port1&lt;/code> might look like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>_uuid : 8ad6a4c0-4c7b-4817-bf13-8e7b1a86bab1
addresses : [&amp;#34;c0:ff:ee:00:00:11 dynamic&amp;#34;]
dhcpv4_options : f8a6abc5-b8e4-4209-8809-b95435b4d48b
dhcpv6_options : []
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:11 10.0.0.11&amp;#34;
enabled : []
external_ids : {}
ha_chassis_group : []
name : port1
options : {}
parent_name : []
port_security : []
tag : []
tag_request : []
type : &amp;#34;&amp;#34;
up : false
&lt;/code>&lt;/pre>&lt;p>Looking at the &lt;code>dynamic_addresses&lt;/code> column we can see that &lt;code>port1&lt;/code> has been assigned the ip address &lt;code>10.0.0.11&lt;/code>. We can see the assigned addresses for all of our ports like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-nbctl --columns dynamic_addresses list logical_switch_port
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:13 10.0.0.13&amp;#34;
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:11 10.0.0.11&amp;#34;
dynamic_addresses : &amp;#34;c0:ff:ee:00:00:12 10.0.0.12&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="simulating-a-dhcp-request-with-ovn-trace">Simulating a DHCP request with ovn-trace&lt;/h2>
&lt;p>At this point, we have a functioning switch, although we haven&amp;rsquo;t actually realized the ports anywhere yet. This is the perfect time to introduce the &lt;code>ovn-trace&lt;/code> tool, which can be used to simulate how your OVN network will handle a packet of data.&lt;/p>
&lt;p>We can show how OVN will respond to a DHCP &lt;code>DISCOVER&lt;/code> message with the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovn-trace --summary net0 &amp;#39;
inport==&amp;#34;port1&amp;#34; &amp;amp;&amp;amp;
eth.src==c0:ff:ee:00:00:11 &amp;amp;&amp;amp;
ip4.src==0.0.0.0 &amp;amp;&amp;amp;
ip.ttl==1 &amp;amp;&amp;amp;
ip4.dst==255.255.255.255 &amp;amp;&amp;amp;
udp.src==68 &amp;amp;&amp;amp;
udp.dst==67&amp;#39;
&lt;/code>&lt;/pre>&lt;p>The above command simulates a packet originating on &lt;code>port1&lt;/code> with the appropriate MAC address (&lt;code>eth.src&lt;/code>, &lt;code>c0:ff:ee:00:00:11&lt;/code>) and a source address (&lt;code>ip4.src&lt;/code>) of &lt;code>0.0.0.0&lt;/code> (port 68 (&lt;code>udp.src&lt;/code>)), targeting (&lt;code>ip4.dst&lt;/code>) the broadcast address &lt;code>255.255.255.255&lt;/code> (port 67 (&lt;code>udp.dst&lt;/code>)).&lt;/p>
&lt;p>Assuming everything is functioning correctly, this should produce the following output:&lt;/p>
&lt;pre tabindex="0">&lt;code># udp,reg14=0x2,vlan_tci=0x0000,dl_src=c0:ff:ee:00:00:11,dl_dst=c0:ff:ee:00:00:01,nw_src=0.0.0.0,nw_dst=255.255.255.255,nw_tos=0,nw_ecn=0,nw_ttl=1,tp_src=68,tp_dst=67
ingress(dp=&amp;#34;net0&amp;#34;, inport=&amp;#34;port1&amp;#34;) {
next;
reg0[3] = put_dhcp_opts(offerip = 10.0.0.11, lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1);
/* We assume that this packet is DHCPDISCOVER or DHCPREQUEST. */;
next;
eth.dst = eth.src;
eth.src = c0:ff:ee:00:00:01;
ip4.dst = 10.0.0.11;
ip4.src = 10.0.0.1;
udp.src = 67;
udp.dst = 68;
outport = inport;
flags.loopback = 1;
output;
egress(dp=&amp;#34;net0&amp;#34;, inport=&amp;#34;port1&amp;#34;, outport=&amp;#34;port1&amp;#34;) {
next;
output;
/* output to &amp;#34;port1&amp;#34;, type &amp;#34;&amp;#34; */;
};
};
&lt;/code>&lt;/pre>&lt;p>In the above output, you can see that OVN is filling in the details of the DHCP lease (that&amp;rsquo;s the &lt;code>put_dhcp_options&lt;/code> command), and then sending the packet back out &lt;code>port1&lt;/code> with the ethernet source and destination addresses reversed (so that the destination address is now the MAC address of &lt;code>port1&lt;/code>).&lt;/p>
&lt;p>It looks like everything is working in theory. Let&amp;rsquo;s attach some actual network interfaces and see what happens!&lt;/p>
&lt;h1 id="attaching-network-interfaces">Attaching network interfaces&lt;/h1>
&lt;p>In this section, we will attach network interfaces to our logical switch and demonstrate that they can be properly configured using DHCP.&lt;/p>
&lt;h2 id="create-an-ovs-port">Create an OVS port&lt;/h2>
&lt;p>On host &lt;code>ovn1&lt;/code>, let&amp;rsquo;s create port &lt;code>port1&lt;/code>. We&amp;rsquo;ll want to ensure that (a) the MAC address of this port matches the MAC address we configured earlier (&lt;code>c0:ff:ee:00:00:11&lt;/code>), and we need to make sure that the &lt;code>iface-id&lt;/code> external id matches the port name we registered in the Northbound database. We can do that with the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br-int port1 -- \
set interface port1 \
type=internal \
mac=&amp;#39;[&amp;#34;c0:ff:ee:00:00:11&amp;#34;]&amp;#39; \
external_ids:iface-id=port1
&lt;/code>&lt;/pre>&lt;p>After running this command, running &lt;code>ovs-vsctl show&lt;/code> on &lt;code>ovn1&lt;/code> should produce:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ovs-vsctl show
f359ad7a-5fcd-49b3-8557-e61be3a0b130
Bridge br-int
fail_mode: secure
Port br-int
Interface br-int
type: internal
Port &amp;#34;port1&amp;#34;
Interface &amp;#34;port1&amp;#34;
type: internal
Port &amp;#34;ovn-ovn2-0&amp;#34;
Interface &amp;#34;ovn-ovn2-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.102&amp;#34;}
Port &amp;#34;ovn-ovn0-0&amp;#34;
Interface &amp;#34;ovn-ovn0-0&amp;#34;
type: geneve
options: {csum=&amp;#34;true&amp;#34;, key=flow, remote_ip=&amp;#34;192.168.122.100&amp;#34;}
ovs_version: &amp;#34;2.12.0&amp;#34;
&lt;/code>&lt;/pre>&lt;p>Furthermore, OVN should also be aware of this port. If we run &lt;code>ovn-sbctl show&lt;/code> on &lt;code>ovn0&lt;/code>, we see a binding for host &lt;code>ovn1&lt;/code> (look for the &lt;code>Port_Binding port1&lt;/code> line under &lt;code>Chassis ovn1&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-sbctl show
Chassis ovn0
hostname: ovn0.virt
Encap geneve
ip: &amp;#34;192.168.122.100&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Chassis ovn1
hostname: ovn1.virt
Encap geneve
ip: &amp;#34;192.168.122.101&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port1
Chassis ovn2
hostname: ovn2.virt
Encap geneve
ip: &amp;#34;192.168.122.102&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
&lt;/code>&lt;/pre>&lt;h2 id="configure-the-port-using-dhcp">Configure the port using DHCP&lt;/h2>
&lt;p>We can now try to configure this interface with DHCP. Let&amp;rsquo;s first move the interface into a network namespace; this means we don&amp;rsquo;t need to worry about messing up routing on the host. We&amp;rsquo;ll create a namespace named &lt;code>vm1&lt;/code> and make &lt;code>port1&lt;/code> part of that namespace:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns add vm1
ip link set netns vm1 port1
ip -n vm1 addr add 127.0.0.1/8 dev lo
ip -n vm1 link set lo up
&lt;/code>&lt;/pre>&lt;p>We can now configure the interface using DHCP by running the &lt;code>dhclient&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns exec vm1 dhclient -v -i port1 --no-pid
&lt;/code>&lt;/pre>&lt;p>After &lt;code>dhclient&lt;/code> goes to the background, we see that it was able to successfully request an address:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ip netns exec vm1 dhclient -v -i port1 --no-pid
Internet Systems Consortium DHCP Client 4.4.1
Copyright 2004-2018 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
Listening on LPF/port1/c0:ff:ee:00:00:11
Sending on LPF/port1/c0:ff:ee:00:00:11
Sending on Socket/fallback
Created duid &amp;#34;\000\004\344J\012\236\007\033AF\261\354\246\273\206\011\226g&amp;#34;.
DHCPDISCOVER on port1 to 255.255.255.255 port 67 interval 7 (xid=0xffc0820a)
DHCPOFFER of 10.0.0.11 from 10.0.0.1
DHCPREQUEST for 10.0.0.11 on port1 to 255.255.255.255 port 67 (xid=0xffc0820a)
DHCPACK of 10.0.0.11 from 10.0.0.1 (xid=0xffc0820a)
bound to 10.0.0.11 -- renewal in 1378 seconds.
&lt;/code>&lt;/pre>&lt;p>And it has correctly configured the interface:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn1 ~]# ip netns exec vm1 ip addr show port1
6: port1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
link/ether c0:ff:ee:00:00:11 brd ff:ff:ff:ff:ff:ff
inet 10.0.0.11/24 brd 10.0.0.255 scope global dynamic port1
valid_lft 577sec preferred_lft 577sec
inet6 fe80::c2ff:eeff:fe00:11/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;h2 id="configuring-port2-on-ovn1">Configuring port2 on ovn1&lt;/h2>
&lt;p>Let&amp;rsquo;s repeat the above process with &lt;code>port2&lt;/code>, again using host &lt;code>ovn1&lt;/code>. First we add the port:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br-int port2 -- \
set interface port2 \
type=internal \
mac=&amp;#39;[&amp;#34;c0:ff:ee:00:00:12&amp;#34;]&amp;#39; \
external_ids:iface-id=port2
&lt;/code>&lt;/pre>&lt;p>Add it to a namespace:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns add vm2
ip link set netns vm2 port2
ip -n vm2 addr add 127.0.0.1/8 dev lo
ip -n vm2 link set lo up
&lt;/code>&lt;/pre>&lt;p>Configure it using &lt;code>dhclient&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip netns exec vm2 dhclient -v -i port2 --no-pid
&lt;/code>&lt;/pre>&lt;p>And finally look at the OVN port bindings on &lt;code>ovn0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-sbctl show
Chassis ovn1
hostname: ovn1.virt
Encap geneve
ip: &amp;#34;192.168.122.101&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port2
Port_Binding port1
Chassis ovn0
hostname: ovn0.virt
Encap geneve
ip: &amp;#34;192.168.122.100&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Chassis ovn2
hostname: ovn2.virt
Encap geneve
ip: &amp;#34;192.168.122.102&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
&lt;/code>&lt;/pre>&lt;h2 id="configuring-port3-on-ovn2">Configuring port3 on ovn2&lt;/h2>
&lt;p>Lastly, let&amp;rsquo;s repeat the above process for &lt;code>port3&lt;/code> on host &lt;code>ovn2&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl add-port br-int port3 -- \
set interface port3 \
type=internal \
mac=&amp;#39;[&amp;#34;c0:ff:ee:00:00:13&amp;#34;]&amp;#39; \
external_ids:iface-id=port3
ip netns add vm3
ip link set netns vm3 port3
ip -n vm3 addr add 127.0.0.1/8 dev lo
ip -n vm3 link set lo up
ip netns exec vm3 dhclient -v -i port3 --no-pid
&lt;/code>&lt;/pre>&lt;p>When we&amp;rsquo;re done, &lt;code>ovn-sbctl show&lt;/code> looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn0 ~]# ovn-sbctl show
Chassis ovn1
hostname: ovn1.virt
Encap geneve
ip: &amp;#34;192.168.122.101&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port2
Port_Binding port1
Chassis ovn0
hostname: ovn0.virt
Encap geneve
ip: &amp;#34;192.168.122.100&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Chassis ovn2
hostname: ovn2.virt
Encap geneve
ip: &amp;#34;192.168.122.102&amp;#34;
options: {csum=&amp;#34;true&amp;#34;}
Port_Binding port3
&lt;/code>&lt;/pre>&lt;h2 id="verify-connectivity">Verify connectivity&lt;/h2>
&lt;p>We can verify that the network namespaces we&amp;rsquo;ve created in the above examples are able to communicate with each other regardless of the host on which they have been created. For example, if we log into &lt;code>ovn2&lt;/code> we can show that we are able to reach the address of &lt;code>port1&lt;/code> (&lt;code>10.0.0.11&lt;/code>) from &lt;code>port3&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@ovn2 ~]# ip netns exec vm3 ping -c1 10.0.0.11
PING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.
64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=0.266 ms
--- 10.0.0.11 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.266/0.266/0.266/0.000 ms
&lt;/code>&lt;/pre>&lt;h1 id="thats-all-folks">That&amp;rsquo;s all folks!&lt;/h1>
&lt;p>I hope this post helps you understand how to set up a simple OVN environment with DHCP. Please feel free to leave comments and questions!&lt;/p>
&lt;h2 id="thanks-to">Thanks to&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/LorenzoBianconi">Lorenzo Bianconi&lt;/a> for helping sort this out over email.&lt;/li>
&lt;li>&lt;a href="https://twitter.com/zhouhanok">Han Zhou&lt;/a> for helping solve the issue around Geneve tunnels coming up appropriately.&lt;/li>
&lt;/ul>
&lt;h2 id="see-also">See also&lt;/h2>
&lt;p>Below are some of the resources to which I referred while figuring out how to put this all together:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developers.redhat.com/blog/2018/09/03/ovn-dynamic-ip-address-management/">Dynamic IP address management in Open Virtual Network (OVN): Part One&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developers.redhat.com/blog/2018/09/27/dynamic-ip-address-management-in-open-virtual-network-ovn-part-two/">Dynamic IP address management in Open Virtual Network (OVN): Part Two&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qyx.me/2018/07/10/run-and-test-ovn/">Run Open Virtual Network (OVN) in Ubuntu&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://dani.foroselectronica.es/simple-ovn-setup-in-5-minutes-491/">Simple OVN setup in 5 minutes&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Connecting another vm to your tripleo-quickstart deployment</title><link>https://blog.oddbit.com/post/2016-05-19-connecting-another-vm-to-your-/</link><pubDate>Thu, 19 May 2016 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2016-05-19-connecting-another-vm-to-your-/</guid><description>Let&amp;rsquo;s say that you have set up an environment using tripleo-quickstart and you would like to add another virtual machine to the mix that has both &amp;ldquo;external&amp;rdquo; connectivity (&amp;ldquo;external&amp;rdquo; in quotes because I am using it in the same way as the quickstart does w/r/t the undercloud) and connectivity to the overcloud nodes. How would you go about setting that up?
For a concrete example, let&amp;rsquo;s presume you have deployed an environment using the default tripleo-quickstart configuration, which looks like this:</description><content>&lt;p>Let&amp;rsquo;s say that you have set up an environment using
&lt;a href="https://github.com/openstack/tripleo-quickstart/">tripleo-quickstart&lt;/a> and you would like to add another virtual
machine to the mix that has both &amp;ldquo;external&amp;rdquo; connectivity (&amp;ldquo;external&amp;rdquo;
in quotes because I am using it in the same way as the quickstart does
w/r/t the undercloud) and connectivity to the overcloud nodes. How
would you go about setting that up?&lt;/p>
&lt;p>For a concrete example, let&amp;rsquo;s presume you have deployed an environment
using the default tripleo-quickstart configuration, which looks like
this:&lt;/p>
&lt;pre>&lt;code>overcloud_nodes:
- name: control_0
flavor: control
- name: compute_0
flavor: compute
extra_args: &amp;gt;-
--neutron-network-type vxlan
--neutron-tunnel-types vxlan
--ntp-server pool.ntp.org
network_isolation: true
&lt;/code>&lt;/pre>
&lt;p>That gets you one controller, one compute node, and enables network
isolation. When your deployment is complete, networking from the
perspective of the undercloud looks like this:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>eth0&lt;/code> is connected to the host&amp;rsquo;s &lt;code>brext&lt;/code> bridge and gives the
undercloud NAT access to the outside world. The interface will have
an address on the &lt;code>192.168.23.0/24&lt;/code> network.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>eth1&lt;/code> is connected to the host&amp;rsquo;s &lt;code>brovc&lt;/code> bridge, which is the
internal network for the overcloud. The interface is attached to
the OVS bridge &lt;code>br-ctlplane&lt;/code>.&lt;/p>
&lt;p>The &lt;code>br-ctlplane&lt;/code> bridge has the address &lt;code>192.0.2.1&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>And your overcloud environment probably looks something like this:&lt;/p>
&lt;pre>&lt;code>[stack@undercloud ~]$ nova list
+-------...+-------------------------+--------+...+--------------------+
| ID ...| Name | Status |...| Networks |
+-------...+-------------------------+--------+...+--------------------+
| 32f6ec...| overcloud-controller-0 | ACTIVE |...| ctlplane=192.0.2.7 |
| d98474...| overcloud-novacompute-0 | ACTIVE |...| ctlplane=192.0.2.8 |
+-------...+-------------------------+--------+...+--------------------+
&lt;/code>&lt;/pre>
&lt;p>We want to set up a new machine that has the same connectivity as the
undercloud.&lt;/p>
&lt;h2 id="upload-an-image">Upload an image&lt;/h2>
&lt;p>Before we can boot a new vm we&amp;rsquo;ll need an image; let&amp;rsquo;s start with the
standard CentOS 7 cloud image. First we&amp;rsquo;ll download it:&lt;/p>
&lt;pre>&lt;code>curl -O http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2
&lt;/code>&lt;/pre>
&lt;p>Let&amp;rsquo;s add a root password to the image and disable &lt;a href="https://cloudinit.readthedocs.io/en/latest/">cloud-init&lt;/a>,
since we&amp;rsquo;re not booting in a cloud environment:&lt;/p>
&lt;pre>&lt;code>virt-customize -a CentOS-7-x86_64-GenericCloud.qcow2 \
--root-password password:changeme \
--run-command &amp;quot;yum -y remove cloud-init&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Now let&amp;rsquo;s upload it to libvirt:&lt;/p>
&lt;pre>&lt;code>virsh vol-create-as oooq_pool centos-7-cloud.qcow2 8G \
--format qcow2 \
--allocation 0
virsh vol-upload --pool oooq_pool centos-7-cloud.qcow2 \
CentOS-7-x86_64-GenericCloud.qcow2
&lt;/code>&lt;/pre>
&lt;h2 id="a-idboot-the-vmboot-the-vma">&lt;!-- raw HTML omitted -->Boot the vm&lt;!-- raw HTML omitted -->&lt;/h2>
&lt;p>I like to boot from a copy-on-write clone of the image, so that I can
use the base image multiple times or quickly revert to a pristine
state, so let&amp;rsquo;s first create that clone:&lt;/p>
&lt;pre>&lt;code>virsh vol-create-as oooq_pool myguest.qcow2 10G \
--allocation 0 --format qcow2 \
--backing-vol centos-7-cloud.qcow2 \
--backing-vol-format qcow2
&lt;/code>&lt;/pre>
&lt;p>And then boot our vm:
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
&lt;pre>&lt;code>virt-install --disk vol=oooq_pool/myguest.qcow2,bus=virtio \
--import \
-r 2048 -n myguest --cpu host \
--os-variant rhel7 \
-w bridge=brext,model=virtio \
-w bridge=brovc,model=virtio \
--serial pty \
--noautoconsole
&lt;/code>&lt;/pre>
&lt;p>The crucial parts of the above command are the two &lt;code>-w ...&lt;/code> arguments,
which create interfaces attached to the named bridges.&lt;/p>
&lt;p>We can now connect to the console and log in as &lt;code>root&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ virsh console myguest
.
.
.
localhost login: root
Password:
&lt;/code>&lt;/pre>
&lt;p>We&amp;rsquo;ll see that the system already has an ip address on the &amp;ldquo;external&amp;rdquo;
network:&lt;/p>
&lt;pre>&lt;code>[root@localhost ~]# ip addr show eth0
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
link/ether 52:54:00:7f:5c:5a brd ff:ff:ff:ff:ff:ff
inet 192.168.23.27/24 brd 192.168.23.255 scope global dynamic eth0
valid_lft 3517sec preferred_lft 3517sec
inet6 fe80::5054:ff:fe7f:5c5a/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>And we have external connectivity:&lt;/p>
&lt;pre>&lt;code>[root@localhost ~]# ping -c1 google.com
PING google.com (216.58.219.206) 56(84) bytes of data.
64 bytes from lga25s40-in-f14.1e100.net (216.58.219.206): icmp_seq=1 ttl=56 time=20.6 ms
--- google.com ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 20.684/20.684/20.684/0.000 ms
&lt;/code>&lt;/pre>
&lt;p>Let&amp;rsquo;s give &lt;code>eth1&lt;/code> an address on the ctlplane network:&lt;/p>
&lt;pre>&lt;code>[root@localhost ~]# ip addr add 192.0.2.254/24 dev eth1
[root@localhost ~]# ip link set eth1 up
&lt;/code>&lt;/pre>
&lt;p>Now we can access the undercloud:&lt;/p>
&lt;pre>&lt;code>[root@localhost ~]# ping -c1 192.0.2.1
PING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.
64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.464 ms
--- 192.0.2.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.464/0.464/0.464/0.000 ms
&lt;/code>&lt;/pre>
&lt;p>As well as all of the overcloud hosts using their addresses on the
same network:&lt;/p>
&lt;pre>&lt;code>[root@localhost ~]# ping -c1 192.0.2.1
PING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.
64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.464 ms
--- 192.0.2.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.464/0.464/0.464/0.000 ms
&lt;/code>&lt;/pre>
&lt;h2 id="allocating-an-address-using-dhcp">Allocating an address using DHCP&lt;/h2>
&lt;p>In the above instructions we&amp;rsquo;ve manually assigned an ip address on the
ctlplane network. This works fine for testing, but it could
ultimately prove problematic if neutron were to allocate the same
address to another overcloud host. We can use neutron to configure a
static dhcp lease for our new host.&lt;/p>
&lt;p>First, we need the MAC address of our guest:&lt;/p>
&lt;pre>&lt;code>virthost$ virsh dumpxml myguest |
xmllint --xpath '//interface[source/@bridge=&amp;quot;brovc&amp;quot;]' -
&amp;lt;interface type=&amp;quot;bridge&amp;quot;&amp;gt;
&amp;lt;mac address=&amp;quot;52:54:00:42:d6:c2&amp;quot;/&amp;gt;
&amp;lt;source bridge=&amp;quot;brovc&amp;quot;/&amp;gt;
&amp;lt;target dev=&amp;quot;tap9&amp;quot;/&amp;gt;
&amp;lt;model type=&amp;quot;virtio&amp;quot;/&amp;gt;
&amp;lt;alias name=&amp;quot;net1&amp;quot;/&amp;gt;
&amp;lt;address type=&amp;quot;pci&amp;quot; domain=&amp;quot;0x0000&amp;quot; bus=&amp;quot;0x00&amp;quot; slot=&amp;quot;0x04&amp;quot; function=&amp;quot;0x0&amp;quot;/&amp;gt;
&amp;lt;/interface&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>And then on the undercloud we run &lt;code>neutron port-create&lt;/code> to create a
port and associate it with our MAC address:&lt;/p>
&lt;pre>&lt;code>[stack@undercloud]$ neutron port-create --mac-address 52:54:00:42:d6:c2 ctlplane
&lt;/code>&lt;/pre>
&lt;p>Now if we run &lt;code>dhclient&lt;/code> on our guest, it will acquire a lease from
the neutron-managed DHCP server:&lt;/p>
&lt;pre>&lt;code>[root@localhost]# dhclient -d eth1
Internet Systems Consortium DHCP Client 4.2.5
Copyright 2004-2013 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
Listening on LPF/eth1/52:54:00:42:d6:c2
Sending on LPF/eth1/52:54:00:42:d6:c2
Sending on Socket/fallback
DHCPREQUEST on eth1 to 255.255.255.255 port 67 (xid=0xc90c0ba)
DHCPACK from 192.0.2.5 (xid=0xc90c0ba)
bound to 192.0.2.9 -- renewal in 42069 seconds.
&lt;/code>&lt;/pre>
&lt;p>We can make this persistent by creating
&lt;code>/etc/sysconfig/network-scripts/ifcfg-eth1&lt;/code>:&lt;/p>
&lt;pre>&lt;code>[root@localhost]# cd /etc/sysconfig/network-scripts
[root@localhost]# sed s/eth0/eth1/g ifcfg-eth0 &amp;gt; ifcfg-eth1
[root@localhost]# ifup eth1
Determining IP information for eth1... done.
&lt;/code>&lt;/pre></content></item><item><title>Provider external networks (in an appropriate amount of detail)</title><link>https://blog.oddbit.com/post/2015-08-13-provider-external-networks-det/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2015-08-13-provider-external-networks-det/</guid><description>In Quantum in Too Much Detail, I discussed the architecture of a Neutron deployment in detail. Since that article was published, Neutron gained the ability to handle multiple external networks with a single L3 agent. While I wrote about that back in 2014, I covered the configuration side of it in much more detail than I discussed the underlying network architecture. This post addresses the architecture side.
The players This document describes the architecture that results from a particular OpenStack configuration, specifically:</description><content>&lt;p>In &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">Quantum in Too Much Detail&lt;/a>, I discussed the architecture of a
Neutron deployment in detail. Since that article was published,
Neutron gained the ability to handle multiple external networks with a
single L3 agent. While I &lt;a href="https://blog.oddbit.com/post/2014-05-28-multiple-external-networks-wit/">wrote about that&lt;/a> back in 2014, I
covered the configuration side of it in much more detail than I
discussed the underlying network architecture. This post addresses
the architecture side.&lt;/p>
&lt;h2 id="the-players">The players&lt;/h2>
&lt;p>This document describes the architecture that results from a
particular OpenStack configuration, specifically:&lt;/p>
&lt;ul>
&lt;li>Neutron networking using VXLAN or GRE tunnels;&lt;/li>
&lt;li>A dedicated network controller;&lt;/li>
&lt;li>Two external networks&lt;/li>
&lt;/ul>
&lt;h2 id="the-lay-of-the-land">The lay of the land&lt;/h2>
&lt;p>This is a simplified architecture diagram of the network connectivity
in this scenario:&lt;/p>
&lt;p>Everything on the compute hosts is identical to &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">my previous
article&lt;/a>, so I will only be discussing the network host here.&lt;/p>
&lt;p>For the purposes of this article, we have two external networks and
two internal networks defined:&lt;/p>
&lt;pre>&lt;code>$ neutron net-list
+--------------------------------------+-----------+----------...------------------+
| id | name | subnets ... |
+--------------------------------------+-----------+----------...------------------+
| 6f0a5622-4d2b-4e4d-b34a-09b70cacf3f1 | net1 | beb767f8-... 192.168.101.0/24 |
| 972f2853-2ba6-474d-a4be-a400d4e3dc97 | net2 | f6d0ca0f-... 192.168.102.0/24 |
| 12136507-9bbe-406f-b68b-151d2a78582b | external2 | 106db3d6-... 172.24.5.224/28 |
| 973a6eb3-eaf8-4697-b90b-b30315b0e05d | external1 | fe8e8193-... 172.24.4.224/28 |
+--------------------------------------+-----------+----------...------------------+
&lt;/code>&lt;/pre>
&lt;p>And two routers:&lt;/p>
&lt;pre>&lt;code>$ neutron router-list
+--------------------------------------+---------+-----------------------...-------------------+...
| id | name | external_gateway_info ... |...
+--------------------------------------+---------+-----------------------...-------------------+...
| 1b19e179-5d67-4d80-8449-bab42119a4c5 | router2 | {&amp;quot;network_id&amp;quot;: &amp;quot;121365... &amp;quot;172.24.5.226&amp;quot;}]} |...
| e2117de3-58ca-420d-9ac6-c4eccf5e7a53 | router1 | {&amp;quot;network_id&amp;quot;: &amp;quot;973a6e... &amp;quot;172.24.4.227&amp;quot;}]} |...
+--------------------------------------+---------+-----------------------...-------------------+...
&lt;/code>&lt;/pre>
&lt;p>And our logical connectivity is:&lt;/p>
&lt;pre>&lt;code>+---------+ +----------+ +-------------+
| | | | | |
| net1 +----&amp;gt; router1 +----&amp;gt; external1 |
| | | | | |
+---------+ +----------+ +-------------+
+---------+ +----------+ +-------------+
| | | | | |
| net2 +----&amp;gt; router2 +----&amp;gt; external2 |
| | | | | |
+---------+ +----------+ +-------------+
&lt;/code>&lt;/pre>
&lt;h2 id="router-attachments-to-integration-bridge">Router attachments to integration bridge&lt;/h2>
&lt;p>In the &lt;a href="https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/">legacy model&lt;/a>, in which an L3 agent supported a single
external network, the &lt;code>qrouter-...&lt;/code> namespaces that implement Neutron
routers were attached to both the integration bridge &lt;code>br-int&lt;/code> and the
external network bridge (the &lt;code>external_network_bridge&lt;/code> configuration
option from your &lt;code>l3_agent.ini&lt;/code>, often named &lt;code>br-ex&lt;/code>).&lt;/p>
&lt;p>In the provider network model, &lt;em>both&lt;/em> interfaces in a &lt;code>qrouter&lt;/code>
namespace are attached to the integration bridge. For the
configuration we&amp;rsquo;ve described above, the configuration of the
integration bridge ends up looking something like:&lt;/p>
&lt;pre>&lt;code>Bridge br-int
fail_mode: secure
Port &amp;quot;qvoc532d46c-33&amp;quot;
tag: 3
Interface &amp;quot;qvoc532d46c-33&amp;quot;
Port br-int
Interface br-int
type: internal
Port &amp;quot;qg-09e9da38-fb&amp;quot;
tag: 4
Interface &amp;quot;qg-09e9da38-fb&amp;quot;
type: internal
Port &amp;quot;qvo3ccea690-c2&amp;quot;
tag: 2
Interface &amp;quot;qvo3ccea690-c2&amp;quot;
Port &amp;quot;int-br-ex2&amp;quot;
Interface &amp;quot;int-br-ex2&amp;quot;
type: patch
options: {peer=&amp;quot;phy-br-ex2&amp;quot;}
Port &amp;quot;tapd2ff89e7-16&amp;quot;
tag: 2
Interface &amp;quot;tapd2ff89e7-16&amp;quot;
type: internal
Port patch-tun
Interface patch-tun
type: patch
options: {peer=patch-int}
Port &amp;quot;int-br-ex1&amp;quot;
Interface &amp;quot;int-br-ex1&amp;quot;
type: patch
options: {peer=&amp;quot;phy-br-ex1&amp;quot;}
Port &amp;quot;qr-affdbcee-5c&amp;quot;
tag: 3
Interface &amp;quot;qr-affdbcee-5c&amp;quot;
type: internal
Port &amp;quot;qr-b37877cd-42&amp;quot;
tag: 2
Interface &amp;quot;qr-b37877cd-42&amp;quot;
type: internal
Port &amp;quot;qg-19250d3f-5c&amp;quot;
tag: 1
Interface &amp;quot;qg-19250d3f-5c&amp;quot;
type: internal
Port &amp;quot;tap0881edf5-e5&amp;quot;
tag: 3
Interface &amp;quot;tap0881edf5-e5&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>qr-...&lt;/code> interface on each router is attached to an internal
network. The VLAN tag associated with this interface is whatever VLAN
Neutron has selected internally for the private network. In the above
output, these ports are on the network named &lt;code>net1&lt;/code>:&lt;/p>
&lt;pre>&lt;code>Port &amp;quot;qr-affdbcee-5c&amp;quot;
tag: 3
Interface &amp;quot;qr-affdbcee-5c&amp;quot;
type: internal
Port &amp;quot;tap0881edf5-e5&amp;quot;
tag: 3
Interface &amp;quot;tap0881edf5-e5&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>Where &lt;code>qr-affdbcee-5c&lt;/code> is &lt;code>router1&lt;/code>&amp;rsquo;s interface on that network, and
&lt;code>tap0881edf5-e5&lt;/code> is the port attached to a &lt;code>dhcp-...&lt;/code> namespace. The
same router is attached to the &lt;code>external1&lt;/code> network; this attachment is
represented by:&lt;/p>
&lt;pre>&lt;code>Port &amp;quot;qg-09e9da38-fb&amp;quot;
tag: 4
Interface &amp;quot;qg-09e9da38-fb&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>The external bridges are connected to the integration bridge using OVS
&amp;ldquo;patch&amp;rdquo; interfaces (the &lt;code>int-br-ex1&lt;/code> on the integration bridge and the
&lt;code>phy-br-ex1&lt;/code> interface on the &lt;code>br-ex1&lt;/code>).&lt;/p>
&lt;h2 id="from-here-to-there">From here to there&lt;/h2>
&lt;p>Connectivity between the &lt;code>qg-...&lt;/code> interface and the appropriate
external bridge (&lt;code>br-ex1&lt;/code> in this case) happens due to the VLAN tag
assigned on egress by the &lt;code>qg-...&lt;/code> interface and the following
OpenFlow rules associated with &lt;code>br-ex1&lt;/code>:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl dump-flows br-ex1
NXST_FLOW reply (xid=0x4):
cookie=0x0, duration=794.876s, table=0, n_packets=0, n_bytes=0, idle_age=794, priority=1 actions=NORMAL
cookie=0x0, duration=785.833s, table=0, n_packets=0, n_bytes=0, idle_age=785, priority=4,in_port=3,dl_vlan=4 actions=strip_vlan,NORMAL
cookie=0x0, duration=792.945s, table=0, n_packets=24, n_bytes=1896, idle_age=698, priority=2,in_port=3 actions=drop
&lt;/code>&lt;/pre>
&lt;p>Each of these rules contains some state information (like the
packet/byte counts), some conditions (like
&lt;code>priority=4,in_port=3,dl_vlan=4&lt;/code>) and one or more actions (like
&lt;code>actions=strip_vlan,NORMAL&lt;/code>). So, the second rule there matches
packets associated with VLAN tag 4 and strips the VLAN tag (after
which the packet is delivered to any physical interfaces that are
attached to this OVS bridge).&lt;/p>
&lt;p>Putting this all together:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>An outbound packet from a Nova server running on a compute node
enters via &lt;code>br-tun&lt;/code> (&lt;strong>H&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Flow rules on &lt;code>br-tun&lt;/code> translate the tunnel id into an internal
VLAN tag.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet gets delivered to the &lt;code>qr-...&lt;/code> interface of the
appropriate router. (&lt;strong>O&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet exits the &lt;code>qg-...&lt;/code> interface of the router (where it
is assigned the VLAN tag associated with the external network).
(&lt;strong>N&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet is delivered to the external bridge, where a flow rule
strip the VLAN tag. (&lt;strong>P&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The packet is sent out the physical interface associated with the
bridge.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="for-the-sake-of-completeness">For the sake of completeness&lt;/h2>
&lt;p>The second private network, &lt;code>net2&lt;/code>, is attached to &lt;code>router2&lt;/code> on the
&lt;code>qr-b37877cd-42&lt;/code> interface. It exits on the &lt;code>qg-19250d3f-5c&lt;/code>
interface, where packets will be assigned to VLAN 1:&lt;/p>
&lt;pre>&lt;code>Port &amp;quot;qr-b37877cd-42&amp;quot;
tag: 2
Interface &amp;quot;qr-b37877cd-42&amp;quot;
type: internal
Port &amp;quot;qg-19250d3f-5c&amp;quot;
tag: 1
Interface &amp;quot;qg-19250d3f-5c&amp;quot;
type: internal
&lt;/code>&lt;/pre>
&lt;p>The network interface configuration in the associated router namespace
looks like this:&lt;/p>
&lt;pre>&lt;code># ip netns exec qrouter-1b19e179-5d67-4d80-8449-bab42119a4c5 ip a
30: qg-19250d3f-5c: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether fa:16:3e:01:e9:e3 brd ff:ff:ff:ff:ff:ff
inet 172.24.5.226/28 brd 172.24.5.239 scope global qg-19250d3f-5c
valid_lft forever preferred_lft forever
inet6 fe80::f816:3eff:fe01:e9e3/64 scope link
valid_lft forever preferred_lft forever
37: qr-b37877cd-42: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether fa:16:3e:4c:6c:f2 brd ff:ff:ff:ff:ff:ff
inet 192.168.102.1/24 brd 192.168.102.255 scope global qr-b37877cd-42
valid_lft forever preferred_lft forever
inet6 fe80::f816:3eff:fe4c:6cf2/64 scope link
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>OpenFlow rules attached to &lt;code>br-ex2&lt;/code> will match these packets:&lt;/p>
&lt;pre>&lt;code># ovs-ofctl dump-flows br-ex2
NXST_FLOW reply (xid=0x4):
cookie=0x0, duration=3841.678s, table=0, n_packets=0, n_bytes=0, idle_age=3841, priority=1 actions=NORMAL
cookie=0x0, duration=3831.396s, table=0, n_packets=0, n_bytes=0, idle_age=3831, priority=4,in_port=3,dl_vlan=1 actions=strip_vlan,NORMAL
cookie=0x0, duration=3840.085s, table=0, n_packets=26, n_bytes=1980, idle_age=3742, priority=2,in_port=3 actions=drop
&lt;/code>&lt;/pre>
&lt;p>We can see that the second rule here will patch traffic on VLAN 1
(&lt;code>priority=4,in_port=3,dl_vlan=1&lt;/code>) and strip the VLAN tag, after which
the packet will be delivered to any other interfaces attached to this
bridge.&lt;/p></content></item><item><title>Four ways to connect a docker container to a local network</title><link>https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/</link><pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/</guid><description>Update (2018-03-22) Since I wrote this document back in 2014, Docker has developed the macvlan network driver. That gives you a supported mechanism for direct connectivity to a local layer 2 network. I&amp;rsquo;ve written an article about working with the macvlan driver.
This article discusses four ways to make a Docker container appear on a local network. These are not suggested as practical solutions, but are meant to illustrate some of the underlying network technology available in Linux.</description><content>&lt;p>&lt;strong>Update (2018-03-22)&lt;/strong> Since I wrote this document back in 2014,
Docker has developed the &lt;a href="https://docs.docker.com/network/macvlan/">macvlan network
driver&lt;/a>. That gives you a
&lt;em>supported&lt;/em> mechanism for direct connectivity to a local layer 2
network. I&amp;rsquo;ve &lt;a href="https://blog.oddbit.com/2018/03/12/using-docker-macvlan-networks/">written an article about working with the macvlan
driver&lt;/a>.&lt;/p>
&lt;hr>
&lt;p>This article discusses four ways to make a Docker container appear on
a local network. These are not suggested as practical solutions, but
are meant to illustrate some of the underlying network technology
available in Linux.&lt;/p>
&lt;p>If you were actually going to use one of these solutions as anything
other than a technology demonstration, you might look to the &lt;a href="https://github.com/jpetazzo/pipework">pipework&lt;/a> script, which can automate many of these configurations.&lt;/p>
&lt;h2 id="goals-and-assumptions">Goals and Assumptions&lt;/h2>
&lt;p>In the following examples, we have a host with address 10.12.0.76 on
the 10.12.0.0/21 network. We are creating a Docker container that we
want to expose as 10.12.0.117.&lt;/p>
&lt;p>I am running Fedora 20 with Docker 1.1.2. This means, in particular,
that my &lt;code>utils-linux&lt;/code> package is recent enough to include the
&lt;a href="http://man7.org/linux/man-pages/man1/nsenter.1.html">nsenter&lt;/a> command. If you don&amp;rsquo;t have that handy, there is a
convenient Docker recipe to build it for you at &lt;a href="https://github.com/jpetazzo/nsenter">jpetazzo/nsenter&lt;/a>
on GitHub.&lt;/p>
&lt;h2 id="a-little-help-along-the-way">A little help along the way&lt;/h2>
&lt;p>In this article we will often refer to the PID of a docker container.
In order to make this convenient, drop the following into a script
called &lt;code>docker-pid&lt;/code>, place it somewhere on your &lt;code>PATH&lt;/code>, and make it
executable:&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
exec docker inspect --format '{{ .State.Pid }}' &amp;quot;$@&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>This allows us to conveniently get the PID of a docker container by
name or ID:&lt;/p>
&lt;pre>&lt;code>$ docker-pid web
22041
&lt;/code>&lt;/pre>
&lt;p>In a script called &lt;code>docker-ip&lt;/code>, place the following:&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
exec docker inspect --format '{{ .NetworkSettings.IPAddress }}' &amp;quot;$@&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>And now we can get the ip address of a container like this:&lt;/p>
&lt;pre>&lt;code>$ docker-ip web
172.17.0.4
&lt;/code>&lt;/pre>
&lt;h2 id="using-nat">Using NAT&lt;/h2>
&lt;p>This uses the standard Docker network model combined with NAT rules on
your host to redirect inbound traffic to/outbound traffic from the
appropriate IP address.&lt;/p>
&lt;p>Assign our target address to your host interface:&lt;/p>
&lt;pre>&lt;code># ip addr add 10.12.0.117/21 dev em1
&lt;/code>&lt;/pre>
&lt;p>Start your docker container, using the &lt;code>-p&lt;/code> option to bind exposed
ports to an ip address and port on the host:&lt;/p>
&lt;pre>&lt;code># docker run -d --name web -p 10.12.0.117:80:80 larsks/simpleweb
&lt;/code>&lt;/pre>
&lt;p>With this command, Docker will set up the &lt;a href="https://docs.docker.com/articles/networking/">standard network&lt;/a> model:&lt;/p>
&lt;ul>
&lt;li>It will create a &lt;a href="http://lwn.net/Articles/232688/">veth&lt;/a> interface pair.&lt;/li>
&lt;li>Connect one end to the &lt;code>docker0&lt;/code> bridge.&lt;/li>
&lt;li>Place the other inside the container namespace as &lt;code>eth0&lt;/code>.&lt;/li>
&lt;li>Assign an ip address from the network used by the &lt;code>docker0&lt;/code> bridge.&lt;/li>
&lt;/ul>
&lt;p>Because we added &lt;code>-p 10.12.0.117:80:80&lt;/code> to our command line, Docker
will also create the following rule in the &lt;code>nat&lt;/code> table &lt;code>DOCKER&lt;/code>
chain (which is run from the &lt;code>PREROUTING&lt;/code> chain):&lt;/p>
&lt;pre>&lt;code>-A DOCKER -d 10.12.0.117/32 ! -i docker0 -p tcp -m tcp
--dport 80 -j DNAT --to-destination 172.17.0.4:80
&lt;/code>&lt;/pre>
&lt;p>This matches traffic TO our target address (&lt;code>-d 10.12.0.117/32&lt;/code>) not
originating on the &lt;code>docker0&lt;/code> bridge (&lt;code>! -i docker0&lt;/code>) destined for
&lt;code>tcp&lt;/code> port &lt;code>80&lt;/code> (&lt;code>-p tcp -m tcp --dport 80&lt;/code>). Matching traffic has
it&amp;rsquo;s destination set to the address of our docker container (&lt;code>-j DNAT --to-destination 172.17.0.4:80&lt;/code>).&lt;/p>
&lt;p>From a host elsewhere on the network, we can now access the web server
at our selected ip address:&lt;/p>
&lt;pre>&lt;code>$ curl http://10.12.0.117/hello.html
Hello world
&lt;/code>&lt;/pre>
&lt;p>If our container were to initiate a network connection with another
system, that connection would appear to originate with ip address of
our &lt;em>host&lt;/em>. We can fix that my adding a &lt;code>SNAT&lt;/code> rule to the
&lt;code>POSTROUTING&lt;/code> chain to modify the source address:&lt;/p>
&lt;pre>&lt;code># iptables -t nat -I POSTROUTING -s $(docker-ip web) \
-j SNAT --to-source 10.12.0.117
&lt;/code>&lt;/pre>
&lt;p>Note here the use of &lt;code>-I POSTROUTING&lt;/code>, which places the rule at the
&lt;em>top&lt;/em> of the &lt;code>POSTROUTING&lt;/code> chain. This is necessary because, by
default, Docker has already added the following rule to the top of the
&lt;code>POSTROUTING&lt;/code> chain:&lt;/p>
&lt;pre>&lt;code>-A POSTROUTING -s 172.17.0.0/16 ! -d 172.17.0.0/16 -j MASQUERADE
&lt;/code>&lt;/pre>
&lt;p>Because this &lt;code>MASQUERADE&lt;/code> rule matches traffic from any container, we
need to place our rule earlier in the &lt;code>POSTROUTING&lt;/code> chain for it to
have any affect.&lt;/p>
&lt;p>With these rules in place, traffic to 10.12.0.117 (port 80) is
directed to our &lt;code>web&lt;/code> container, and traffic &lt;em>originating&lt;/em> in the web
container will appear to come from 10.12.0.117.&lt;/p>
&lt;h2 id="with-linux-bridge-devices">With Linux Bridge devices&lt;/h2>
&lt;p>The previous example was relatively easy to configure, but has a few
shortcomings. If you need to configure an interface using DHCP, or if
you have an application that needs to be on the same layer 2 broadcast
domain as other devices on your network, NAT rules aren&amp;rsquo;t going to
work out.&lt;/p>
&lt;p>This solution uses a Linux bridge device, created using &lt;code>brctl&lt;/code>, to
connect your containers directly to a physical network.&lt;/p>
&lt;p>Start by creating a new bridge device. In this example, we&amp;rsquo;ll create
one called &lt;code>br-em1&lt;/code>:&lt;/p>
&lt;pre>&lt;code># brctl addbr br-em1
# ip link set br-em1 up
&lt;/code>&lt;/pre>
&lt;p>We&amp;rsquo;re going to add &lt;code>em1&lt;/code> to this bridge, and move the ip address from
&lt;code>em1&lt;/code> onto the bridge.&lt;/p>
&lt;p>&lt;strong>WARNING&lt;/strong>: This is not something you should do remotely, especially
for the first time, and making this persistent varies from
distribution to distribution, so this will not be a persistent
configuration.&lt;/p>
&lt;p>Look at the configuration of interface &lt;code>em1&lt;/code> and note the existing ip
address:&lt;/p>
&lt;pre>&lt;code># ip addr show em1
2: em1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc mq master br-em1 state UP group default qlen 1000
link/ether 00:1d:09:63:71:30 brd ff:ff:ff:ff:ff:ff
inet 10.12.0.76/21 scope global br-em1
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>
&lt;p>Look at your current routes and note the default route:&lt;/p>
&lt;pre>&lt;code># ip route
default via 10.12.7.254 dev em1
10.12.0.0/21 dev em1 proto kernel scope link src 10.12.0.76
&lt;/code>&lt;/pre>
&lt;p>Now, add this device to your bridge:&lt;/p>
&lt;pre>&lt;code># brctl addif br-em1 em1
&lt;/code>&lt;/pre>
&lt;p>Configure the bridge with the address that used to belong to
&lt;code>em1&lt;/code>:&lt;/p>
&lt;pre>&lt;code># ip addr del 10.12.0.76/21 dev em1
# ip addr add 10.12.0.76/21 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>And move the default route to the bridge:&lt;/p>
&lt;pre>&lt;code># ip route del default
# ip route add default via 10.12.7.254 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>If you were doing this remotely; you would do this all in one line
like this:&lt;/p>
&lt;pre>&lt;code># ip addr add 10.12.0.76/21 dev br-em1; \
ip addr del 10.12.0.76/21 dev em1; \
brctl addif br-em1 em1; \
ip route del default; \
ip route add default via 10.12.7.254 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>At this point, verify that you still have network connectivity:&lt;/p>
&lt;pre>&lt;code># curl http://google.com/
&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html;charset=utf-8&amp;quot;&amp;gt;
[...]
&lt;/code>&lt;/pre>
&lt;p>Start up the web container:&lt;/p>
&lt;pre>&lt;code># docker run -d --name web larsks/simpleweb
&lt;/code>&lt;/pre>
&lt;p>This will give us the normal &lt;code>eth0&lt;/code> interface inside the container,
but we&amp;rsquo;re going to ignore that and add a new one.&lt;/p>
&lt;p>Create a &lt;a href="http://lwn.net/Articles/232688/">veth&lt;/a> interface pair:&lt;/p>
&lt;pre>&lt;code># ip link add web-int type veth peer name web-ext
&lt;/code>&lt;/pre>
&lt;p>Add the &lt;code>web-ext&lt;/code> link to the &lt;code>br-eth0&lt;/code> bridge:&lt;/p>
&lt;pre>&lt;code># brctl addif br-em1 web-ext
&lt;/code>&lt;/pre>
&lt;p>And add the &lt;code>web-int&lt;/code> interface to the namespace of the container:&lt;/p>
&lt;pre>&lt;code># ip link set netns $(docker-pid web) dev web-int
&lt;/code>&lt;/pre>
&lt;p>Next, we&amp;rsquo;ll use the &lt;a href="http://man7.org/linux/man-pages/man1/nsenter.1.html">nsenter&lt;/a> command (part of the &lt;code>util-linux&lt;/code> package) to run some commands inside the &lt;code>web&lt;/code> container. Start by bringing up the link inside the container:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip link set web-int up
&lt;/code>&lt;/pre>
&lt;p>Assign our target ip address to the interface:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip addr add 10.12.0.117/21 dev web-int
&lt;/code>&lt;/pre>
&lt;p>And set a new default route inside the container:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip route del default
# nsenter -t $(docker-pid web) -n ip route add default via 10.12.7.254 dev web-int
&lt;/code>&lt;/pre>
&lt;p>Again, we can verify from another host that the web server is
available at 10.12.0.117:&lt;/p>
&lt;pre>&lt;code>$ curl http://10.12.0.117/hello.html
Hello world
&lt;/code>&lt;/pre>
&lt;p>Note that in this example we have assigned a static ip address, but we
could just have easily acquired an address using DHCP. After running:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip link set web-int up
&lt;/code>&lt;/pre>
&lt;p>We can run:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n -- dhclient -d web-int
Internet Systems Consortium DHCP Client 4.2.6
Copyright 2004-2014 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
Listening on LPF/web-int/6e:f0:a8:c6:f0:43
Sending on LPF/web-int/6e:f0:a8:c6:f0:43
Sending on Socket/fallback
DHCPDISCOVER on web-int to 255.255.255.255 port 67 interval 4 (xid=0x3aaab45b)
DHCPREQUEST on web-int to 255.255.255.255 port 67 (xid=0x3aaab45b)
DHCPOFFER from 10.12.7.253
DHCPACK from 10.12.7.253 (xid=0x3aaab45b)
bound to 10.12.6.151 -- renewal in 714 seconds.
&lt;/code>&lt;/pre>
&lt;h2 id="with-open-vswitch-bridge-devices">With Open vSwitch Bridge devices&lt;/h2>
&lt;p>This process is largely the same as in the previous example, but we
use &lt;a href="http://openvswitch.org/">Open vSwitch&lt;/a> instead of the legacy Linux bridge devices.
These instructions assume that you have already installed and started
Open vSwitch on your system.&lt;/p>
&lt;p>Create an OVS bridge using the &lt;code>ovs-vsctl&lt;/code> command:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-br br-em1
# ip link set br-em1 up
&lt;/code>&lt;/pre>
&lt;p>And add your external interface:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-port br-em1 em1
&lt;/code>&lt;/pre>
&lt;p>And then proceed as in the previous set of instructions.&lt;/p>
&lt;p>The equivalent all-in-one command is:&lt;/p>
&lt;pre>&lt;code># ip addr add 10.12.0.76/21 dev br-em1; \
ip addr del 10.12.0.76/21 dev em1; \
ovs-vsctl add-port br-em1 em1; \
ip route del default; \
ip route add default via 10.12.7.254 dev br-em1
&lt;/code>&lt;/pre>
&lt;p>Once that completes, your openvswitch configuration should look like
this:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl show
0b1d5895-88e6-42e5-a1da-ad464c75198c
Bridge &amp;quot;br-em1&amp;quot;
Port &amp;quot;br-em1&amp;quot;
Interface &amp;quot;br-em1&amp;quot;
type: internal
Port &amp;quot;em1&amp;quot;
Interface &amp;quot;em1&amp;quot;
ovs_version: &amp;quot;2.1.2&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>To add the &lt;code>web-ext&lt;/code> interface to the bridge, run:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-port br-em1 web-ext
&lt;/code>&lt;/pre>
&lt;p>Instead of:&lt;/p>
&lt;pre>&lt;code># brctl addif br-em1 web-ext
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>WARNING&lt;/strong>: The Open vSwitch configuration persists between reboots.
This means that when your system comes back up, &lt;code>em1&lt;/code> will still be a
member of &lt;code>br-em&lt;/code>, which will probably result in no network
connectivity for your host.&lt;/p>
&lt;p>Before rebooting your system, make sure to &lt;code>ovs-vsctl del-port br-em1 em1&lt;/code>.&lt;/p>
&lt;h2 id="with-macvlan-devices">With macvlan devices&lt;/h2>
&lt;p>This process is similar to the previous two, but instead of using a
bridge device we will create a &lt;a href="http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/">macvlan&lt;/a>, which is a virtual network
interface associated with a physical interface. Unlike the previous
two solutions, this does not require any interruption to your primary
network interface.&lt;/p>
&lt;p>Start by creating a docker container as in the previous examples:&lt;/p>
&lt;pre>&lt;code># docker run -d --name web larsks/simpleweb
&lt;/code>&lt;/pre>
&lt;p>Create a &lt;code>macvlan&lt;/code> interface associated with your physical interface:&lt;/p>
&lt;pre>&lt;code># ip link add em1p0 link em1 type macvlan mode bridge
&lt;/code>&lt;/pre>
&lt;p>This creates a new &lt;code>macvlan&lt;/code> interface named &lt;code>em1p0&lt;/code> (but you can
name it anything you want) associated with interface &lt;code>em1&lt;/code>. We are
setting it up in &lt;code>bridge&lt;/code> mode, which permits all &lt;code>macvlan&lt;/code> interfaces
to communicate with eachother.&lt;/p>
&lt;p>Add this interface to the container&amp;rsquo;s network namespace:&lt;/p>
&lt;pre>&lt;code># ip link set netns $(docker-pid web) em1p0
&lt;/code>&lt;/pre>
&lt;p>Bring up the link:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip link set em1p0 up
&lt;/code>&lt;/pre>
&lt;p>And configure the ip address and routing:&lt;/p>
&lt;pre>&lt;code># nsenter -t $(docker-pid web) -n ip route del default
# nsenter -t $(docker-pid web) -n ip addr add 10.12.0.117/21 dev em1p0
# nsenter -t $(docker-pid web) -n ip route add default via 10.12.7.254 dev em1p0
&lt;/code>&lt;/pre>
&lt;p>And demonstrate that &lt;em>from another host&lt;/em> the web server is available
at 10.12.0.117:&lt;/p>
&lt;pre>&lt;code>$ curl http://10.12.0.117/hello.html
Hello world
&lt;/code>&lt;/pre>
&lt;p>But note that if you were to try the same thing on the host, you would
get:&lt;/p>
&lt;pre>&lt;code>curl: (7) Failed connect to 10.12.0.117:80; No route to host
&lt;/code>&lt;/pre>
&lt;p>The &lt;em>host&lt;/em> is unable to communicate with &lt;code>macvlan&lt;/code> devices via the
primary interface. You can create &lt;em>another&lt;/em> &lt;code>macvlan&lt;/code> interface on
the host, give it an address on the appropriate network, and then set
up routes to your containers via that interface:&lt;/p>
&lt;pre>&lt;code># ip link add em1p1 link em1 type macvlan mode bridge
# ip addr add 10.12.6.144/21 dev em1p1
# ip route add 10.12.0.117 dev em1p1
&lt;/code>&lt;/pre></content></item><item><title>Video: Configuring OpenStack's external bridge on a single-interface system</title><link>https://blog.oddbit.com/post/2014-05-27-configuring-openstacks-externa/</link><pubDate>Tue, 27 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-27-configuring-openstacks-externa/</guid><description>I&amp;rsquo;ve just put a video on Youtube that looks at the steps required to set up the external bridge (br-ex) on a single-interface system:</description><content>&lt;p>I&amp;rsquo;ve just put a video on Youtube that looks at the steps required to
set up the external bridge (&lt;code>br-ex&lt;/code>) on a single-interface system:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/8zFQG5mKwPk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></content></item><item><title>Open vSwitch and persistent MAC addresses</title><link>https://blog.oddbit.com/post/2014-05-23-open-vswitch-and-persistent-ma/</link><pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-23-open-vswitch-and-persistent-ma/</guid><description>Normally I like to post solutions, but today&amp;rsquo;s post is about a vexing problem to which I have not been able to find a solution.
This started as a simple attempt to set up external connectivity on an all-in-one Icehouse install deployed on an OpenStack instance. I wanted to add eth0 to br-ex in order to model a typical method for providing external connectivity, but I ran into a very odd problem: the system would boot and work fine for a few seconds, but would then promptly lose network connectivity.</description><content>&lt;p>Normally I like to post solutions, but today&amp;rsquo;s post is about a
vexing problem to which I have not been able to find a solution.&lt;/p>
&lt;p>This started as a simple attempt to set up external connectivity on
an all-in-one Icehouse install deployed on an OpenStack instance. I
wanted to add &lt;code>eth0&lt;/code> to &lt;code>br-ex&lt;/code> in order to model a typical method for
providing external connectivity, but I ran into a very odd problem:
the system would boot and work fine for a few seconds, but would then
promptly lose network connectivity.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>The immediate cause was that the MAC address on &lt;code>br-ex&lt;/code> was changing.
I was setting the MAC explicitly in the configuration file:&lt;/p>
&lt;pre>&lt;code># cat ifcfg-br-ex
DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
OVSBOOTPROTO=dhcp
OVSDHCPINTERFACES=eth0
MACADDR=fa:16:3e:ef:91:ec
&lt;/code>&lt;/pre>
&lt;p>This was required in this case in order to make the MAC-address
filters on the host happy. When booting an instance, Neutron sets up
a rule like this:&lt;/p>
&lt;pre>&lt;code>-A neutron-openvswi-s55439d7d-a -s 10.0.0.8/32 -m mac --mac-source FA:16:3E:EF:91:EC -j RETURN
-A neutron-openvswi-s55439d7d-a -j DROP
&lt;/code>&lt;/pre>
&lt;p>But things quickly got weird. Some testing demonstrated that the MAC
address was changing when starting &lt;code>neutron-openvswitch-agent&lt;/code>, but a
thorough inspection of the code didn&amp;rsquo;t yield any obvious culprits for
this behavior.&lt;/p>
&lt;p>I liberally sprinkled the agent with the following (incrementing the
argument to &lt;code>echo&lt;/code> each time to uniquely identify each message):&lt;/p>
&lt;pre>&lt;code>os.system('echo 1 &amp;gt;&amp;gt; /tmp/ovs.log; ip link show dev br-ex &amp;gt;&amp;gt; /tmp/ovs.log')
&lt;/code>&lt;/pre>
&lt;p>It turns out that the MAC address on &lt;code>br-ex&lt;/code> was changing&amp;hellip;when
Neutron was deleting a port on &lt;code>br-int&lt;/code>. Specifically, at &lt;a href="https://github.com/openstack/neutron/blob/423ca756af10e10398636d6d34a7594a4fd4bc87/neutron/plugins/openvswitch/agent/ovs_neutron_agent.py#L909">this
line&lt;/a> in &lt;code>ovs_neutron_agent.py&lt;/code>:&lt;/p>
&lt;pre>&lt;code>self.int_br.delete_port(int_veth_name)
&lt;/code>&lt;/pre>
&lt;p>After some additional testing, it turns out that just about &lt;em>any&lt;/em> OVS
operation causes an explicit MAC address to disappear. For example,
create a new OVS bridge:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-br br-test0
# ip link show dev br-test0
9: br-test0: &amp;lt;BROADCAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether ba:cb:48:b9:6a:43 brd ff:ff:ff:ff:ff:ff
&lt;/code>&lt;/pre>
&lt;p>Then set the MAC address:&lt;/p>
&lt;pre>&lt;code># ip link set br-test0 addr c0:ff:ee:ee:ff:0c
# ip link show br-test0
8: br-test0: &amp;lt;BROADCAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether c0:ff:ee:ee:ff:0c brd ff:ff:ff:ff:ff:ff
&lt;/code>&lt;/pre>
&lt;p>Now create a new bridge:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl add-br br-test1
&lt;/code>&lt;/pre>
&lt;p>And inspect the MAC address on the first bridge:&lt;/p>
&lt;pre>&lt;code># ip link show dev br-test0
9: br-test0: &amp;lt;BROADCAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether ba:cb:48:b9:6a:43 brd ff:ff:ff:ff:ff:ff
&lt;/code>&lt;/pre>
&lt;p>In other words, creating a new bridge caused the MAC address on
&lt;code>br-ex&lt;/code> to revert. Other operations (e.g., deleting a port on an
unrelated switch) will cause the same behavior.&lt;/p>
&lt;p>I&amp;rsquo;ve seen this behavior on both versions &lt;code>1.11.0&lt;/code> and &lt;code>2.0.1&lt;/code>.&lt;/p>
&lt;p>So far everyone I&amp;rsquo;ve asked about this behavior has been stumped. If I
am able to figure out what&amp;rsquo;s going on I will update this post. Thanks
for reading!&lt;/p></content></item><item><title>Solved: Open vSwitch and persistent MAC addresses</title><link>https://blog.oddbit.com/post/2014-05-23-solved-open-vswitch-and-persis/</link><pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-23-solved-open-vswitch-and-persis/</guid><description>In my previous post I discussed a problem I was having setting a persistent MAC address on an OVS bridge device. It looks like the short answer is, &amp;ldquo;don&amp;rsquo;t use ip link set ...&amp;rdquo; for this purpose.
You can set the bridge MAC address via ovs-vsctl like this:
ovs-vsctl set bridge br-ex other-config:hwaddr=$MACADDR So I&amp;rsquo;ve updated my ifconfig-br-ex to look like this:
DEVICE=br-ex DEVICETYPE=ovs TYPE=OVSBridge ONBOOT=yes OVSBOOTPROTO=dhcp OVSDHCPINTERFACES=eth0 MACADDR=fa:16:3e:ef:91:ec OVS_EXTRA=&amp;quot;set bridge br-ex other-config:hwaddr=$MACADDR&amp;quot; The OVS_EXTRA parameter gets passed to the add-br call like this:</description><content>&lt;p>In my &lt;a href="https://blog.oddbit.com/2014/05/23/open-vswitch-and-persistent-ma/">previous post&lt;/a> I discussed a problem I was having setting a
persistent MAC address on an OVS bridge device. It looks like the
short answer is, &amp;ldquo;don&amp;rsquo;t use &lt;code>ip link set ...&lt;/code>&amp;rdquo; for this purpose.&lt;/p>
&lt;p>You can set the bridge MAC address via &lt;code>ovs-vsctl&lt;/code> like this:&lt;/p>
&lt;pre>&lt;code>ovs-vsctl set bridge br-ex other-config:hwaddr=$MACADDR
&lt;/code>&lt;/pre>
&lt;p>So I&amp;rsquo;ve updated my &lt;code>ifconfig-br-ex&lt;/code> to look like this:&lt;/p>
&lt;pre>&lt;code>DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
OVSBOOTPROTO=dhcp
OVSDHCPINTERFACES=eth0
MACADDR=fa:16:3e:ef:91:ec
OVS_EXTRA=&amp;quot;set bridge br-ex other-config:hwaddr=$MACADDR&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>OVS_EXTRA&lt;/code> parameter gets passed to the &lt;code>add-br&lt;/code> call like this:&lt;/p>
&lt;pre>&lt;code>ovs-vsctl --may-exist add-br br-ex -- set bridge br-ex other-config:hwaddr=$MACADDR
&lt;/code>&lt;/pre>
&lt;p>And unlike using &lt;code>ip link set&lt;/code>, this seems to stick.&lt;/p></content></item><item><title>Fedora and OVS Bridge Interfaces</title><link>https://blog.oddbit.com/post/2014-05-20-fedora-and-ovs-bridge-interfac/</link><pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-20-fedora-and-ovs-bridge-interfac/</guid><description>I run OpenStack on my laptop, and I&amp;rsquo;ve been chasing down a pernicious problem with OVS bridge interfaces under both F19 and F20. My OpenStack environment relies on an OVS bridge device named br-ex for external connectivity and for making services available to OpenStack instances, but after rebooting, br-ex was consistently unconfigured, which caused a variety of problems.
This is the network configuration file for br-ex on my system:
DEVICE=br-ex DEVICETYPE=ovs TYPE=OVSBridge BOOTPROT=static IPADDR=192.</description><content>&lt;p>I run OpenStack on my laptop, and I&amp;rsquo;ve been chasing down a pernicious
problem with OVS bridge interfaces under both F19 and F20. My
OpenStack environment relies on an OVS bridge device named &lt;code>br-ex&lt;/code> for
external connectivity and for making services available to OpenStack
instances, but after rebooting, &lt;code>br-ex&lt;/code> was consistently unconfigured,
which caused a variety of problems.&lt;/p>
&lt;p>This is the network configuration file for &lt;code>br-ex&lt;/code> on my system:&lt;/p>
&lt;pre>&lt;code>DEVICE=br-ex
DEVICETYPE=ovs
TYPE=OVSBridge
BOOTPROT=static
IPADDR=192.168.200.1
NETMASK=255.255.255.0
ONBOOT=yes
NM_CONTROLLED=no
ZONE=openstack
&lt;/code>&lt;/pre>
&lt;p>Running &lt;code>ifup br-ex&lt;/code> would also fail to configure the interface, but
running &lt;code>ifdown br-ex; ifup br-ex&lt;/code> would configure things
appropriately.&lt;/p>
&lt;p>I finally got fed up with this behavior and spent some time chasing
down the problem, and this is what I found:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Calling &lt;code>ifup br-ex&lt;/code> passes control to
&lt;code>/etc/sysconfig/network-scripts/ifup-ovs&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ifup-ovs&lt;/code> calls the &lt;code>check_device_down&lt;/code> function from
&lt;code>network-functions&lt;/code>, which looks like:&lt;/p>
&lt;pre>&lt;code> check_device_down ()
{
[ ! -d /sys/class/net/$1 ] &amp;amp;&amp;amp; return 0
if LC_ALL=C ip -o link show dev $1 2&amp;gt;/dev/null | grep -q &amp;quot;,UP&amp;quot; ; then
return 1
else
return 0
fi
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>This returns failure (=1) if the interface flags contain &lt;code>,UP&lt;/code>.
Unfortunately, since information about this device is stored
persistently in &lt;code>ovsdb&lt;/code>, the device is already &lt;code>UP&lt;/code> when &lt;code>ifup&lt;/code> is
called, which causes &lt;code>ifup-ovs&lt;/code> to skip further device
configuration. The logic that calls &lt;code>check_device_down&lt;/code> looks like
this:&lt;/p>
&lt;pre>&lt;code>if check_device_down &amp;quot;${DEVICE}&amp;quot;; then
ovs-vsctl -t ${TIMEOUT} -- --may-exist add-br &amp;quot;$DEVICE&amp;quot; $OVS_OPTIONS \
${OVS_EXTRA+-- $OVS_EXTRA} \
${STP+-- set bridge &amp;quot;$DEVICE&amp;quot; stp_enable=&amp;quot;${STP}&amp;quot;}
else
OVSBRIDGECONFIGURED=&amp;quot;yes&amp;quot;
fi
&lt;/code>&lt;/pre>
&lt;p>This sets &lt;code>OVSBRIDGECONFIGURED&lt;/code> if it believes the device is &lt;code>UP&lt;/code>,
which causes &lt;code>ifup-ovs&lt;/code> to skip the call to &lt;code>ifup-eth&lt;/code> to configure
the interface:&lt;/p>
&lt;pre>&lt;code>if [ &amp;quot;${OVSBOOTPROTO}&amp;quot; != &amp;quot;dhcp&amp;quot; ] &amp;amp;&amp;amp; [ -z &amp;quot;${OVSINTF}&amp;quot; ] &amp;amp;&amp;amp; \
[ &amp;quot;${OVSBRIDGECONFIGURED}&amp;quot; != &amp;quot;yes&amp;quot; ]; then
${OTHERSCRIPT} ${CONFIG}
fi
&lt;/code>&lt;/pre>
&lt;p>I have found that the simplest solution to this problem is to disable
the logic that sets &lt;code>OVSBRIDGECONFIGURED&lt;/code>, by changing this:&lt;/p>
&lt;pre>&lt;code>else
OVSBRIDGECONFIGURED=&amp;quot;yes&amp;quot;
fi
&lt;/code>&lt;/pre>
&lt;p>To this:&lt;/p>
&lt;pre>&lt;code>else
: OVSBRIDGECONFIGURED=&amp;quot;yes&amp;quot;
fi
&lt;/code>&lt;/pre>
&lt;p>With this change in place, &lt;code>br-ex&lt;/code> is correctly configured after a
reboot.&lt;/p></content></item><item><title>Flat networks with ML2 and OpenVSwitch</title><link>https://blog.oddbit.com/post/2014-05-19-flat-networks-with-ml-and-open/</link><pubDate>Mon, 19 May 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-05-19-flat-networks-with-ml-and-open/</guid><description>Due to an unfortunate incident involving sleep mode and an overheated backpack I had the &amp;ldquo;opportunity&amp;rdquo; to rebuild my laptop. Since this meant reinstalling OpenStack I used this as an excuse to finally move to the ML2 network plugin for Neutron.
I was attempting to add an external network using the normal incantation:
neutron net-create external -- --router:external=true \ --provider:network_type=flat \ --provider:physical_network=physnet1 While this command completed successfully, I was left without any connectivity between br-int and br-ex, despite having in my /etc/neutron/plugins/ml2/ml2_conf.</description><content>&lt;p>Due to an unfortunate incident involving sleep mode and an overheated
backpack I had the &amp;ldquo;opportunity&amp;rdquo; to rebuild my laptop. Since this meant
reinstalling OpenStack I used this as an excuse to finally move to the ML2
network plugin for Neutron.&lt;/p>
&lt;p>I was attempting to add an external network using the normal incantation:&lt;/p>
&lt;pre>&lt;code>neutron net-create external -- --router:external=true \
--provider:network_type=flat \
--provider:physical_network=physnet1
&lt;/code>&lt;/pre>
&lt;p>While this command completed successfully, I was left without any
connectivity between &lt;code>br-int&lt;/code> and &lt;code>br-ex&lt;/code>, despite having in my
&lt;code>/etc/neutron/plugins/ml2/ml2_conf.ini&lt;/code>:&lt;/p>
&lt;pre>&lt;code>[ml2_type_flat]
flat_networks = *
[ovs]
network_vlan_ranges = physnet1
bridge_mappings = physnet1:br-ex
&lt;/code>&lt;/pre>
&lt;p>The reason this is failing is very simple, but not terribly clear from
the existing documentation. This is how the &lt;code>neutron-server&lt;/code> process
is running:&lt;/p>
&lt;pre>&lt;code>/usr/bin/python /usr/bin/neutron-server \
--config-file /usr/share/neutron/neutron-dist.conf \
--config-file /etc/neutron/neutron.conf \
--config-file /etc/neutron/plugin.ini \
--log-file /var/log/neutron/server.log
&lt;/code>&lt;/pre>
&lt;p>This is how the &lt;code>neutron-openvswitch-agent&lt;/code> process is running:&lt;/p>
&lt;pre>&lt;code>/usr/bin/python /usr/bin/neutron-openvswitch-agent \
--config-file /usr/share/neutron/neutron-dist.conf \
--config-file /etc/neutron/neutron.conf \
--config-file /etc/neutron/plugins/openvswitch/ovs_neutron_plugin.ini \
--log-file /var/log/neutron/openvswitch-agent.log
&lt;/code>&lt;/pre>
&lt;p>Note in particular that &lt;code>neutron-server&lt;/code> is looking at
&lt;code>/etc/neutron/plugin.ini&lt;/code>, which is a symlink to
&lt;code>/etc/neutron/plugins/ml2/ml2_conf.ini&lt;/code>, while
&lt;code>neutron-openvswitch-agent&lt;/code> is looking explicitly at
&lt;code>/etc/neutron/plugins/openvswitch/ovs_neutron_plugin.ini&lt;/code>. The
physical network configuration needs to go into the
&lt;code>ovs_neutron_plugin.ini&lt;/code> configuration file.&lt;/p></content></item><item><title>Show OVS external-ids</title><link>https://blog.oddbit.com/post/2014-01-19-show-ovs-externalids/</link><pubDate>Sun, 19 Jan 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-01-19-show-ovs-externalids/</guid><description>This is just here as a reminder for me:
An OVS interface has a variety of attributes associated with it, including an external-id field that can be used to associate resources outside of OpenVSwitch with the interface. You can view this field with the following command:
$ ovs-vsctl --columns=name,external-ids list Interface Which on my system, with a single virtual instance, looks like this:
# ovs-vsctl --columns=name,external-ids list Interface . . .</description><content>&lt;p>This is just here as a reminder for me:&lt;/p>
&lt;p>An OVS interface has a variety of attributes associated with it, including an
&lt;code>external-id&lt;/code> field that can be used to associate resources outside of
OpenVSwitch with the interface. You can view this field with the following
command:&lt;/p>
&lt;pre>&lt;code>$ ovs-vsctl --columns=name,external-ids list Interface
&lt;/code>&lt;/pre>
&lt;p>Which on my system, with a single virtual instance, looks like this:&lt;/p>
&lt;pre>&lt;code># ovs-vsctl --columns=name,external-ids list Interface
.
.
.
name : &amp;quot;qvo519d7cc4-75&amp;quot;
external_ids : {attached-mac=&amp;quot;fa:16:3e:f7:75:b0&amp;quot;, iface-id=&amp;quot;519d7cc4-7593-4944-af7b-4056436f2d66&amp;quot;, iface-status=active, vm-uuid=&amp;quot;0330b084-03db-4d42-a231-2cd6ad89515b&amp;quot;}
.
.
.
&lt;/code>&lt;/pre>
&lt;p>Note the information contained here:&lt;/p>
&lt;ul>
&lt;li>&lt;code>attached-mac&lt;/code> is the MAC address of the device attached to this interface.&lt;/li>
&lt;li>&lt;code>vm-uuid&lt;/code> is the libvirt UUID for the instance attached to this interface&amp;hellip;&lt;/li>
&lt;li>&amp;hellip;which also happens to be the Nova UUID for the instance.&lt;/li>
&lt;/ul>
&lt;p>So we can pass that UUID to &lt;code>virsh dumpxml&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ virsh dumpxml 0330b084-03db-4d42-a231-2cd6ad89515b
&amp;lt;domain type='kvm' id='150'&amp;gt;
&amp;lt;name&amp;gt;instance-0000009c&amp;lt;/name&amp;gt;
&amp;lt;uuid&amp;gt;0330b084-03db-4d42-a231-2cd6ad89515b&amp;lt;/uuid&amp;gt;
&amp;lt;memory unit='KiB'&amp;gt;6144000&amp;lt;/memory&amp;gt;
&amp;lt;currentMemory unit='KiB'&amp;gt;6144000&amp;lt;/currentMemory&amp;gt;
&amp;lt;vcpu placement='static'&amp;gt;1&amp;lt;/vcpu&amp;gt;
.
.
.
&lt;/code>&lt;/pre>
&lt;p>Or to &lt;code>nova show&lt;/code>:&lt;/p>
&lt;pre>&lt;code>$ nova show 0330b084-03db-4d42-a231-2cd6ad89515b
+--------------------------------------+----------------------------------------------------------+
| Property | Value |
+--------------------------------------+----------------------------------------------------------+
| OS-DCF:diskConfig | MANUAL |
| OS-EXT-AZ:availability_zone | nova |
.
.
.
&lt;/code>&lt;/pre></content></item></channel></rss>