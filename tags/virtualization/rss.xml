<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Virtualization on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/virtualization/</link><description>Recent content in Virtualization on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 10:58:10 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/virtualization/rss.xml" rel="self" type="application/rss+xml"/><item><title>Creating a VXLAN overlay network with Open vSwitch</title><link>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/</guid><description>&lt;p&gt;In this post, we&amp;rsquo;ll walk through the process of getting virtual
machines on two different hosts to communicate over an overlay network
created using the support for VXLAN in &lt;a href="https://www.openvswitch.org/"&gt;Open vSwitch&lt;/a&gt; (or OVS).&lt;/p&gt;
&lt;h2 id="the-test-environment"&gt;The test environment&lt;/h2&gt;
&lt;p&gt;For this post, I&amp;rsquo;ll be working with two systems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;node0.ovs.virt&lt;/code&gt; at address 192.168.122.107&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node1.ovs.virt&lt;/code&gt; at address 192.168.122.174&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These hosts are running CentOS 8, although once we get past the
package installs the instructions will be similar for other
distributions.&lt;/p&gt;</description></item><item><title>OpenShift and CNV: MAC address management in CNV 2.4</title><link>https://blog.oddbit.com/post/2020-08-10-mac-address-management-in-cnv/</link><pubDate>Mon, 10 Aug 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-08-10-mac-address-management-in-cnv/</guid><description>&lt;p&gt;This is part of a &lt;a href="https://blog.oddbit.com/tag/openshift-and-cnv"&gt;series of posts&lt;/a&gt; about my experience working with
&lt;a href="https://www.openshift.com/"&gt;OpenShift&lt;/a&gt; and &lt;a href="https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization"&gt;CNV&lt;/a&gt;. In this post, I&amp;rsquo;ll look at how the
recently released CNV 2.4 resolves some issues in managing virtual
machines that are attached directly to local layer 2 networks&lt;/p&gt;
&lt;p&gt;In &lt;a href="https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/"&gt;an earlier post&lt;/a&gt;, I discussed some issues around the
management of virtual machine MAC addresses in CNV 2.3: in particular,
that virtual machines are assigned a random MAC address not just at
creation time but every time they boot. CNV 2.4 (re-)introduces &lt;a href="https://docs.openshift.com/container-platform/4.5/virt/virtual_machines/vm_networking/virt-using-mac-address-pool-for-vms.html"&gt;MAC
address pools&lt;/a&gt; to alleviate these issues. The high level description
reads:&lt;/p&gt;</description></item><item><title>Automatic hostname entries for libvirt domains</title><link>https://blog.oddbit.com/post/2013-10-04-automatic-dns-entrie/</link><pubDate>Fri, 04 Oct 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-10-04-automatic-dns-entrie/</guid><description>&lt;p&gt;Have you ever wished that you could use &lt;code&gt;libvirt&lt;/code&gt; domain names as
hostnames? So that you could do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ virt-install -n anewhost ...
$ ssh clouduser@anewhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since this is something that would certainly make my life convenient,
I put together a small script called &lt;a href="https://raw.github.com/larsks/virt-utils/master/virt-hosts"&gt;virt-hosts&lt;/a&gt; that makes this
possible. You can find &lt;a href="https://raw.github.com/larsks/virt-utils/master/virt-hosts"&gt;virt-hosts&lt;/a&gt; in my &lt;a href="https://raw.github.com/larsks/virt-utils/"&gt;virt-utils&lt;/a&gt; GitHub
repository:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://raw.github.com/larsks/virt-utils/master/virt-hosts"&gt;https://raw.github.com/larsks/virt-utils/master/virt-hosts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Run by itself, with no options, &lt;code&gt;virt-hosts&lt;/code&gt; will scan through your
running domains for interfaces on the libvirt &lt;code&gt;default&lt;/code&gt; network, look
up those MAC addresses up in the corresponding &lt;code&gt;default.leases&lt;/code&gt; file,
and then generate a hosts file on &lt;code&gt;stdout&lt;/code&gt; like this:&lt;/p&gt;</description></item><item><title>Did Arch Linux eat your KVM?</title><link>https://blog.oddbit.com/post/2013-04-08-did-archlinux-eat-yo/</link><pubDate>Mon, 08 Apr 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-04-08-did-archlinux-eat-yo/</guid><description>&lt;p&gt;A recent update to &lt;a href="https://www.archlinux.org/"&gt;Arch Linux&lt;/a&gt; replaced the &lt;code&gt;qemu-kvm&lt;/code&gt; package with
an updated version of &lt;code&gt;qemu&lt;/code&gt;. A side effect of this change is that
the &lt;code&gt;qemu-kvm&lt;/code&gt; binary is no longer available, and any &lt;code&gt;libvirt&lt;/code&gt; guests
on your system utilizing that binary will no longer operate. As is
typical with Arch, there is no announcement about this incompatible
change, and queries to &lt;code&gt;#archlinux&lt;/code&gt; will be met with the knowledge,
grace and decorum you would expect of that channel:&lt;/p&gt;</description></item><item><title>Growing a filesystem on a virtual disk</title><link>https://blog.oddbit.com/post/2012-10-24-resizing-virtual-disk/</link><pubDate>Wed, 24 Oct 2012 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2012-10-24-resizing-virtual-disk/</guid><description>&lt;p&gt;Occasionally we will deploy a virtual instance into our KVM
infrastructure and realize after the fact that we need more local disk
space available. This is the process we use to expand the disk image.
This process assumes the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You&amp;rsquo;re using legacy disk partitions. The process for LVM is similar
and I will describe that in another post (it&amp;rsquo;s generally identical
except for an additional &lt;code&gt;pvresize&lt;/code&gt; thrown in and &lt;code&gt;lvextend&lt;/code&gt; in
place of &lt;code&gt;resize2fs&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The partition you need to resize is the last partition on the disk.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This process will work with either a &lt;code&gt;qcow2&lt;/code&gt; or &lt;code&gt;raw&lt;/code&gt; disk image. For
&lt;code&gt;raw&lt;/code&gt; images you can also run &lt;code&gt;fdisk&lt;/code&gt; on the host, potentially saving
yourself a reboot, but that&amp;rsquo;s less convenient for &lt;code&gt;qcow2&lt;/code&gt; format
images.&lt;/p&gt;</description></item></channel></rss>