<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stackexchange on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/stackexchange/</link><description>Recent content in Stackexchange on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Sun, 19 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/stackexchange/rss.xml" rel="self" type="application/rss+xml"/><item><title>NAT between identical networks using VRF</title><link>https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/</link><pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/</guid><description>&lt;p>Last week, Oskar Stenberg asked on &lt;a href="https://unix.stackexchange.com/q/735931/4989">Unix &amp;amp; Linux&lt;/a> if it were possible to configure connectivity between two networks, both using the same address range, without involving network namespaces. That is, given this high level view of the network&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://excalidraw.com/#json=uuXRRZ2ybaAXiUvbQVkNO,krx3lsbf12c-tDhuWtRjbg">&lt;img alt="two networks with the same address range connected by a host named &amp;ldquo;middleman&amp;rdquo;" src="https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/the-problem.svg">&lt;/a>&lt;/p>
&lt;p>&amp;hellip;can we set things up so that hosts on the &amp;ldquo;inner&amp;rdquo; network can communicate with hosts on the &amp;ldquo;outer&amp;rdquo; network using the range &lt;code>192.168.3.0/24&lt;/code>, and similarly for communication in the other direction?&lt;/p></description><content>&lt;p>Last week, Oskar Stenberg asked on &lt;a href="https://unix.stackexchange.com/q/735931/4989">Unix &amp;amp; Linux&lt;/a> if it were possible to configure connectivity between two networks, both using the same address range, without involving network namespaces. That is, given this high level view of the network&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://excalidraw.com/#json=uuXRRZ2ybaAXiUvbQVkNO,krx3lsbf12c-tDhuWtRjbg">&lt;img alt="two networks with the same address range connected by a host named &amp;ldquo;middleman&amp;rdquo;" src="https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/the-problem.svg">&lt;/a>&lt;/p>
&lt;p>&amp;hellip;can we set things up so that hosts on the &amp;ldquo;inner&amp;rdquo; network can communicate with hosts on the &amp;ldquo;outer&amp;rdquo; network using the range &lt;code>192.168.3.0/24&lt;/code>, and similarly for communication in the other direction?&lt;/p>
&lt;h2 id="setting-up-a-lab">Setting up a lab&lt;/h2>
&lt;p>When investigating this sort of networking question, I find it easiest to reproduce the topology in a virtual environment so that it&amp;rsquo;s easy to test things out. I generally use &lt;a href="https://mininet.org">Mininet&lt;/a> for this, which provides a simple Python API for creating virtual nodes and switches and creating links between them.&lt;/p>
&lt;p>I created the following network topology for this test:&lt;/p>
&lt;figure class="center" >
&lt;img src="topology-1.svg" alt="virtual network topology diagram" />
&lt;/figure>
&lt;p>In the rest of this post, I&amp;rsquo;ll be referring to these hostnames.&lt;/p>
&lt;p>See the bottom of this post for a link to the repository that contains the complete test environment.&lt;/p>
&lt;h2 id="vrf-in-theory">VRF in theory&lt;/h2>
&lt;p>VRF stands for &amp;ldquo;Virtual Routing and Forwarding&amp;rdquo;. From the &lt;a href="https://en.wikipedia.org/wiki/Virtual_routing_and_forwarding">Wikipedia article on the topic&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>In IP-based computer networks, virtual routing and forwarding (VRF) is a technology that allows multiple instances of a routing table to co-exist within the same router at the same time. One or more logical or physical interfaces may have a VRF and these VRFs do not share routes therefore the packets are only forwarded between interfaces on the same VRF. VRFs are the TCP/IP layer 3 equivalent of a VLAN. Because the routing instances are independent, the same or overlapping IP addresses can be used without conflicting with each other. Network functionality is improved because network paths can be segmented without requiring multiple routers.&lt;a href="https://blog.oddbit.com/post/2023-02-19-vrf-and-nat/the-problem.svg">1&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>In Linux, VRF support is implemented as a &lt;a href="https://docs.kernel.org/networking/vrf.html">special type of network device&lt;/a>. A VRF device sets up an isolated routing domain; network traffic on devices associated with a VRF will use the routing table associated with that VRF, rather than the main routing table, which permits us to connect multiple networks with overlapping address ranges.&lt;/p>
&lt;p>We can create new VRF devices with the &lt;code>ip link add&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add vrf-inner type vrf table 100
&lt;/code>&lt;/pre>&lt;p>Running the above command results in the following changes:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>It creates a new network device named &lt;code>vrf-inner&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It adds a new route policy rule (if it doesn&amp;rsquo;t already exist) that looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>1000: from all lookup [l3mdev-table]
&lt;/code>&lt;/pre>&lt;p>This causes route lookups to use the appropriate route table for interfaces associated with a VRF.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>After creating a VRF device, we can add interfaces to it like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link set eth0 master vrf-inner
&lt;/code>&lt;/pre>&lt;p>This associates the given interface with the VRF device, and it moves all routes associated with the interface out of the &lt;code>local&lt;/code> and &lt;code>main&lt;/code> routing tables and into the VRF-specific routing table.&lt;/p>
&lt;p>You can see a list of vrf devices by running &lt;code>ip vrf show&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip vrf show
Name Table
-----------------------
vrf-inner 100
&lt;/code>&lt;/pre>&lt;p>You can see a list of devices associated with a particular VRF with the &lt;code>ip link&lt;/code> command:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip -brief link show master vrf-inner
eth0@if448 UP 72:87:af:d3:b5:f9 &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="vrf-in-practice">VRF in practice&lt;/h2>
&lt;p>We&amp;rsquo;re going to create two VRF devices on the &lt;code>middleman&lt;/code> host; one associated with the &amp;ldquo;inner&amp;rdquo; network and one associated with the &amp;ldquo;outer&amp;rdquo; network. In our virtual network topology, the &lt;code>middleman&lt;/code> host has two network interfaces:&lt;/p>
&lt;ul>
&lt;li>&lt;code>middleman-eth0&lt;/code> is connected to the &amp;ldquo;inner&amp;rdquo; network&lt;/li>
&lt;li>&lt;code>middleman-eth1&lt;/code> is connected to the &amp;ldquo;outer&amp;rdquo; network&lt;/li>
&lt;/ul>
&lt;p>Both devices have the same address (&lt;code>192.168.2.1&lt;/code>):&lt;/p>
&lt;pre tabindex="0">&lt;code># ip addr show
2: middleman-eth0@if426: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master vrf-inner state UP group default qlen 1000
link/ether 32:9e:01:2e:78:2f brd ff:ff:ff:ff:ff:ff link-netnsid 0
inet 192.168.2.1/24 brd 192.168.2.255 scope global middleman-eth0
valid_lft forever preferred_lft forever
root@mininet-vm:~/unix-735931# ip addr show middleman-eth1
3: middleman-eth1@if427: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master vrf-outer state UP group default qlen 1000
link/ether 12:be:9a:09:33:93 brd ff:ff:ff:ff:ff:ff link-netnsid 0
inet 192.168.2.1/24 brd 192.168.2.255 scope global middleman-eth1
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>And the main routing table looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip route show
192.168.2.0/24 dev middleman-eth1 proto kernel scope link src 192.168.2.1
192.168.2.0/24 dev middleman-eth0 proto kernel scope link src 192.168.2.1
&lt;/code>&lt;/pre>&lt;p>If you&amp;rsquo;re at all familiar with Linux network configuration, that probably looks weird. Right now this isn&amp;rsquo;t a particularly functional network configuration, but we can fix that!&lt;/p>
&lt;p>To create our two VRF devices, we run the following commands:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add vrf-inner type vrf table 100
ip link add vrf-outer type vrf table 200
ip link set vrf-inner up
ip link set vrf-outer up
&lt;/code>&lt;/pre>&lt;p>This associates &lt;code>vrf-inner&lt;/code> with route table 100, and &lt;code>vrf-outer&lt;/code> with route table 200. At this point, tables 100 and 200 are empty:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip route show table 100
Error: ipv4: FIB table does not exist.
Dump terminated
# ip route show table 200
Error: ipv4: FIB table does not exist.
Dump terminated
&lt;/code>&lt;/pre>&lt;p>Next, we add our interfaces to the appropriate VRF devices:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link set middleman-eth0 master vrf-inner
ip link set middleman-eth1 master vrf-outer
&lt;/code>&lt;/pre>&lt;p>After running these commands, there are no routes left in the main routing table:&lt;/p>
&lt;pre tabindex="0">&lt;code># ip route show
&amp;lt;no output&amp;gt;
&lt;/code>&lt;/pre>&lt;p>And the routes associated with our two physical interfaces are now contained by the appropriate VRF routing tables. Here&amp;rsquo;s table 100:&lt;/p>
&lt;pre tabindex="0">&lt;code>root@mininet-vm:~/unix-735931# ip route show table 100
broadcast 192.168.2.0 dev middleman-eth0 proto kernel scope link src 192.168.2.1
192.168.2.0/24 dev middleman-eth0 proto kernel scope link src 192.168.2.1
local 192.168.2.1 dev middleman-eth0 proto kernel scope host src 192.168.2.1
broadcast 192.168.2.255 dev middleman-eth0 proto kernel scope link src 192.168.2.1
&lt;/code>&lt;/pre>&lt;p>And table 200:&lt;/p>
&lt;pre tabindex="0">&lt;code>root@mininet-vm:~/unix-735931# ip route show table 200
broadcast 192.168.2.0 dev middleman-eth1 proto kernel scope link src 192.168.2.1
192.168.2.0/24 dev middleman-eth1 proto kernel scope link src 192.168.2.1
local 192.168.2.1 dev middleman-eth1 proto kernel scope host src 192.168.2.1
broadcast 192.168.2.255 dev middleman-eth1 proto kernel scope link src 192.168.2.1
&lt;/code>&lt;/pre>&lt;p>This configuration effectively gives us two isolated networks:&lt;/p>
&lt;figure class="center" >
&lt;img src="topology-2.svg" alt="virtual network topology diagram" />
&lt;/figure>
&lt;p>We can verify that nodes in the &amp;ldquo;inner&amp;rdquo; and &amp;ldquo;outer&amp;rdquo; networks are now able to communicate with &lt;code>middleman&lt;/code>. We can reach &lt;code>middleman&lt;/code> from &lt;code>innernode0&lt;/code>; in this case, we&amp;rsquo;re communicating with interface &lt;code>middleman-eth0&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ping -c1 192.168.2.1
PING 192.168.2.1 (192.168.2.1) 56(84) bytes of data.
64 bytes from 192.168.2.1: icmp_seq=1 ttl=64 time=0.126 ms
--- 192.168.2.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.126/0.126/0.126/0.000 ms
&lt;/code>&lt;/pre>&lt;p>Similarly, we can reach &lt;code>middleman&lt;/code> from &lt;code>outernode&lt;/code>, but in this case we&amp;rsquo;re communicating with interface &lt;code>middleman-eth1&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>outernode0# ping -c1 192.168.2.1
PING 192.168.2.1 (192.168.2.1) 56(84) bytes of data.
64 bytes from 192.168.2.1: icmp_seq=1 ttl=64 time=1.02 ms
--- 192.168.2.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 1.020/1.020/1.020/0.000 ms
&lt;/code>&lt;/pre>&lt;h2 id="configure-routing-on-the-nodes">Configure routing on the nodes&lt;/h2>
&lt;p>Our goal is to let nodes on one side of the network to use the address range &lt;code>192.168.3.0/24&lt;/code> to refer to nodes on the other side of the network. Right now, if we were to try to access &lt;code>192.168.3.10&lt;/code> from &lt;code>innernode0&lt;/code>, the attempt would fail with:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ping 192.168.3.10
ping: connect: Network is unreachable
&lt;/code>&lt;/pre>&lt;p>The &amp;ldquo;network is unreachable&amp;rdquo; message means that &lt;code>innernode0&lt;/code> has no idea where to send that request. That&amp;rsquo;s because at the moment, the routing table on all the nodes look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ip route
192.168.2.0/24 dev outernode0-eth0 proto kernel scope link src 192.168.2.10
&lt;/code>&lt;/pre>&lt;p>There is neither a default gateway nor a network-specific route appropriate for &lt;code>192.168.3.0/24&lt;/code> addresses. Let&amp;rsquo;s add a network route that will route that address range through &lt;code>middleman&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ip route add 192.168.3.0/24 via 192.168.2.1
innernode0# ip route
192.168.2.0/24 dev innernode0-eth0 proto kernel scope link src 192.168.2.10
192.168.3.0/24 via 192.168.2.1 dev innernode0-eth0
&lt;/code>&lt;/pre>&lt;p>This same change needs to be made on all the &lt;code>innernode*&lt;/code> and &lt;code>outernode*&lt;/code> nodes.&lt;/p>
&lt;p>With the route in place, attempts to reach &lt;code>192.168.3.10&lt;/code> from &lt;code>innernode0&lt;/code> will still fail, but now they&amp;rsquo;re getting rejected by &lt;code>middleman&lt;/code> because &lt;em>it&lt;/em> doesn&amp;rsquo;t have any appropriate routes:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# ping -c1 192.168.3.10
PING 192.168.3.10 (192.168.3.10) 56(84) bytes of data.
From 192.168.2.1 icmp_seq=1 Destination Net Unreachable
--- 192.168.3.10 ping statistics ---
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms
&lt;/code>&lt;/pre>&lt;p>We need to tell &lt;code>middleman&lt;/code> what to do with these packets.&lt;/p>
&lt;h2 id="configure-routing-and-nat-on-middleman">Configure routing and NAT on middleman&lt;/h2>
&lt;p>In order to achieve our desired connectivity, we need to:&lt;/p>
&lt;ol>
&lt;li>Map the &lt;code>192.168.3.0/24&lt;/code> destination address to the equivalent &lt;code>192.168.2.0/24&lt;/code> address &lt;em>before&lt;/em> the kernel makes a routing decision.&lt;/li>
&lt;li>Map the &lt;code>192.168.2.0/24&lt;/code> source address to the equivalent &lt;code>192.168.3.0/24&lt;/code> address &lt;em>after&lt;/em> the kernel makes a routing decision (so that replies will go back to &amp;ldquo;other&amp;rdquo; side).&lt;/li>
&lt;li>Ensure that the kernel uses the routing table for the &lt;em>target&lt;/em> network when making routing decisions for these connections.&lt;/li>
&lt;/ol>
&lt;p>We can achieve (1) and (2) using the netfilter &lt;a href="https://www.netfilter.org/documentation/HOWTO/netfilter-extensions-HOWTO-4.html#ss4.4">&lt;code>NETMAP&lt;/code>&lt;/a> extension by adding the following two rules:&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t nat -A PREROUTING -d 192.168.3.0/24 -j NETMAP --to 192.168.2.0/24
iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -j NETMAP --to 192.168.3.0/24
&lt;/code>&lt;/pre>&lt;p>For incoming traffic destined for the 192.168.3.0/24 network, this maps the destination address to the matching &lt;code>192.168.2.0/24&lt;/code> address. For outgoing traffic with a source address on the &lt;code>192.168.2.0/24&lt;/code> network, this maps the source to the equivalent &lt;code>192.168.3.0/24&lt;/code> network (so that the recipient see the traffic as coming from &amp;ldquo;the other side&amp;rdquo;).&lt;/p>
&lt;p>(For those of you wondering, &amp;ldquo;can we do this using &lt;code>nftables&lt;/code> instead?&amp;rdquo;, as of this writing &lt;a href="https://wiki.nftables.org/wiki-nftables/index.php/Supported_features_compared_to_xtables#NETMAP">&lt;code>nftables&lt;/code> does not appear to have &lt;code>NETMAP&lt;/code> support&lt;/a>, so we have to use &lt;code>iptables&lt;/code> for this step.)&lt;/p>
&lt;p>With this change in place, re-trying that &lt;code>ping&lt;/code> command on &lt;code>innernode0&lt;/code> will apparently succeed:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0 ping -c1 192.168.3.10
PING 192.168.3.10 (192.168.3.10) 56(84) bytes of data.
64 bytes from 192.168.3.10: icmp_seq=1 ttl=63 time=0.063 ms
--- 192.168.3.10 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.063/0.063/0.063/0.000 ms
&lt;/code>&lt;/pre>&lt;p>However, running &lt;code>tcpdump&lt;/code> on &lt;code>middleman&lt;/code> will show us that we haven&amp;rsquo;t yet achieved our goal:&lt;/p>
&lt;pre tabindex="0">&lt;code>12:59:52.899054 middleman-eth0 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo request, id 16520, seq 1, length 64
12:59:52.899077 middleman-eth0 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo request, id 16520, seq 1, length 64
12:59:52.899127 middleman-eth0 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo reply, id 16520, seq 1, length 64
12:59:52.899130 middleman-eth0 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo reply, id 16520, seq 1, length 64
&lt;/code>&lt;/pre>&lt;p>You can see that our packet is coming on on &lt;code>middleman-eth0&lt;/code>&amp;hellip;and going right back out the same interface. We have thus far achieved a very complicated loopback interface.&lt;/p>
&lt;p>The missing piece is some logic to have the kernel use the routing table for the &amp;ldquo;other side&amp;rdquo; when making routing decisions for these packets. We&amp;rsquo;re going to do that by:&lt;/p>
&lt;ol>
&lt;li>Tagging packets with a mark that indicates the interface on which they were recieved&lt;/li>
&lt;li>Using this mark to select an appropriate routing table&lt;/li>
&lt;/ol>
&lt;p>We add the packet mark by adding these rules to the &lt;code>MANGLE&lt;/code> table &lt;code>PREROUTING&lt;/code> chain:&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t mangle -A PREROUTING -i middleman-eth0 -d 192.168.3.0/24 -j MARK --set-mark 100
iptables -t mangle -A PREROUTING -i middleman-eth1 -d 192.168.3.0/24 -j MARK --set-mark 200
&lt;/code>&lt;/pre>&lt;p>And we utilize that mark in route lookups by adding the following two route policy rules:&lt;/p>
&lt;pre tabindex="0">&lt;code>ip rule add prio 100 fwmark 100 lookup 200
ip rule add prio 200 fwmark 200 lookup 100
&lt;/code>&lt;/pre>&lt;p>It is critical that these rules come before (aka &amp;ldquo;have a higher priority than&amp;rdquo;, aka &amp;ldquo;have a lower number than&amp;rdquo;) the &lt;code>l3mdev&lt;/code> rule added when we created the VRF devices.&lt;/p>
&lt;h2 id="validation-does-it-actually-work">Validation: Does it actually work?&lt;/h2>
&lt;p>With that last set of changes in place, if we repeat the &lt;code>ping&lt;/code> test from &lt;code>innernode0&lt;/code> to &lt;code>outernode0&lt;/code> and run &lt;code>tcpdump&lt;/code> on &lt;code>middleman&lt;/code>, we see:&lt;/p>
&lt;pre tabindex="0">&lt;code>13:05:27.667793 middleman-eth0 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo request, id 16556, seq 1, length 64
13:05:27.667816 middleman-eth1 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo request, id 16556, seq 1, length 64
13:05:27.667863 middleman-eth1 In IP 192.168.2.10 &amp;gt; 192.168.3.10: ICMP echo reply, id 16556, seq 1, length 64
13:05:27.667868 middleman-eth0 Out IP 192.168.3.10 &amp;gt; 192.168.2.10: ICMP echo reply, id 16556, seq 1, length 64
&lt;/code>&lt;/pre>&lt;p>Now we finally see the desired behavior: the request from &lt;code>innernode0&lt;/code> comes in on &lt;code>eth0&lt;/code>, goes out on &lt;code>eth1&lt;/code> with the addresses appropriately mapped and gets delivered to &lt;code>outernode0&lt;/code>. The reply from &lt;code>outernode0&lt;/code> goes through the process in reverse, and arrives back at &lt;code>innernode0&lt;/code>.&lt;/p>
&lt;h2 id="connection-tracking-or-one-more-thing">Connection tracking (or, &amp;ldquo;One more thing&amp;hellip;&amp;rdquo;)&lt;/h2>
&lt;p>There is a subtle problem with the configuration we&amp;rsquo;ve implemented so far: the Linux connection tracking mechanism (&amp;quot;&lt;a href="https://arthurchiao.art/blog/conntrack-design-and-implementation/">conntrack&lt;/a>&amp;quot;) by default identifies a connection by the 4-tuple &lt;code>(source_address, source_port, destination_address, destination_port)&lt;/code>. To understand why this is a problem, assume that we&amp;rsquo;re running a web server on port 80 on all the &amp;ldquo;inner&amp;rdquo; and &amp;ldquo;outer&amp;rdquo; nodes.&lt;/p>
&lt;p>To connect from &lt;code>innernode0&lt;/code> to &lt;code>outernode0&lt;/code>, we could use the following command. We&amp;rsquo;re using the &lt;code>--local-port&lt;/code> option here because we want to control the source port of our connections:&lt;/p>
&lt;pre tabindex="0">&lt;code>innernode0# curl --local-port 4000 192.168.3.10
&lt;/code>&lt;/pre>&lt;p>To connect from &lt;code>outernode0&lt;/code> to &lt;code>innernode0&lt;/code>, we would use the same command:&lt;/p>
&lt;pre tabindex="0">&lt;code>outernode0# curl --local-port 4000 192.168.3.10
&lt;/code>&lt;/pre>&lt;p>If we look at the connection tracking table on &lt;code>middleman&lt;/code>, we will see a single connection:&lt;/p>
&lt;pre tabindex="0">&lt;code>middleman# conntrack -L
tcp 6 115 TIME_WAIT src=192.168.2.10 dst=192.168.3.10 sport=4000 dport=80 src=192.168.2.10 dst=192.168.3.10 sport=80 dport=4000 [ASSURED] mark=0 use=1
&lt;/code>&lt;/pre>&lt;p>This happens because the 4-tuple for our two connections is identical. Conflating connections like this can cause traffic to stop flowing if both connections are active at the same time.&lt;/p>
&lt;p>We need to provide the connection track subsystem with some additional information to uniquely identify these connections. We can do this by using the netfilter &lt;code>CT&lt;/code> module to assign each connection to a unique conntrack origination &amp;ldquo;zone&amp;rdquo;:&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -t raw -A PREROUTING -s 192.168.2.0/24 -i middleman-eth0 -j CT --zone-orig 100
iptables -t raw -A PREROUTING -s 192.168.2.0/24 -i middleman-eth1 -j CT --zone-orig 200
&lt;/code>&lt;/pre>&lt;p>What is a &amp;ldquo;zone&amp;rdquo;? From &lt;a href="https://lore.kernel.org/all/4B9158F5.5040205@parallels.com/T/">the patch adding this feature&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>A zone is simply a numerical identifier associated with a network
device that is incorporated into the various hashes and used to
distinguish entries in addition to the connection tuples.&lt;/p>
&lt;/blockquote>
&lt;p>With these rules in place, if we repeat the test with &lt;code>curl&lt;/code> we will see two distinct connections:&lt;/p>
&lt;pre tabindex="0">&lt;code>middleman# conntrack -L
tcp 6 117 TIME_WAIT src=192.168.2.10 dst=192.168.3.10 sport=4000 dport=80 zone-orig=100 src=192.168.2.10 dst=192.168.3.10 sport=80 dport=26148 [ASSURED] mark=0 use=1
tcp 6 115 TIME_WAIT src=192.168.2.10 dst=192.168.3.10 sport=4000 dport=80 zone-orig=200 src=192.168.2.10 dst=192.168.3.10 sport=80 dport=4000 [ASSURED] mark=0 use=1
&lt;/code>&lt;/pre>&lt;h2 id="repository-and-demo">Repository and demo&lt;/h2>
&lt;p>You can find a complete test environment in &lt;a href="https://github.com/larsks/unix-example-735931-1-1-nat">this repository&lt;/a>; that includes the mininet topology I mentioned at the beginning of this post as well as shell scripts to implement all the address, route, and netfilter configurations.&lt;/p>
&lt;p>And here&amp;rsquo;s a video that runs through the steps described in this post:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/Kws98JNKcxE?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div></content></item><item><title>A pair of userscripts for cleaning up Stack Exchange sites</title><link>https://blog.oddbit.com/post/2021-09-05-sx-question-filters/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-09-05-sx-question-filters/</guid><description>&lt;p>I&amp;rsquo;ve been a regular visitor to &lt;a href="https://stackoverflow.com">Stack Overflow&lt;/a> and other &lt;a href="https://stackexchange.com">Stack
Exchange&lt;/a> sites over the years, and while I&amp;rsquo;ve mostly enjoyed the
experience, I&amp;rsquo;ve been frustrated by the lack of control I have over
what questions I see. I&amp;rsquo;m not really interested in looking at
questions that have already been closed, or that have a negative
score, but there&amp;rsquo;s no native facility for filtering questions like
this.&lt;/p>
&lt;p>I finally spent the time learning just enough JavaScript ~~~to hurt
myself~~~ to put together a pair of scripts that let me present the
questions that way I want:&lt;/p></description><content>&lt;p>I&amp;rsquo;ve been a regular visitor to &lt;a href="https://stackoverflow.com">Stack Overflow&lt;/a> and other &lt;a href="https://stackexchange.com">Stack
Exchange&lt;/a> sites over the years, and while I&amp;rsquo;ve mostly enjoyed the
experience, I&amp;rsquo;ve been frustrated by the lack of control I have over
what questions I see. I&amp;rsquo;m not really interested in looking at
questions that have already been closed, or that have a negative
score, but there&amp;rsquo;s no native facility for filtering questions like
this.&lt;/p>
&lt;p>I finally spent the time learning just enough JavaScript ~~~to hurt
myself~~~ to put together a pair of scripts that let me present the
questions that way I want:&lt;/p>
&lt;h2 id="sx-hide-questions">sx-hide-questions&lt;/h2>
&lt;p>The &lt;a href="https://github.com/larsks/sx-question-filter/raw/master/sx-hide-questions.user.js">sx-hide-questions&lt;/a> script will hide:&lt;/p>
&lt;ul>
&lt;li>Questions that are closed&lt;/li>
&lt;li>Questions that are marked as a duplicate&lt;/li>
&lt;li>Questions that have a score below 0&lt;/li>
&lt;/ul>
&lt;p>Because I wanted it to be obvious that the script was actually doing
something, hidden questions don&amp;rsquo;t just disappear; they fade out.&lt;/p>
&lt;p>These behaviors (including the fading) can all be controlled
individually by a set of global variables at the top of the script.&lt;/p>
&lt;figure class="left" >
&lt;img src="fading.gif" />
&lt;/figure>
&lt;h2 id="sx-reorder-questions">sx-reorder questions&lt;/h2>
&lt;p>The &lt;a href="https://github.com/larsks/sx-question-filter/raw/master/sx-reorder-questions.user.js">sx-reorder-questions&lt;/a> script will sort questions such that
anything that has an answer will be at the bottom, and questions that
have not yet been answered appear at the top.&lt;/p>
&lt;h2 id="installation">Installation&lt;/h2>
&lt;p>If you are using the &lt;a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en">Tampermonkey&lt;/a> extension, you should be able to
click on the links to the script earlier in this post and be taken
directly to the installation screen. If you&amp;rsquo;re &lt;em>not&lt;/em> running
Tampermonkey, than either (a) install it, or (b) you&amp;rsquo;re on your own.&lt;/p>
&lt;p>You can find both of these scripts in my &lt;a href="https://github.com/larsks/sx-question-filter">sx-question-filter&lt;/a>
repository.&lt;/p>
&lt;h2 id="caveats">Caveats&lt;/h2>
&lt;p>These scripts rely on the CSS classes and layout of the Stack Exchange
websites. If these change, the scripts will need updating. If you
notice that something no longer works as advertised, please feel free
to submit pull request with the necessary corrections!&lt;/p></content></item><item><title>Unpacking a Python regular expression</title><link>https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/</link><pubDate>Tue, 07 May 2019 10:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/</guid><description>&lt;p>I recently answered &lt;a href="https://stackoverflow.com/q/55965819/147356">a question&lt;/a> from &lt;a href="https://stackoverflow.com/users/7738974/harsha-nalore">Harsha Nalore&lt;/a> on &lt;a href="https://stackoverflow.com/">StackOverflow&lt;/a> that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an &lt;a href="https://ansible.com/">Ansible&lt;/a> filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are.&lt;/p></description><content>&lt;p>I recently answered &lt;a href="https://stackoverflow.com/q/55965819/147356">a question&lt;/a> from &lt;a href="https://stackoverflow.com/users/7738974/harsha-nalore">Harsha Nalore&lt;/a> on &lt;a href="https://stackoverflow.com/">StackOverflow&lt;/a> that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an &lt;a href="https://ansible.com/">Ansible&lt;/a> filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are.&lt;/p>
&lt;p>The output in question looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>gtm wideip a wideip {
description wideip
pool-lb-mode topology
pools {
test1-pool {
order 1
}
test2-pool {
order 0
}
}
}
&lt;/code>&lt;/pre>&lt;p>The goal is to return a list of pool names. You can see the complete solution in &lt;a href="https://stackoverflow.com/a/55970019/147356">my answer&lt;/a>; for the purposes of this post we&amp;rsquo;re interesting in the following two regular expressions:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>re_pools &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?P&amp;lt;parameters&amp;gt;(\S+ \s+ \S+ \s+)*)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pools \s+ { \s+ (?P&amp;lt;pools&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">\S+ \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[^}]* \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">} \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)+ \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>re_pool &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(\S+) \s+ { \s+ [^}]* \s+ } \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="verbose-mode">VERBOSE mode&lt;/h1>
&lt;p>The first thing to note is that I&amp;rsquo;m using &lt;code>VERBOSE&lt;/code> syntax for both of these expressions. That means that whitespace must be included explicitly in the expression. That&amp;rsquo;s what all of those &lt;code>\s+&lt;/code> markers are &amp;ndash; that means &amp;ldquo;any white space character, one or more times&amp;rdquo;. For example, consider the following simple expression:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#66d9ef">match&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The pattern matches the string just fine. But if we were to enable the &lt;code>VERBOSE&lt;/code> flag, the pattern would no longer match:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#66d9ef">match&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We would instead need to write it like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#66d9ef">match&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this \s is \s a \s test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The advantage to &lt;code>VERBOSE&lt;/code> mode is that you can split your regular expression across multiple lines for legibility:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#66d9ef">match&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... this \s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... is \s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... a \s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... test&amp;#39;&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="capture-groups">Capture groups&lt;/h2>
&lt;p>In order to make it easier to extract information from the results of a match, I&amp;rsquo;m using named capture groups. A &amp;ldquo;capture group&amp;rdquo; is a part of the expression inside parentheses that can be extracted from the resulting match object. Unnamed groups can be extracted using their index. If we wanted to match the phrase &lt;code>this is a &amp;lt;noun&amp;gt;&lt;/code>, rather than &lt;code>this is a test&lt;/code>, and we wanted to extract the noun, we might write something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_example &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;this is a (\S+)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span> &lt;span style="color:#f92672">=&lt;/span> re_example&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#66d9ef">match&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this is a frog&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span>&lt;span style="color:#f92672">.&lt;/span>groups()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>,)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span>&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The expression &lt;code>(\S+)&lt;/code> is a capture group that will match any string of non-whitespace characters. This works fine for a simple expression, but keeping the index straight in a complex expression can be difficult. This is where named capture groups become useful. We could rewrite the above like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_example &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;this is a (?P&amp;lt;noun&amp;gt;\S+)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span> &lt;span style="color:#f92672">=&lt;/span> re_example&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#66d9ef">match&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this is a frog&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span>&lt;span style="color:#f92672">.&lt;/span>groupdict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#e6db74">&amp;#39;noun&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span>&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#e6db74">&amp;#39;noun&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="non-capture-groups">Non-capture groups&lt;/h2>
&lt;p>Sometimes, you want to group part of a regular expression in a way that does not result in another capture group. This is what the &lt;code>(?: ...)&lt;/code> expression is for. For example, we we were to write:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_example &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;this (?:is|was) a (?P&amp;lt;noun&amp;gt;\S+)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we could match the phrase &lt;code>this is a test&lt;/code> or &lt;code>this was a test&lt;/code>, but we would still only have a single capture group:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span> &lt;span style="color:#f92672">=&lt;/span> re_example&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#66d9ef">match&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span>&lt;span style="color:#f92672">.&lt;/span>groupdict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#e6db74">&amp;#39;noun&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;test&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="putting-it-all-together">Putting it all together&lt;/h2>
&lt;p>With all that in mind, let&amp;rsquo;s take a look at the regular expression in my answer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>re_pools &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?P&amp;lt;parameters&amp;gt;(\S+ \s+ \S+ \s+)*)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pools \s+ { \s+ (?P&amp;lt;pools&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">\S+ \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[^}]* \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">} \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)+ \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first line matches &lt;code>gtm wideip a &amp;lt;something&amp;gt; {&lt;/code>:&lt;/p>
&lt;pre>&lt;code>gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
&lt;/code>&lt;/pre>
&lt;p>Next, we match the &lt;code>&amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code> part of the output, which looks like this:&lt;/p>
&lt;pre>&lt;code>description wideip
pool-lb-mode topology
&lt;/code>&lt;/pre>
&lt;p>With this expression:&lt;/p>
&lt;pre>&lt;code> (?P&amp;lt;parameters&amp;gt;(\S+ \s+ \S+ \s+)*)
&lt;/code>&lt;/pre>
&lt;p>That is a named capture group (&amp;ldquo;parameters&amp;rdquo;) that matches the expression &lt;code>(\S+ \s+ \S+ \s+)&lt;/code> zero or more times (&lt;code>*&lt;/code>). Since &lt;code>\S+&lt;/code> means &amp;ldquo;a string of non-whitespace characters&amp;rdquo; and &lt;code>\s+&lt;/code> means &amp;ldquo;a string of whitespace characters&amp;rdquo;, this correctly matches that part of the output.&lt;/p>
&lt;p>Next, we match the entire &lt;code>pools {...}&lt;/code> part of the output with this expression:&lt;/p>
&lt;pre>&lt;code>pools \s+ { \s+ (?P&amp;lt;pools&amp;gt;
(?:
\S+ \s+ { \s+
[^}]* \s+
} \s+
)+ \s+
)
&lt;/code>&lt;/pre>
&lt;p>That creates a named capture group (&amp;ldquo;pools&amp;rdquo;) that looks for one or more occurrences of the pattern:&lt;/p>
&lt;pre>&lt;code>\S+ \s+ { \s+
[^}]* \s+
} \s+
&lt;/code>&lt;/pre>
&lt;p>The first line will match a string like &lt;code>test1-pool1 {&lt;/code>. The next line matches any sequence of characters that are not &lt;code>}&lt;/code>, so that gathers up everthing between &lt;code>test1-pool {&lt;/code> and the closing &lt;code>}&lt;/code>. Because we have the entire thing wrapped in &lt;code>(?: ...)+&lt;/code>, we are looking for one or more matches of that sub-expression, which gathers up all of the pool definitions.&lt;/p>
&lt;p>Finally we match the closing brace:&lt;/p>
&lt;pre>&lt;code>}
&lt;/code>&lt;/pre>
&lt;p>When that expression matches, we end up with a match object that has a &lt;code>pools&lt;/code> match group that will look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> print(&lt;span style="color:#66d9ef">match&lt;/span>&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#e6db74">&amp;#39;pools&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test1&lt;span style="color:#f92672">-&lt;/span>pool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test2&lt;span style="color:#f92672">-&lt;/span>pool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We now use a much simpler regular expression to extract the pool names from that content:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>re_pool &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(\S+) \s+ { \s+ [^}]* \s+ } \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That has a single capture group (&lt;code>(\S+)&lt;/code>) that will match the pool name; the remainder of the expression takes care of matching the &lt;code>{ &amp;lt;anythingthing not '}'&amp;gt; }&lt;/code> part. We use &lt;code>re.findall&lt;/code> to get &lt;em>all&lt;/em> of the matches in one go:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_pool&lt;span style="color:#f92672">.&lt;/span>findall(&lt;span style="color:#66d9ef">match&lt;/span>&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#e6db74">&amp;#39;pools&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#e6db74">&amp;#39;test1-pool&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test2-pool&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And that&amp;rsquo;s it!&lt;/p>
&lt;h2 id="for-more-information">For more information&lt;/h2>
&lt;p>For more information on Python regular expressions:&lt;/p>
&lt;ul>
&lt;li>The documentation for the &lt;a href="https://docs.python.org/3/library/re.html">re&lt;/a> module.&lt;/li>
&lt;li>The &lt;a href="https://docs.python.org/3/howto/regex.html">Regular expression HOWTO&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>