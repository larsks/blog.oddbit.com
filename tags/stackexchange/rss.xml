<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>stackexchange on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/stackexchange/</link><description>Recent content in stackexchange on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Sun, 05 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/stackexchange/rss.xml" rel="self" type="application/rss+xml"/><item><title>A pair of userscripts for cleaning up Stack Exchange sites</title><link>https://blog.oddbit.com/posts/sx-question-filters/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/posts/sx-question-filters/</guid><description>I&amp;rsquo;ve been a regular visitor to Stack Overflow and other Stack Exchange sites over the years, and while I&amp;rsquo;ve mostly enjoyed the experience, I&amp;rsquo;ve been frustrated by the lack of control I have over what questions I see. I&amp;rsquo;m not really interested in looking at questions that have already been closed, or that have a negative score, but there&amp;rsquo;s no native facility for filtering questions like this.
I finally spent the time learning just enough JavaScript to hurt myself to put together a pair of scripts that let me present the questions that way I want:</description><content>&lt;p>I&amp;rsquo;ve been a regular visitor to &lt;a href="https://stackoverflow.com">Stack Overflow&lt;/a> and other &lt;a href="https://stackexchange.com">Stack
Exchange&lt;/a> sites over the years, and while I&amp;rsquo;ve mostly enjoyed the
experience, I&amp;rsquo;ve been frustrated by the lack of control I have over
what questions I see. I&amp;rsquo;m not really interested in looking at
questions that have already been closed, or that have a negative
score, but there&amp;rsquo;s no native facility for filtering questions like
this.&lt;/p>
&lt;p>I finally spent the time learning just enough JavaScript &lt;del>&lt;del>to hurt
myself&lt;/del>&lt;/del> to put together a pair of scripts that let me present the
questions that way I want:&lt;/p>
&lt;h2 id="sx-hide-questions">sx-hide-questions&lt;/h2>
&lt;p>The &lt;a href="https://github.com/larsks/sx-question-filter/raw/master/sx-hide-questions.user.js">sx-hide-questions&lt;/a> script will hide:&lt;/p>
&lt;ul>
&lt;li>Questions that are closed&lt;/li>
&lt;li>Questions that are marked as a duplicate&lt;/li>
&lt;li>Questions that have a score below 0&lt;/li>
&lt;/ul>
&lt;p>Because I wanted it to be obvious that the script was actually doing
something, hidden questions don&amp;rsquo;t just disappear; they fade out.&lt;/p>
&lt;p>These behaviors (including the fading) can all be controlled
individually by a set of global variables at the top of the script.&lt;/p>
&lt;figure class="left" >
&lt;img src="fading.gif" />
&lt;/figure>
&lt;h2 id="sx-reorder-questions">sx-reorder questions&lt;/h2>
&lt;p>The &lt;a href="https://github.com/larsks/sx-question-filter/raw/master/sx-reorder-questions.user.js">sx-reorder-questions&lt;/a> script will sort questions such that
anything that has an answer will be at the bottom, and questions that
have not yet been answered appear at the top.&lt;/p>
&lt;h2 id="installation">Installation&lt;/h2>
&lt;p>If you are using the &lt;a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en">Tampermonkey&lt;/a> extension, you should be able to
click on the links to the script earlier in this post and be taken
directly to the installation screen. If you&amp;rsquo;re &lt;em>not&lt;/em> running
Tampermonkey, than either (a) install it, or (b) you&amp;rsquo;re on your own.&lt;/p>
&lt;p>You can find both of these scripts in my &lt;a href="https://github.com/larsks/sx-question-filter">sx-question-filter&lt;/a>
repository.&lt;/p>
&lt;h2 id="caveats">Caveats&lt;/h2>
&lt;p>These scripts rely on the CSS classes and layout of the Stack Exchange
websites. If these change, the scripts will need updating. If you
notice that something no longer works as advertised, please feel free
to submit pull request with the necessary corrections!&lt;/p></content></item><item><title>Unpacking a Python regular expression</title><link>https://blog.oddbit.com/posts/unpacking-a-python-regular-exp/</link><pubDate>Tue, 07 May 2019 10:00:00 +0000</pubDate><guid>https://blog.oddbit.com/posts/unpacking-a-python-regular-exp/</guid><description>I recently answered a question from Harsha Nalore on StackOverflow that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an Ansible filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are.</description><content>&lt;p>I recently answered &lt;a href="https://stackoverflow.com/q/55965819/147356">a question&lt;/a> from &lt;a href="https://stackoverflow.com/users/7738974/harsha-nalore">Harsha Nalore&lt;/a> on &lt;a href="https://stackoverflow.com/">StackOverflow&lt;/a> that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an &lt;a href="https://ansible.com/">Ansible&lt;/a> filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are.&lt;/p>
&lt;p>The output in question looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>gtm wideip a wideip {
description wideip
pool-lb-mode topology
pools {
test1-pool {
order 1
}
test2-pool {
order 0
}
}
}
&lt;/code>&lt;/pre>&lt;p>The goal is to return a list of pool names. You can see the complete solution in &lt;a href="https://stackoverflow.com/a/55970019/147356">my answer&lt;/a>; for the purposes of this post we&amp;rsquo;re interesting in the following two regular expressions:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>re_pools &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?P&amp;lt;parameters&amp;gt;(\S+ \s+ \S+ \s+)*)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pools \s+ { \s+ (?P&amp;lt;pools&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">\S+ \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[^}]* \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">} \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)+ \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>re_pool &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(\S+) \s+ { \s+ [^}]* \s+ } \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="verbose-mode">VERBOSE mode&lt;/h1>
&lt;p>The first thing to note is that I&amp;rsquo;m using &lt;code>VERBOSE&lt;/code> syntax for both of these expressions. That means that whitespace must be included explicitly in the expression. That&amp;rsquo;s what all of those &lt;code>\s+&lt;/code> markers are &amp;ndash; that means &amp;ldquo;any white space character, one or more times&amp;rdquo;. For example, consider the following simple expression:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>match(&lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The pattern matches the string just fine. But if we were to enable the &lt;code>VERBOSE&lt;/code> flag, the pattern would no longer match:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>match(&lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We would instead need to write it like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>match(&lt;span style="color:#e6db74">&amp;#39;this \s is \s a \s test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The advantage to &lt;code>VERBOSE&lt;/code> mode is that you can split your regular expression across multiple lines for legibility:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>match(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... this \s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... is \s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... a \s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">... test&amp;#39;&amp;#39;&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="capture-groups">Capture groups&lt;/h2>
&lt;p>In order to make it easier to extract information from the results of a match, I&amp;rsquo;m using named capture groups. A &amp;ldquo;capture group&amp;rdquo; is a part of the expression inside parentheses that can be extracted from the resulting match object. Unnamed groups can be extracted using their index. If we wanted to match the phrase &lt;code>this is a &amp;lt;noun&amp;gt;&lt;/code>, rather than &lt;code>this is a test&lt;/code>, and we wanted to extract the noun, we might write something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_example &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;this is a (\S+)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match &lt;span style="color:#f92672">=&lt;/span> re_example&lt;span style="color:#f92672">.&lt;/span>match(&lt;span style="color:#e6db74">&amp;#39;this is a frog&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match&lt;span style="color:#f92672">.&lt;/span>groups()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>,)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The expression &lt;code>(\S+)&lt;/code> is a capture group that will match any string of non-whitespace characters. This works fine for a simple expression, but keeping the index straight in a complex expression can be difficult. This is where named capture groups become useful. We could rewrite the above like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_example &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;this is a (?P&amp;lt;noun&amp;gt;\S+)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match &lt;span style="color:#f92672">=&lt;/span> re_example&lt;span style="color:#f92672">.&lt;/span>match(&lt;span style="color:#e6db74">&amp;#39;this is a frog&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match&lt;span style="color:#f92672">.&lt;/span>groupdict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#e6db74">&amp;#39;noun&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#e6db74">&amp;#39;noun&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;frog&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="non-capture-groups">Non-capture groups&lt;/h2>
&lt;p>Sometimes, you want to group part of a regular expression in a way that does not result in another capture group. This is what the &lt;code>(?: ...)&lt;/code> expression is for. For example, we we were to write:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_example &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;this (?:is|was) a (?P&amp;lt;noun&amp;gt;\S+)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we could match the phrase &lt;code>this is a test&lt;/code> or &lt;code>this was a test&lt;/code>, but we would still only have a single capture group:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match &lt;span style="color:#f92672">=&lt;/span> re_example&lt;span style="color:#f92672">.&lt;/span>match(&lt;span style="color:#e6db74">&amp;#39;this is a test&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> match&lt;span style="color:#f92672">.&lt;/span>groupdict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#e6db74">&amp;#39;noun&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;test&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="putting-it-all-together">Putting it all together&lt;/h2>
&lt;p>With all that in mind, let&amp;rsquo;s take a look at the regular expression in my answer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>re_pools &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?P&amp;lt;parameters&amp;gt;(\S+ \s+ \S+ \s+)*)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">pools \s+ { \s+ (?P&amp;lt;pools&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(?:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">\S+ \s+ { \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">[^}]* \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">} \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)+ \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first line matches &lt;code>gtm wideip a &amp;lt;something&amp;gt; {&lt;/code>:&lt;/p>
&lt;pre>&lt;code>gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
&lt;/code>&lt;/pre>
&lt;p>Next, we match the &lt;code>&amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code> part of the output, which looks like this:&lt;/p>
&lt;pre>&lt;code>description wideip
pool-lb-mode topology
&lt;/code>&lt;/pre>
&lt;p>With this expression:&lt;/p>
&lt;pre>&lt;code> (?P&amp;lt;parameters&amp;gt;(\S+ \s+ \S+ \s+)*)
&lt;/code>&lt;/pre>
&lt;p>That is a named capture group (&amp;ldquo;parameters&amp;rdquo;) that matches the expression &lt;code>(\S+ \s+ \S+ \s+)&lt;/code> zero or more times (&lt;code>*&lt;/code>). Since &lt;code>\S+&lt;/code> means &amp;ldquo;a string of non-whitespace characters&amp;rdquo; and &lt;code>\s+&lt;/code> means &amp;ldquo;a string of whitespace characters&amp;rdquo;, this correctly matches that part of the output.&lt;/p>
&lt;p>Next, we match the entire &lt;code>pools {...}&lt;/code> part of the output with this expression:&lt;/p>
&lt;pre>&lt;code>pools \s+ { \s+ (?P&amp;lt;pools&amp;gt;
(?:
\S+ \s+ { \s+
[^}]* \s+
} \s+
)+ \s+
)
&lt;/code>&lt;/pre>
&lt;p>That creates a named capture group (&amp;ldquo;pools&amp;rdquo;) that looks for one or more occurrences of the pattern:&lt;/p>
&lt;pre>&lt;code>\S+ \s+ { \s+
[^}]* \s+
} \s+
&lt;/code>&lt;/pre>
&lt;p>The first line will match a string like &lt;code>test1-pool1 {&lt;/code>. The next line matches any sequence of characters that are not &lt;code>}&lt;/code>, so that gathers up everthing between &lt;code>test1-pool {&lt;/code> and the closing &lt;code>}&lt;/code>. Because we have the entire thing wrapped in &lt;code>(?: ...)+&lt;/code>, we are looking for one or more matches of that sub-expression, which gathers up all of the pool definitions.&lt;/p>
&lt;p>Finally we match the closing brace:&lt;/p>
&lt;pre>&lt;code>}
&lt;/code>&lt;/pre>
&lt;p>When that expression matches, we end up with a match object that has a &lt;code>pools&lt;/code> match group that will look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> print(match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#e6db74">&amp;#39;pools&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test1&lt;span style="color:#f92672">-&lt;/span>pool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test2&lt;span style="color:#f92672">-&lt;/span>pool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We now use a much simpler regular expression to extract the pool names from that content:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>re_pool &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">(\S+) \s+ { \s+ [^}]* \s+ } \s+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>, flags&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>VERBOSE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That has a single capture group (&lt;code>(\S+)&lt;/code>) that will match the pool name; the remainder of the expression takes care of matching the &lt;code>{ &amp;lt;anythingthing not '}'&amp;gt; }&lt;/code> part. We use &lt;code>re.findall&lt;/code> to get &lt;em>all&lt;/em> of the matches in one go:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> re_pool&lt;span style="color:#f92672">.&lt;/span>findall(match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#e6db74">&amp;#39;pools&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#e6db74">&amp;#39;test1-pool&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test2-pool&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And that&amp;rsquo;s it!&lt;/p>
&lt;h2 id="for-more-information">For more information&lt;/h2>
&lt;p>For more information on Python regular expressions:&lt;/p>
&lt;ul>
&lt;li>The documentation for the &lt;a href="https://docs.python.org/3/library/re.html">re&lt;/a> module.&lt;/li>
&lt;li>The &lt;a href="https://docs.python.org/3/howto/regex.html">Regular expression HOWTO&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>