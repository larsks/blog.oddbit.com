<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kernel on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/kernel/</link><description>Recent content in Kernel on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 10:58:10 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/kernel/rss.xml" rel="self" type="application/rss+xml"/><item><title>Packet, packet, who's got the packet?</title><link>https://blog.oddbit.com/post/2023-02-14-whos-got-the-packet/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2023-02-14-whos-got-the-packet/</guid><description>&lt;p&gt;In &lt;a href="https://unix.stackexchange.com/q/735522/4989"&gt;this question&lt;/a&gt;, August Vrubel has some C code that sets up a &lt;a href="https://docs.kernel.org/networking/tuntap.html"&gt;tun&lt;/a&gt; interface and then injects a packet, but the packet seemed to disappear into the ether. In this post, I&amp;rsquo;d like to take a slightly extended look at &lt;a href="https://unix.stackexchange.com/a/735534/4989"&gt;my answer&lt;/a&gt; because I think it&amp;rsquo;s a great opportunity for learning a bit more about performing network diagnostics.&lt;/p&gt;
&lt;p&gt;The original code looked like this:&lt;/p&gt;



 &lt;div class="collapsable-code"&gt;
 &lt;input id="321576498" type="checkbox" /&gt;
 &lt;label for="321576498"&gt;
 &lt;span class="collapsable-code__language"&gt;c&lt;/span&gt;
 &lt;span class="collapsable-code__title"&gt;original sendpacket.c&lt;/span&gt;
 &lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽"&gt;&lt;/span&gt;
 &lt;/label&gt;
 &lt;pre class="language-c" &gt;&lt;code&gt;

#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/if.h&amp;gt;
#include &amp;lt;linux/if_tun.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

static int tunAlloc(void) {
 int fd;
 struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;, .ifr_flags = IFF_TUN | IFF_NO_PI};

 fd = open(&amp;#34;/dev/net/tun&amp;#34;, O_RDWR);
 ioctl(fd, TUNSETIFF, (void *)&amp;amp;ifr);
 ioctl(fd, TUNSETOWNER, geteuid());
 return fd;
}

// this is a test
static void bringInterfaceUp(void) {
 int sock;
 struct sockaddr_in addr = {.sin_family = AF_INET};
 struct ifreq ifr = {.ifr_name = &amp;#34;tun0&amp;#34;};

 inet_aton(&amp;#34;172.30.0.1&amp;#34;, &amp;amp;addr.sin_addr);
 memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));

 sock = socket(AF_INET, SOCK_DGRAM, 0);
 ioctl(sock, SIOCSIFADDR, &amp;amp;ifr);
 ioctl(sock, SIOCGIFFLAGS, &amp;amp;ifr);
 ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
 ioctl(sock, SIOCSIFFLAGS, &amp;amp;ifr);
 close(sock);
}

static void emitPacket(int tap_fd) {
 unsigned char packet[] = {
 0x45, 0x00, 0x00, 0x3c, 0xd8, 0x6f, 0x40, 0x00, 0x3f, 0x06, 0x08, 0x91,
 172, 30, 0, 1, 192, 168, 255, 8, 0xa2, 0x9a, 0x27, 0x11,
 0x80, 0x0b, 0x63, 0x79, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xfa, 0xf0,
 0x89, 0xd8, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a,
 0x5b, 0x76, 0x5f, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07};

 write(tap_fd, packet, sizeof(packet));
}

int main() {
 int tap_fd;

 tap_fd = tunAlloc();
 bringInterfaceUp();
 emitPacket(tap_fd);
 close(tap_fd);

 return 0;
}



&lt;/code&gt;&lt;/pre&gt;
 &lt;/div&gt;


&lt;p&gt;A problem with the original code is that it creates the interface, sends the packet, and tears down the interface with no delays, making it very difficult to inspect the interface configuration, perform packet captures, or otherwise figure out what&amp;rsquo;s going on.&lt;/p&gt;</description></item><item><title>Tracking down a kernel bug with git bisect</title><link>https://blog.oddbit.com/post/2014-07-21-tracking-down-a-kernel-bug-wit/</link><pubDate>Mon, 21 Jul 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-07-21-tracking-down-a-kernel-bug-wit/</guid><description>&lt;p&gt;After a recent upgrade of my Fedora 20 system to kernel 3.15.mumble, I
started running into a problem (&lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=1121345"&gt;BZ 1121345&lt;/a&gt;) with my &lt;a href="https://www.docker.com/"&gt;Docker&lt;/a&gt;
containers. Operations such as &lt;code&gt;su&lt;/code&gt; or &lt;code&gt;runuser&lt;/code&gt; would fail with the
singularly unhelpful &lt;code&gt;System error&lt;/code&gt; message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -ti fedora /bin/bash
bash-4.2# su -c 'uptime'
su: System error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hooking up something (like, say, &lt;code&gt;socat unix-listen:/dev/log -&lt;/code&gt;) to
&lt;code&gt;/dev/log&lt;/code&gt; revealed that the system was logging:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Jul 19 14:31:18 su: PAM audit_log_acct_message() failed: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Downgrading the kernel to 3.14 immediately resolved the problem,
suggesting that this was at least partly a kernel issue. This seemed
like a great opportunity to play with the &lt;a href="http://git-scm.com/docs/git-bisect"&gt;git bisect&lt;/a&gt; command,
which uses a binary search to find which commit introduced a
particular problem.&lt;/p&gt;</description></item></channel></rss>