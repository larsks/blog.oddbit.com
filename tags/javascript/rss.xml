<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascript on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/javascript/</link><description>Recent content in Javascript on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 10:58:10 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/javascript/rss.xml" rel="self" type="application/rss+xml"/><item><title>A pair of userscripts for cleaning up Stack Exchange sites</title><link>https://blog.oddbit.com/post/2021-09-05-sx-question-filters/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-09-05-sx-question-filters/</guid><description>&lt;p&gt;I&amp;rsquo;ve been a regular visitor to &lt;a href="https://stackoverflow.com"&gt;Stack Overflow&lt;/a&gt; and other &lt;a href="https://stackexchange.com"&gt;Stack
Exchange&lt;/a&gt; sites over the years, and while I&amp;rsquo;ve mostly enjoyed the
experience, I&amp;rsquo;ve been frustrated by the lack of control I have over
what questions I see. I&amp;rsquo;m not really interested in looking at
questions that have already been closed, or that have a negative
score, but there&amp;rsquo;s no native facility for filtering questions like
this.&lt;/p&gt;
&lt;p&gt;I finally spent the time learning just enough JavaScript ~~~to hurt
myself~~~ to put together a pair of scripts that let me present the
questions that way I want:&lt;/p&gt;</description></item><item><title>Long polling with Javascript and Python</title><link>https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/</link><pubDate>Sat, 23 Nov 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/</guid><description>&lt;p&gt;In this post I&amp;rsquo;m going to step through an example web chat system
implemented in Python (with &lt;a href="http://bottlepy.org/docs/"&gt;Bottle&lt;/a&gt; and &lt;a href="http://www.gevent.org/"&gt;gevent&lt;/a&gt;) that uses long
polling to implement a simple publish/subscribe mechanism for
efficiently updating connected clients.&lt;/p&gt;
&lt;p&gt;My &lt;a href="http://github.com/larsks/pusub_example/"&gt;pubsub_example&lt;/a&gt; repository on &lt;a href="http://github.com/"&gt;GitHub&lt;/a&gt; has a complete
project that implements the ideas discussed in this article. This
project can be deployed directly on &lt;a href="http://openshift.com/"&gt;OpenShift&lt;/a&gt; if you want to try
things out on your own. You can also try it out online at
&lt;a href="http://pubsub.example.oddbit.com/"&gt;http://pubsub.example.oddbit.com/&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Sockets on OpenShift</title><link>https://blog.oddbit.com/post/2013-11-23-openshift-socket-pro/</link><pubDate>Sat, 23 Nov 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-11-23-openshift-socket-pro/</guid><description>&lt;p&gt;In this article, a followup to my &lt;a href="https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/"&gt;previous post&lt;/a&gt; regarding
long-poll servers and Python, we investigate the code changes that
were necessary to make the code work when deployed on OpenShift.&lt;/p&gt;
&lt;p&gt;In the previous post, we implemented IO polling to watch for client
disconnects at the same time we were waiting for messages on a message
bus:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;poll = zmq.Poller()
poll.register(subsock, zmq.POLLIN)
poll.register(rfile, zmq.POLLIN)

events = dict(poll.poll())

.
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you were to try this at home, you would find that everything worked
as described&amp;hellip;but if you were to deploy the same code to OpenShift,
you would find that the problem we were trying to solve (the server
holding file descriptors open after a client disconnected) would still
exist.&lt;/p&gt;</description></item></channel></rss>