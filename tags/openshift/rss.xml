<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Openshift on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/openshift/</link><description>Recent content in Openshift on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 15:16:45 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/openshift/rss.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes, connection timeouts, and the importance of labels</title><link>https://blog.oddbit.com/post/2022-09-10-kubernetes-labels/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2022-09-10-kubernetes-labels/</guid><description>&lt;p&gt;We are working with an application that produces resource utilization reports for clients of our OpenShift-based cloud environments. The developers working with the application have been reporting mysterious issues concerning connection timeouts between the application and the database (a MariaDB instance). For a long time we had only high-level verbal descriptions of the problem (&amp;ldquo;I&amp;rsquo;m seeing a lot of connection timeouts!&amp;rdquo;) and a variety of unsubstantiated theories (from multiple sources) about the cause. Absent a solid reproducer of the behavior in question, we looked at other aspects of our infrastructure:&lt;/p&gt;</description></item><item><title>Kubernetes External Secrets</title><link>https://blog.oddbit.com/post/2021-09-03-kubernetes-external-secrets/</link><pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-09-03-kubernetes-external-secrets/</guid><description>&lt;p&gt;At &lt;em&gt;$JOB&lt;/em&gt; we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using &lt;a href="https://argo-cd.readthedocs.io/en/stable/"&gt;ArgoCD&lt;/a&gt; and &lt;a href="https://kustomize.io/"&gt;Kustomize&lt;/a&gt;. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials.&lt;/p&gt;</description></item><item><title>Connecting OpenShift to an External Ceph Cluster</title><link>https://blog.oddbit.com/post/2021-08-23-external-ocs/</link><pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-08-23-external-ocs/</guid><description>&lt;p&gt;Red Hat&amp;rsquo;s &lt;a href="https://www.redhat.com/en/technologies/cloud-computing/openshift-data-foundation"&gt;OpenShift Data Foundation&lt;/a&gt; (formerly &amp;ldquo;OpenShift
Container Storage&amp;rdquo;, or &amp;ldquo;OCS&amp;rdquo;) allows you to either (a) automatically
set up a Ceph cluster as an application running on your OpenShift
cluster, or (b) connect your OpenShift cluster to an externally
managed Ceph cluster. While setting up Ceph as an OpenShift
application is a relatively polished experienced, connecting to an
external cluster still has some rough edges.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NB&lt;/strong&gt; I am not a Ceph expert. If you read this and think I&amp;rsquo;ve made a
mistake with respect to permissions or anything else, please feel free
to leave a comment and I will update the article as necessary. In
particular, I think it may be possible to further restrict the &lt;code&gt;mgr&lt;/code&gt;
permissions shown in this article and I&amp;rsquo;m interested in feedback on
that topic.&lt;/p&gt;</description></item><item><title>Getting started with KSOPS</title><link>https://blog.oddbit.com/post/2021-03-09-getting-started-with-ksops/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-03-09-getting-started-with-ksops/</guid><description>&lt;p&gt;&lt;a href="https://kustomize.io/"&gt;Kustomize&lt;/a&gt; is a tool for assembling Kubernetes manifests from a
collection of files. We&amp;rsquo;re making extensive use of Kustomize in the
&lt;a href="https://www.operate-first.cloud/"&gt;operate-first&lt;/a&gt; project. In order to keep secrets stored in our
configuration repositories, we&amp;rsquo;re using the &lt;a href="https://github.com/viaduct-ai/kustomize-sops"&gt;KSOPS&lt;/a&gt; plugin, which
enables Kustomize to use &lt;a href="https://github.com/mozilla/sops"&gt;sops&lt;/a&gt; to encrypt/files using GPG.&lt;/p&gt;
&lt;p&gt;In this post, I&amp;rsquo;d like to walk through the steps necessary to get
everything up and running.&lt;/p&gt;
&lt;h2 id="set-up-gpg"&gt;Set up GPG&lt;/h2&gt;
&lt;p&gt;We encrypt files using GPG, so the first step is making sure that you
have a GPG keypair and that your public key is published where other
people can find it.&lt;/p&gt;</description></item><item><title>Object storage with OpenShift Container Storage</title><link>https://blog.oddbit.com/post/2021-02-10-object-storage-with-openshift/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2021-02-10-object-storage-with-openshift/</guid><description>&lt;p&gt;&lt;a href="https://www.redhat.com/en/technologies/cloud-computing/openshift-container-storage"&gt;OpenShift Container Storage&lt;/a&gt; (OCS) from Red Hat deploys Ceph in your
OpenShift cluster (or allows you to integrate with an external Ceph
cluster). In addition to the file- and block- based volume services
provided by Ceph, OCS includes two S3-api compatible object storage
implementations.&lt;/p&gt;
&lt;p&gt;The first option is the &lt;a href="https://docs.ceph.com/en/latest/radosgw/"&gt;Ceph Object Gateway&lt;/a&gt; (radosgw),
Ceph&amp;rsquo;s native object storage interface. The second option called the
&amp;ldquo;&lt;a href="https://www.openshift.com/blog/introducing-multi-cloud-object-gateway-for-openshift"&gt;Multicloud Object Gateway&lt;/a&gt;&amp;rdquo;, which is in fact a piece of software
named &lt;a href="https://www.noobaa.io/"&gt;Noobaa&lt;/a&gt;, a storage abstraction layer that was &lt;a href="https://www.redhat.com/en/blog/faq-red-hat-acquires-noobaa"&gt;acquired by
Red Hat&lt;/a&gt; in 2018. In this article I&amp;rsquo;d like to demonstrate how to
take advantage of these storage options.&lt;/p&gt;</description></item><item><title>Installing metallb on OpenShift with Kustomize</title><link>https://blog.oddbit.com/post/2020-09-27-installing-metallb-on-openshif/</link><pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-09-27-installing-metallb-on-openshif/</guid><description>&lt;p&gt;Out of the box, OpenShift (4.x) on bare metal doesn&amp;rsquo;t come with any
integrated load balancer support (when installed in a cloud environment,
OpenShift typically makes use of the load balancing features available from
the cloud provider). Fortunately, there are third party solutions available
that are designed to work in bare metal environments. &lt;a href="https://metallb.universe.tf/"&gt;MetalLB&lt;/a&gt; is a
popular choice, but requires some minor fiddling to get it to run properly
on OpenShift.&lt;/p&gt;</description></item><item><title>OpenShift and CNV: MAC address management in CNV 2.4</title><link>https://blog.oddbit.com/post/2020-08-10-mac-address-management-in-cnv/</link><pubDate>Mon, 10 Aug 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-08-10-mac-address-management-in-cnv/</guid><description>&lt;p&gt;This is part of a &lt;a href="https://blog.oddbit.com/tag/openshift-and-cnv"&gt;series of posts&lt;/a&gt; about my experience working with
&lt;a href="https://www.openshift.com/"&gt;OpenShift&lt;/a&gt; and &lt;a href="https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization"&gt;CNV&lt;/a&gt;. In this post, I&amp;rsquo;ll look at how the
recently released CNV 2.4 resolves some issues in managing virtual
machines that are attached directly to local layer 2 networks&lt;/p&gt;
&lt;p&gt;In &lt;a href="https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/"&gt;an earlier post&lt;/a&gt;, I discussed some issues around the
management of virtual machine MAC addresses in CNV 2.3: in particular,
that virtual machines are assigned a random MAC address not just at
creation time but every time they boot. CNV 2.4 (re-)introduces &lt;a href="https://docs.openshift.com/container-platform/4.5/virt/virtual_machines/vm_networking/virt-using-mac-address-pool-for-vms.html"&gt;MAC
address pools&lt;/a&gt; to alleviate these issues. The high level description
reads:&lt;/p&gt;</description></item><item><title>OpenShift and CNV: Exposing virtualized services</title><link>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/</link><pubDate>Thu, 30 Jul 2020 01:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/</guid><description>&lt;p&gt;This is the second in a &lt;a href="https://blog.oddbit.com/tag/openshift-and-cnv"&gt;series of posts&lt;/a&gt; about my experience working
with &lt;a href="https://www.openshift.com/"&gt;OpenShift&lt;/a&gt; and &lt;a href="https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization"&gt;CNV&lt;/a&gt;. In this post, I&amp;rsquo;ll be taking a look
at how to expose services on a virtual machine once you&amp;rsquo;ve git it up
and running.&lt;/p&gt;
&lt;nav id="TableOfContents"&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href="#tldr"&gt;TL;DR&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#overview"&gt;Overview&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#connectivity-options"&gt;Connectivity options&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#direct-attachment"&gt;Direct attachment&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#using-an-openshift-service"&gt;Using an OpenShift Service&lt;/a&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href="#exposing-services-on-nodeports"&gt;Exposing services on NodePorts&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#exposing-services-on-cluster-external-ipso"&gt;Exposing services on cluster external IPso&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#exposing-services-using-a-loadbalancer"&gt;Exposing services using a LoadBalancer&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/li&gt;
 &lt;/ul&gt;
&lt;/nav&gt;

&lt;h2 id="tldr"&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Networking seems to be a weak area for CNV right now. Out of the box,
your options for exposing a service on a virtual machine on a public
address at a well known port are slim.&lt;/p&gt;</description></item><item><title>OpenShift and CNV: Installer network requirements</title><link>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-1-worki/</link><pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-1-worki/</guid><description>&lt;p&gt;This is the first in a &lt;a href="https://blog.oddbit.com/tag/openshift-and-cnv"&gt;series of posts&lt;/a&gt; about my experience working
with &lt;a href="https://www.openshift.com/"&gt;OpenShift&lt;/a&gt; and &lt;a href="https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization"&gt;CNV&lt;/a&gt; (&amp;ldquo;Container Native Virtualization&amp;rdquo;, a
technology that allows you to use OpenShift to manage virtualized
workloads in addition to the containerized workloads for which
OpenShift is known). In this post, I&amp;rsquo;ll be taking a look at the
installation experience, and in particular at how restrictions in our
local environment interacted with the network requirements of the installer.&lt;/p&gt;</description></item><item><title>Sockets on OpenShift</title><link>https://blog.oddbit.com/post/2013-11-23-openshift-socket-pro/</link><pubDate>Sat, 23 Nov 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-11-23-openshift-socket-pro/</guid><description>&lt;p&gt;In this article, a followup to my &lt;a href="https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/"&gt;previous post&lt;/a&gt; regarding
long-poll servers and Python, we investigate the code changes that
were necessary to make the code work when deployed on OpenShift.&lt;/p&gt;
&lt;p&gt;In the previous post, we implemented IO polling to watch for client
disconnects at the same time we were waiting for messages on a message
bus:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;poll = zmq.Poller()
poll.register(subsock, zmq.POLLIN)
poll.register(rfile, zmq.POLLIN)

events = dict(poll.poll())

.
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you were to try this at home, you would find that everything worked
as described&amp;hellip;but if you were to deploy the same code to OpenShift,
you would find that the problem we were trying to solve (the server
holding file descriptors open after a client disconnected) would still
exist.&lt;/p&gt;</description></item></channel></rss>