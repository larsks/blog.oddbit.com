<!doctype html><html lang=en><head><title>Openshift :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/tags/openshift/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Openshift"><meta property="og:description" content><meta property="og:url" content="https://blog.oddbit.com/tags/openshift/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/openshift/rss.xml rel=alternate type=application/rss+xml title=blog.oddbit.com></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><h1>Posts for: #Openshift</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2022-09-10-kubernetes-labels/>Kubernetes, connection timeouts, and the importance of labels</a></h1><div class=post-meta><time class=post-date>2022-09-10</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/cloud/>cloud</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/labels/>labels</a>&nbsp;
</span><img src=/post/2022-09-10-kubernetes-labels/cover.png class=post-cover alt="Kubernetes, connection timeouts, and the importance of labels" title="Cover Image"><div class=post-content><p>We are working with an application that produces resource utilization reports for clients of our OpenShift-based cloud environments. The developers working with the application have been reporting mysterious issues concerning connection timeouts between the application and the database (a MariaDB instance). For a long time we had only high-level verbal descriptions of the problem (&ldquo;I&rsquo;m seeing a lot of connection timeouts!&rdquo;) and a variety of unsubstantiated theories (from multiple sources) about the cause. Absent a solid reproducer of the behavior in question, we looked at other aspects of our infrastructure:</p></div><div><a class="read-more button inline" href=/post/2022-09-10-kubernetes-labels/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-09-03-kubernetes-external-secrets/>Kubernetes External Secrets</a></h1><div class=post-meta><time class=post-date>2021-09-03</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/secrets/>secrets</a>&nbsp;
</span><img src=/post/2021-09-03-kubernetes-external-secrets/cover.jpg class=post-cover alt="Kubernetes External Secrets" title="Cover Image"><div class=post-content><p>At <em>$JOB</em> we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using <a href=https://argo-cd.readthedocs.io/en/stable/>ArgoCD</a> and <a href=https://kustomize.io/>Kustomize</a>. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials.</p></div><div><a class="read-more button inline" href=/post/2021-09-03-kubernetes-external-secrets/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-08-23-external-ocs/>Connecting OpenShift to an External Ceph Cluster</a></h1><div class=post-meta><time class=post-date>2021-08-23</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/ceph/>ceph</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ocs/>ocs</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/odf/>odf</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/storage/>storage</a>&nbsp;</span><div class=post-content><p>Red Hat&rsquo;s <a href=https://www.redhat.com/en/technologies/cloud-computing/openshift-data-foundation>OpenShift Data Foundation</a> (formerly &ldquo;OpenShift
Container Storage&rdquo;, or &ldquo;OCS&rdquo;) allows you to either (a) automatically
set up a Ceph cluster as an application running on your OpenShift
cluster, or (b) connect your OpenShift cluster to an externally
managed Ceph cluster. While setting up Ceph as an OpenShift
application is a relatively polished experienced, connecting to an
external cluster still has some rough edges.</p><p><strong>NB</strong> I am not a Ceph expert. If you read this and think I&rsquo;ve made a
mistake with respect to permissions or anything else, please feel free
to leave a comment and I will update the article as necessary. In
particular, I think it may be possible to further restrict the <code>mgr</code>
permissions shown in this article and I&rsquo;m interested in feedback on
that topic.</p></div><div><a class="read-more button inline" href=/post/2021-08-23-external-ocs/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-03-09-getting-started-with-ksops/>Getting started with KSOPS</a></h1><div class=post-meta><time class=post-date>2021-03-09</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ksops/>ksops</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/gpg/>gpg</a>&nbsp;</span><div class=post-content><p><a href=https://kustomize.io/>Kustomize</a> is a tool for assembling Kubernetes manifests from a
collection of files. We&rsquo;re making extensive use of Kustomize in the
<a href=https://www.operate-first.cloud/>operate-first</a> project. In order to keep secrets stored in our
configuration repositories, we&rsquo;re using the <a href=https://github.com/viaduct-ai/kustomize-sops>KSOPS</a> plugin, which
enables Kustomize to use <a href=https://github.com/mozilla/sops>sops</a> to encrypt/files using GPG.</p><p>In this post, I&rsquo;d like to walk through the steps necessary to get
everything up and running.</p><h2 id=set-up-gpg>Set up GPG</h2><p>We encrypt files using GPG, so the first step is making sure that you
have a GPG keypair and that your public key is published where other
people can find it.</p></div><div><a class="read-more button inline" href=/post/2021-03-09-getting-started-with-ksops/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-02-10-object-storage-with-openshift/>Object storage with OpenShift Container Storage</a></h1><div class=post-meta><time class=post-date>2021-02-10</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift-ocs/>openshift-ocs</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/s3/>s3</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
</span><img src=/post/2021-02-10-object-storage-with-openshift/cover.jpg class=post-cover alt="Object storage with OpenShift Container Storage" title="Cover Image"><div class=post-content><p><a href=https://www.redhat.com/en/technologies/cloud-computing/openshift-container-storage>OpenShift Container Storage</a> (OCS) from Red Hat deploys Ceph in your
OpenShift cluster (or allows you to integrate with an external Ceph
cluster). In addition to the file- and block- based volume services
provided by Ceph, OCS includes two S3-api compatible object storage
implementations.</p><p>The first option is the <a href=https://docs.ceph.com/en/latest/radosgw/>Ceph Object Gateway</a> (radosgw),
Ceph&rsquo;s native object storage interface. The second option called the
&ldquo;<a href=https://www.openshift.com/blog/introducing-multi-cloud-object-gateway-for-openshift>Multicloud Object Gateway</a>&rdquo;, which is in fact a piece of software
named <a href=https://www.noobaa.io/>Noobaa</a>, a storage abstraction layer that was <a href=https://www.redhat.com/en/blog/faq-red-hat-acquires-noobaa>acquired by
Red Hat</a> in 2018. In this article I&rsquo;d like to demonstrate how to
take advantage of these storage options.</p></div><div><a class="read-more button inline" href=/post/2021-02-10-object-storage-with-openshift/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2020-09-27-installing-metallb-on-openshif/>Installing metallb on OpenShift with Kustomize</a></h1><div class=post-meta><time class=post-date>2020-09-27</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kustomize/>kustomize</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/metallb/>metallb</a>&nbsp;</span><div class=post-content><p>Out of the box, OpenShift (4.x) on bare metal doesn&rsquo;t come with any
integrated load balancer support (when installed in a cloud environment,
OpenShift typically makes use of the load balancing features available from
the cloud provider). Fortunately, there are third party solutions available
that are designed to work in bare metal environments. <a href=https://metallb.universe.tf/>MetalLB</a> is a
popular choice, but requires some minor fiddling to get it to run properly
on OpenShift.</p></div><div><a class="read-more button inline" href=/post/2020-09-27-installing-metallb-on-openshif/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2020-08-10-mac-address-management-in-cnv/>OpenShift and CNV: MAC address management in CNV 2.4</a></h1><div class=post-meta><time class=post-date>2020-08-10</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift-and-cnv/>openshift-and-cnv</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/virtualization/>virtualization</a>&nbsp;</span><div class=post-content><p>This is part of a <a href=/tag/openshift-and-cnv>series of posts</a> about my experience working with
<a href=https://www.openshift.com/>OpenShift</a> and <a href=https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization>CNV</a>. In this post, I&rsquo;ll look at how the
recently released CNV 2.4 resolves some issues in managing virtual
machines that are attached directly to local layer 2 networks</p><p>In <a href=https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/>an earlier post</a>, I discussed some issues around the
management of virtual machine MAC addresses in CNV 2.3: in particular,
that virtual machines are assigned a random MAC address not just at
creation time but every time they boot. CNV 2.4 (re-)introduces <a href=https://docs.openshift.com/container-platform/4.5/virt/virtual_machines/vm_networking/virt-using-mac-address-pool-for-vms.html>MAC
address pools</a> to alleviate these issues. The high level description
reads:</p></div><div><a class="read-more button inline" href=/post/2020-08-10-mac-address-management-in-cnv/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-2-expos/>OpenShift and CNV: Exposing virtualized services</a></h1><div class=post-meta><time class=post-date>2020-07-30</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/cnv/>cnv</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift-and-cnv/>openshift-and-cnv</a>&nbsp;</span><div class=post-content><p>This is the second in a <a href=/tag/openshift-and-cnv>series of posts</a> about my experience working
with <a href=https://www.openshift.com/>OpenShift</a> and <a href=https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization>CNV</a>. In this post, I&rsquo;ll be taking a look
at how to expose services on a virtual machine once you&rsquo;ve git it up
and running.</p><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#overview>Overview</a></li><li><a href=#connectivity-options>Connectivity options</a></li><li><a href=#direct-attachment>Direct attachment</a></li><li><a href=#using-an-openshift-service>Using an OpenShift Service</a><ul><li><a href=#exposing-services-on-nodeports>Exposing services on NodePorts</a></li><li><a href=#exposing-services-on-cluster-external-ipso>Exposing services on cluster external IPso</a></li><li><a href=#exposing-services-using-a-loadbalancer>Exposing services using a LoadBalancer</a></li></ul></li></ul></nav><h2 id=tldr>TL;DR</h2><p>Networking seems to be a weak area for CNV right now. Out of the box,
your options for exposing a service on a virtual machine on a public
address at a well known port are slim.</p></div><div><a class="read-more button inline" href=/post/2020-07-30-openshift-and-cnv-part-2-expos/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2020-07-30-openshift-and-cnv-part-1-worki/>OpenShift and CNV: Installer network requirements</a></h1><div class=post-meta><time class=post-date>2020-07-30</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/cnv/>cnv</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift-and-cnv/>openshift-and-cnv</a>&nbsp;</span><div class=post-content><p>This is the first in a <a href=/tag/openshift-and-cnv>series of posts</a> about my experience working
with <a href=https://www.openshift.com/>OpenShift</a> and <a href=https://www.redhat.com/en/topics/containers/what-is-container-native-virtualization>CNV</a> (&ldquo;Container Native Virtualization&rdquo;, a
technology that allows you to use OpenShift to manage virtualized
workloads in addition to the containerized workloads for which
OpenShift is known). In this post, I&rsquo;ll be taking a look at the
installation experience, and in particular at how restrictions in our
local environment interacted with the network requirements of the installer.</p></div><div><a class="read-more button inline" href=/post/2020-07-30-openshift-and-cnv-part-1-worki/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2013-11-23-openshift-socket-pro/>Sockets on OpenShift</a></h1><div class=post-meta><time class=post-date>2013-11-23</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/javascript/>javascript</a>&nbsp;</span><div class=post-content><p>In this article, a followup to my <a href=https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/>previous post</a> regarding
long-poll servers and Python, we investigate the code changes that
were necessary to make the code work when deployed on OpenShift.</p><p>In the previous post, we implemented IO polling to watch for client
disconnects at the same time we were waiting for messages on a message
bus:</p><pre><code>poll = zmq.Poller()
poll.register(subsock, zmq.POLLIN)
poll.register(rfile, zmq.POLLIN)

events = dict(poll.poll())

.
.
.
</code></pre><p>If you were to try this at home, you would find that everything worked
as described&mldr;but if you were to deploy the same code to OpenShift,
you would find that the problem we were trying to solve (the server
holding file descriptors open after a client disconnected) would still
exist.</p></div><div><a class="read-more button inline" href=/post/2013-11-23-openshift-socket-pro/>[read more]</a></div></article><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>