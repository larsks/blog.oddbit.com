<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kustomize on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/kustomize/</link><description>Recent content in Kustomize on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Sun, 27 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/kustomize/rss.xml" rel="self" type="application/rss+xml"/><item><title>Installing metallb on OpenShift with Kustomize</title><link>https://blog.oddbit.com/post/2020-09-27-installing-metallb-on-openshif/</link><pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-09-27-installing-metallb-on-openshif/</guid><description>&lt;p>Out of the box, OpenShift (4.x) on bare metal doesn&amp;rsquo;t come with any
integrated load balancer support (when installed in a cloud environment,
OpenShift typically makes use of the load balancing features available from
the cloud provider). Fortunately, there are third party solutions available
that are designed to work in bare metal environments. &lt;a href="https://metallb.universe.tf/">MetalLB&lt;/a> is a
popular choice, but requires some minor fiddling to get it to run properly
on OpenShift.&lt;/p></description><content>&lt;p>Out of the box, OpenShift (4.x) on bare metal doesn&amp;rsquo;t come with any
integrated load balancer support (when installed in a cloud environment,
OpenShift typically makes use of the load balancing features available from
the cloud provider). Fortunately, there are third party solutions available
that are designed to work in bare metal environments. &lt;a href="https://metallb.universe.tf/">MetalLB&lt;/a> is a
popular choice, but requires some minor fiddling to get it to run properly
on OpenShift.&lt;/p>
&lt;p>If you read through the &lt;a href="https://metallb.universe.tf/installation/">installation instructions&lt;/a>, you will see &lt;a href="https://metallb.universe.tf/installation/clouds/#metallb-on-openshift-ocp">this
note&lt;/a> about installation on OpenShift:&lt;/p>
&lt;blockquote>
&lt;p>To run MetalLB on Openshift, two changes are required: changing the pod
UIDs, and granting MetalLB additional networking privileges.&lt;/p>
&lt;p>Pods get UIDs automatically assigned based on an OpenShift-managed UID
range, so you have to remove the hardcoded unprivileged UID from the
MetalLB manifests. You can do this by removing the
spec.template.spec.securityContext.runAsUser field from both the
controller Deployment and the speaker DaemonSet.&lt;/p>
&lt;p>Additionally, you have to grant the speaker DaemonSet elevated
privileges, so that it can do the raw networking required to make
LoadBalancers work. You can do this with:&lt;/p>
&lt;/blockquote>
&lt;p>The docs here suggest some manual changes you can make, but it&amp;rsquo;s possible
to get everything installed correctly using &lt;a href="https://github.com/kubernetes-sigs/kustomize">Kustomize&lt;/a> (which makes
sense especially given that the MetalLB docs already include instructions
&lt;a href="https://metallb.universe.tf/installation/#installation-with-kustomize">on using Kustomize&lt;/a>).&lt;/p>
&lt;p>A vanilla installation of MetalLB with Kustomize uses a &lt;code>kustomization.yml&lt;/code>
file that looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>namespace: metallb-system
resources:
- github.com/metallb/metallb//manifests?ref=v0.9.3
- configmap.yml
- secret.yml
&lt;/code>&lt;/pre>&lt;p>(Where &lt;code>configmap.yml&lt;/code> and &lt;code>secret.yml&lt;/code> are files you create locally
containing, respectively, the MetalLB configuration and a secret used to
authenticate cluster members.)&lt;/p>
&lt;h2 id="fixing-the-security-context">Fixing the security context&lt;/h2>
&lt;p>In order to remove the &lt;code>runAsUser&lt;/code> directive form the template
&lt;code>securityContext&lt;/code> setting, we can use the &lt;a href="https://kubectl.docs.kubernetes.io/pages/reference/kustomize.html#patchesstrategicmerge">patchesStrategicMerge&lt;/a>
feature. In our &lt;code>kustomization.yml&lt;/code> file we add:&lt;/p>
&lt;pre tabindex="0">&lt;code>patches:
- |-
apiVersion: apps/v1
kind: Deployment
metadata:
name: controller
namespace: metallb-system
spec:
template:
spec:
securityContext:
$patch: replace
runAsNonRoot: true
&lt;/code>&lt;/pre>&lt;p>This instructs &lt;code>kustomize&lt;/code> to replace the contents of the &lt;code>securityContext&lt;/code>
key with the value included in the patch (without the &lt;code>$patch: replace&lt;/code>
directive, the default behavior is to merge the contents, which in this
situation would effectively be a no-op).&lt;/p>
&lt;p>We can accomplish the same thing using &lt;a href="https://tools.ietf.org/html/rfc6902">jsonpatch&lt;/a> syntax. In this case,
we would write:&lt;/p>
&lt;pre tabindex="0">&lt;code>patches:
- target:
kind: Deployment
name: controller
namespace: metallb-system
patch: |-
- op: remove
path: /spec/template/spec/securityContext/runAsUser
&lt;/code>&lt;/pre>&lt;p>With either solution, the final output includes a &lt;code>securityContext&lt;/code> setting
that looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>spec:
template:
spec:
securityContext:
runAsNonRoot: true
&lt;/code>&lt;/pre>&lt;h2 id="granting-elevated-privileges">Granting elevated privileges&lt;/h2>
&lt;p>The MetaLB docs suggest running:&lt;/p>
&lt;pre tabindex="0">&lt;code>oc adm policy add-scc-to-user privileged -n metallb-system -z speaker
&lt;/code>&lt;/pre>&lt;p>But we can configure the same privilege level by setting up an appropriate
role binding as part of our Kustomize manifests.&lt;/p>
&lt;p>First, we create an &lt;code>allow-privileged&lt;/code> cluster role by adding the following
manifest in &lt;code>clusterrole.yml&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: allow-privileged
rules:
- apiGroups:
- security.openshift.io
resourceNames:
- privileged
resources:
- securitycontextconstraints
verbs:
- use
&lt;/code>&lt;/pre>&lt;p>Then we bind the &lt;code>speaker&lt;/code> service account to the &lt;code>allow-privileged&lt;/code> role
by adding a &lt;code>ClusterRoleBinding&lt;/code> in &lt;code>rolebinding.yml&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
name: metallb-allow-privileged
roleRef:
apiGroup: rbac.authorization.k8s.io
kind: ClusterRole
name: allow-privileged
subjects:
- kind: ServiceAccount
name: speaker
namespace: metallb-system
&lt;/code>&lt;/pre>&lt;p>You will need to add these new manifests to your &lt;code>kustomization.yml&lt;/code>, which
should now look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>namespace: metallb-system
resources:
- github.com/metallb/metallb//manifests?ref=v0.9.3
- configmap.yml
- secret.yml
- clusterole.yml
- rolebinding.yml
patches:
- target:
kind: Deployment
name: controller
namespace: metallb-system
patch: |-
- op: remove
path: /spec/template/spec/securityContext/runAsUser
&lt;/code>&lt;/pre>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>The changes described here will result in a successful MetalLB deployment
into your OpenShift environment.&lt;/p></content></item></channel></rss>