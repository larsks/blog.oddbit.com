<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Raspberrypi on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/raspberrypi/</link><description>Recent content in Raspberrypi on blog.oddbit.com</description><generator>Hugo</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 16 Feb 2023 10:58:10 -0500</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/raspberrypi/rss.xml" rel="self" type="application/rss+xml"/><item><title>PiPower: A Raspberry Pi UPS</title><link>https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/</guid><description>&lt;figure&gt;&lt;a href="pipower-top.jpg"&gt;&lt;img src="https://blog.oddbit.com/post/2019-01-19-pipower-a-raspberry-pi-ups/pipower-top.jpg" width="400"&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;I have a Raspberry Pi running &lt;a href="https://retropie.org.uk/"&gt;RetroPie&lt;/a&gt; hooked up to a television. It&amp;rsquo;s powered from a USB port on the TV, which is convenient, but it means that whenever we shut off the TV we&amp;rsquo;re pulling the plug on the Pi. While there haven&amp;rsquo;t been any problems so far, this is a classic recipe for filesystem problems or data loss at some point. I started looking into UPS options to alleviate this issue. I wanted something with the following features:&lt;/p&gt;</description></item><item><title>Systemd unit for managing USB gadgets</title><link>https://blog.oddbit.com/post/2018-10-19-systemd-unit-for-managing-usb-/</link><pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-10-19-systemd-unit-for-managing-usb-/</guid><description>&lt;p&gt;The Pi Zero (and Zero W) have support for acting as a USB &lt;a href="http://www.linux-usb.org/gadget/"&gt;gadget&lt;/a&gt;:
that means that they can be configured to act as a USB device &amp;ndash; like
a serial port, an ethernet interface, a mass storage device, etc.&lt;/p&gt;
&lt;p&gt;There are two different ways of configuring this support. The first
only allows you to configure a single type of gadget at a time, and
boils down to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Enable the dwc2 overlay in &lt;code&gt;/boot/config.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reboot.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modprobe g_serial&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This process is more fully documented &lt;a href="https://learn.adafruit.com/turning-your-raspberry-pi-zero-into-a-usb-gadget/overview"&gt;here&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Configuring a static address for wlan0 on Raspbian Stretch</title><link>https://blog.oddbit.com/post/2018-06-14-configuring-a-static-address-f/</link><pubDate>Thu, 14 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-06-14-configuring-a-static-address-f/</guid><description>&lt;p&gt;Recent releases of Raspbian have adopted the use of &lt;a href="http://manpages.ubuntu.com/manpages/trusty/man8/dhcpcd5.8.html"&gt;dhcpcd&lt;/a&gt; to
manage both dynamic and static interface configuration. If you would
prefer to use the traditional &lt;code&gt;/etc/network/interfaces&lt;/code&gt; mechanism
instead, follow these steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, disable &lt;code&gt;dhcpcd&lt;/code&gt; and &lt;code&gt;wpa_supplicant&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; systemctl disable --now dhdpcd wpa_supplicant
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You will need a &lt;code&gt;wpa_supplicant&lt;/code&gt; configuration for &lt;code&gt;wlan0&lt;/code&gt; in
&lt;code&gt;/etc/wpa_supplicant/wpa_supplicant-wlan0.conf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you already have an appropriate configuration in
&lt;code&gt;/etc/wpa_supplicant/wpa_supplicant.conf&lt;/code&gt;, you can just symlink the
file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; cd /etc/wpa_supplicant
 ln -s wpa_supplicant.conf wpa_supplicant-wlan0.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Enable the &lt;code&gt;wpa_supplicant&lt;/code&gt; service for &lt;code&gt;wlan0&lt;/code&gt;:&lt;/p&gt;</description></item><item><title>Multiple 1-Wire Buses on the Raspberry Pi</title><link>https://blog.oddbit.com/post/2018-03-27-multiple-1-wire-buses-on-the-/</link><pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-03-27-multiple-1-wire-buses-on-the-/</guid><description>&lt;p&gt;The DS18B20 is a popular temperature sensor that uses the &lt;a href="https://en.wikipedia.org/wiki/1-Wire"&gt;1-Wire&lt;/a&gt;
protocol for communication. Recent versions of the Linux kernel
include a kernel driver for this protocol, making it relatively
convenient to connect one or more of these devices to a Raspberry Pi
or similar device. 1-Wire devices can be daisy chained, so it is
possible to connect several devices to your Pi using only a single
GPIO pin, and you&amp;rsquo;ll find many articles out there that describe how to
do so.&lt;/p&gt;</description></item><item><title>Some notes on PWM on the Raspberry Pi</title><link>https://blog.oddbit.com/post/2017-09-26-some-notes-on-pwm-on-the-raspb/</link><pubDate>Tue, 26 Sep 2017 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2017-09-26-some-notes-on-pwm-on-the-raspb/</guid><description>&lt;p&gt;I was recently working on a project in which I wanted to drive a
simple &lt;a href="https://www.adafruit.com/product/160"&gt;piezo buzzer&lt;/a&gt; attached to a GPIO pin on a Raspberry Pi. I
was already using the &lt;a href="https://pypi.python.org/pypi/RPi.GPIO"&gt;RPi.GPIO&lt;/a&gt; module in my project so that seemed
like a logical place to start, but I ran into a few issues.&lt;/p&gt;
&lt;p&gt;You drive a piezo buzzer by generating a &lt;a href="https://learn.sparkfun.com/tutorials/pulse-width-modulation"&gt;PWM&lt;/a&gt; signal with the
appropriate frequency. The &lt;code&gt;RPi.GPIO&lt;/code&gt; module implements PWM via
software, which is tricky on a non-realtime system. It&amp;rsquo;s difficult to
get the timing completely accurate, which results in sounds that are a
little wobbly at best. Since I&amp;rsquo;m simply generating tones with a
buzzer (rather than, say, controlling a servo) this is mostly just an
annoyance.&lt;/p&gt;</description></item><item><title>Systemd-nspawn for fun and...well, mostly for fun</title><link>https://blog.oddbit.com/post/2016-02-07-systemd-nspawn-for-fun-and-wel/</link><pubDate>Sun, 07 Feb 2016 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2016-02-07-systemd-nspawn-for-fun-and-wel/</guid><description>&lt;p&gt;&lt;code&gt;systemd-nspawn&lt;/code&gt; has been called &lt;a href="https://wiki.archlinux.org/index.php/Systemd-nspawn"&gt;&amp;ldquo;chroot on steroids&amp;rdquo;&lt;/a&gt;,
but if you think of it as &lt;a href="http://docker.com"&gt;Docker&lt;/a&gt; with a slightly different target
you wouldn&amp;rsquo;t be far wrong, either. It can be used to spawn containers
on your host, and has a variety of options for configuring the
containerized environment through the use of private networking, bind
mounts, capability controls, and a variety of other facilities that
give you flexible container management.&lt;/p&gt;
&lt;p&gt;There are many different ways in which it can be used. I&amp;rsquo;m going to
focus on one that&amp;rsquo;s a bit of a corner use case that I find
particularly interesting. In this article we&amp;rsquo;re going to explore how
we can use &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html"&gt;systemd-nspawn&lt;/a&gt; to spawn lightweight containers for
architectures other than that of our host system.&lt;/p&gt;</description></item><item><title>gpio-watch: Run scripts in response to GPIO signals</title><link>https://blog.oddbit.com/post/2014-07-26-gpiowatch-run-scripts-in-respo/</link><pubDate>Sat, 26 Jul 2014 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2014-07-26-gpiowatch-run-scripts-in-respo/</guid><description>&lt;p&gt;For a small project I&amp;rsquo;m working on I needed to attach a few buttons to
a &lt;a href="http://raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; and have some code execute in response to the
button presses.&lt;/p&gt;
&lt;p&gt;Normally I would reach for &lt;a href="http://python.org/"&gt;Python&lt;/a&gt; for a simple project like this,
but constraints of the project made it necessary to implement
something in C with minimal dependencies. I didn&amp;rsquo;t want to write
something that was tied closely to my project&amp;hellip;&lt;/p&gt;
&lt;figure&gt;&lt;a href="https://xkcd.com/974/"&gt;&lt;img src="http://imgs.xkcd.com/comics/the_general_problem.png"&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;&amp;hellip;so I ended up writing &lt;a href="https://github.com/larsks/gpio-watch"&gt;gpio-watch&lt;/a&gt;, a simple tool for connecting
shell scripts (or any other executable) to GPIO events. There are a
few ways to interact with GPIO on the Raspberry Pi. For the fastest
possible performance, you will need to interact directly with the
underlying hardware using, e.g., something like &lt;a href="http://hertaville.com/2014/07/07/rpimmapgpio/"&gt;direct register
access&lt;/a&gt;. Since I was only responding to button presses I opted
to take advantage of the &lt;a href="https://www.kernel.org/doc/Documentation/gpio/sysfs.txt"&gt;GPIO sysfs interface&lt;/a&gt;, which exposes
the GPIO pins via the filesystem.&lt;/p&gt;</description></item><item><title>Interrupts on the PiFace</title><link>https://blog.oddbit.com/post/2013-08-05-interrupts-on-the-pi/</link><pubDate>Mon, 05 Aug 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-08-05-interrupts-on-the-pi/</guid><description>&lt;p&gt;I recently acquired both a &lt;a href="http://www.raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; and a &lt;a href="http://www.element14.com/community/docs/DOC-52857/l/piface-digital-for-raspberry-pi"&gt;PiFace&lt;/a&gt; IO board.
I had a rough time finding examples of how to read the input ports via
interrupts (rather than periodically polling for values), especially
for the &lt;a href="https://github.com/piface"&gt;newer versions&lt;/a&gt; of the PiFace python libraries.&lt;/p&gt;
&lt;p&gt;After a little research, &lt;a href="https://gist.github.com/larsks/6161684"&gt;here&amp;rsquo;s&lt;/a&gt; some simple code that
will print out pin names as you press the input buttons. Button 3
will cause the code to exit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

import pifacecommon.core
import pifacecommon.interrupts
import os
import time

quit = False

def print_flag(event):
 print 'You pressed button', event.pin_num, '.'

def stop_listening(event):
 global quit
 quit = True

pifacecommon.core.init()

# GPIOB is the input ports, including the four buttons.
port = pifacecommon.core.GPIOB

listener = pifacecommon.interrupts.PortEventListener(port)

# set up listeners for all buttons
listener.register(0, pifacecommon.interrupts.IODIR_ON, print_flag)
listener.register(1, pifacecommon.interrupts.IODIR_ON, print_flag)
listener.register(2, pifacecommon.interrupts.IODIR_ON, print_flag)
listener.register(3, pifacecommon.interrupts.IODIR_ON, stop_listening)

# Start listening for events. This spawns a new thread.
listener.activate()

# Hang around until someone presses button 3.
while not quit:
 time.sleep(1)

print 'you pressed button 3 (quitting)'
listener.deactivate()
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>I2C on the Raspberry Pi</title><link>https://blog.oddbit.com/post/2013-03-12-i2c-on-the-raspberry/</link><pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-12-i2c-on-the-raspberry/</guid><description>&lt;p&gt;I&amp;rsquo;ve set up my &lt;a href="http://www.raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; to communicate with my &lt;a href="http://www.arduino.cc/"&gt;Arduino&lt;/a&gt; via
&lt;a href="http://en.wikipedia.org/wiki/I%C2%B2C"&gt;I2C&lt;/a&gt;. The Raspberry Pi is a 3.3v device and the Arduino is a 5v
device. While in general this means that you need to use a level
converter when connecting the two devices, &lt;strong&gt;you don&amp;rsquo;t need to use a
level converter when connecting the Arduino to the Raspberry Pi via
I2C.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The design of the I2C bus is such that the only device driving a
voltage on the bus is the master (in this case, the Raspberry Pi), via
pull-up resistors. So when &amp;ldquo;idle&amp;rdquo;, the bus is pulled to 3.3v volts by
the Pi, which is perfectly safe for the Arduino (and compatible with
it&amp;rsquo;s 5v signaling). To transmit data on the bus, a device brings the
bus low by connecting it to ground. In other words, slave devices
&lt;em&gt;never&lt;/em&gt; drive the bus high. This means that the Raspberry Pi will
never see a 5v signal from the Arduino&amp;hellip;unless, of course, you make a
mistake and accidentally &lt;code&gt;digitalWrite&lt;/code&gt; a &lt;code&gt;HIGH&lt;/code&gt; value on one of the
Arduino&amp;rsquo;s &lt;code&gt;I2C&lt;/code&gt; pins. So don&amp;rsquo;t do that.&lt;/p&gt;</description></item><item><title>Interrupt driven GPIO with Python</title><link>https://blog.oddbit.com/post/2013-03-08-interrupt-driven-gpi/</link><pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-08-interrupt-driven-gpi/</guid><description>&lt;p&gt;There are several Python libraries out there for interacting with the
&lt;a href="https://en.wikipedia.org/wiki/General_Purpose_Input/Output"&gt;GPIO&lt;/a&gt; pins on a Raspberry Pi:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/RPi.GPIO"&gt;RPi.GPIO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/WiringPi/WiringPi-Python"&gt;WiringPi&lt;/a&gt; bindings for Python, and&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/quick2wire/quick2wire-python-api"&gt;Quick2Wire&lt;/a&gt; Python API (which depends on Python 3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of them are reasonably easy to use, but the Quick2Wire API
provides a uniquely useful feature: &lt;code&gt;epoll&lt;/code&gt;-enabled GPIO interrupts.
This makes it trivial to write code that efficiently waits for and
responds to things like button presses.&lt;/p&gt;
&lt;p&gt;The following simple example waits for a button press attached to
&lt;code&gt;GPIO1&lt;/code&gt; (but refer to the chart in &lt;a href="https://projects.drogon.net/raspberry-pi/wiringpi/pins/"&gt;this document&lt;/a&gt; to see
exactly what that means; this is pin 12 on a Raspberry Pi v2 board)
and lights an LED attached to &lt;code&gt;GPIO0&lt;/code&gt; when the button is pressed:&lt;/p&gt;</description></item></channel></rss>