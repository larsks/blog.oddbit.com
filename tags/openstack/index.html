<!doctype html><html lang=en><head><title>Openstack :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/tags/openstack/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Openstack"><meta property="og:description" content><meta property="og:url" content="https://blog.oddbit.com/tags/openstack/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/openstack/rss.xml rel=alternate type=application/rss+xml title=blog.oddbit.com></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><h1>Posts for: #Openstack</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/>OVN and DHCP: A minimal example</a></h1><div class=post-meta><time class=post-date>2019-12-19</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ovn/>ovn</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openvswitch/>openvswitch</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;</span><div class=post-content><h1 id=introduction>Introduction</h1><p>A long time ago, I wrote an article <a href=https://blog.oddbit.com/post/2013-11-14-quantum-in-too-much-detail/>all about OpenStack Neutron</a> (which at that time was called Quantum). That served as an excellent reference for a number of years, but if you&rsquo;ve deployed a recent version of OpenStack you may have noticed that the network architecture looks completely different. The network namespaces previously used to implement routers and dhcp servers are gone (along with iptables rules and other features), and have been replaced by OVN (&ldquo;Open Virtual Network&rdquo;). What is OVN? How does it work? In this article, I&rsquo;d like to explore a minimal OVN installation to help answer these questions.</p></div><div><a class="read-more button inline" href=/post/2019-12-19-ovn-and-dhcp/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-06-07-running-keystone-with-docker-c/>Running Keystone with Docker Compose</a></h1><div class=post-meta><time class=post-date>2019-06-07</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/keystone/>keystone</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/docker-compose/>docker-compose</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/tripleo/>tripleo</a>&nbsp;</span><div class=post-content><p>In this article, we will look at what is necessary to run OpenStack&rsquo;s <a href=https://docs.openstack.org/keystone/latest/>Keystone</a> service (and the requisite database server) in containers using <a href=https://docs.docker.com/compose/>Docker Compose</a>.</p><h2 id=running-mariadb>Running MariaDB</h2><p>The standard <a href=https://hub.docker.com/_/mariadb/>mariadb docker image</a> can be configured via a number of environment variables. It also benefits from persistent volume storage, since in most situations you don&rsquo;t want to lose your data when you remove a container. A simple <code>docker</code> command line for starting MariaDB might look something like:</p></div><div><a class="read-more button inline" href=/post/2019-06-07-running-keystone-with-docker-c/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2018-02-26-grouping-aggregation-queries-i/>Grouping aggregation queries in Gnocchi 4.0.x</a></h1><div class=post-meta><time class=post-date>2018-02-26</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/gnocchi/>gnocchi</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/metrics/>metrics</a>&nbsp;</span><div class=post-content><p>In this article, we&rsquo;re going to ask Gnocchi (the OpenStack telemetry
storage service) how much memory was used, on average, over the course
of each day by each project in an OpenStack environment.</p><h2 id=environment>Environment</h2><p>I&rsquo;m working with an OpenStack &ldquo;Pike&rdquo; deployment, which means I have
Gnocchi 4.0.x. More recent versions of Gnocchi (4.1.x and later) have
a new aggregation API called <a href=https://gnocchi.xyz/rest.html#dynamic-aggregates>dynamic aggregates</a>, but that isn&rsquo;t
available in 4.0.x so in this article we&rsquo;ll be using the legacy
<code>/v1/aggregations</code> API.</p></div><div><a class="read-more button inline" href=/post/2018-02-26-grouping-aggregation-queries-i/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2018-01-24-safely-restarting-an-openstack/>Safely restarting an OpenStack server with Ansible</a></h1><div class=post-meta><time class=post-date>2018-01-24</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/ansible/>ansible</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;</span><div class=post-content><p>The other day on <a href=http://docs.ansible.com/ansible/latest/community.html#irc-channel>#ansible</a>, someone was looking for a way to safely
shut down a Nova server, wait for it to stop, and then start it up
again using the <code>openstack</code> cli. The first part seemed easy:</p><pre><code>- hosts: myserver
  tasks:
    - name: shut down the server
      command: poweroff
      become: true
</code></pre><p>&mldr;but that will actually fail with the following result:</p><pre><code>TASK [shut down server] *************************************
fatal: [myserver]: UNREACHABLE! =&gt; {&quot;changed&quot;: false, &quot;msg&quot;:
&quot;Failed to connect to the host via ssh: Shared connection to
10.0.0.103 closed.\r\n&quot;, &quot;unreachable&quot;: true}
</code></pre><p>This happens because running <code>poweroff</code> immediately closes Ansible&rsquo;s
ssh connection. The workaround here is to use a &ldquo;fire-and-forget&rdquo;
<a href=http://docs.ansible.com/ansible/latest/playbooks_async.html>asynchronous task</a>:</p></div><div><a class="read-more button inline" href=/post/2018-01-24-safely-restarting-an-openstack/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2017-08-02-ansible-for-infrastructure-tes/>Ansible for Infrastructure Testing</a></h1><div class=post-meta><time class=post-date>2017-08-02</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/ansible/>ansible</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ansible-assertive/>ansible-assertive</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;</span><div class=post-content><p>At <code>$JOB</code> we often find ourselves at customer sites where we see the
same set of basic problems that we have previously encountered
elsewhere (&ldquo;your clocks aren&rsquo;t in sync&rdquo; or &ldquo;your filesystem is full&rdquo;
or &ldquo;you haven&rsquo;t installed a critical update&rdquo;, etc). We would like a
simple tool that could be run either by the customer or by our own
engineers to test for and report on these common issues.
Fundamentally, we want something that acts like a typical code test
suite, but for infrastructure.</p></div><div><a class="read-more button inline" href=/post/2017-08-02-ansible-for-infrastructure-tes/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2017-06-14-openstack-containers-and-loggi/>OpenStack, Containers, and Logging</a></h1><div class=post-meta><time class=post-date>2017-06-14</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/logging/>logging</a>&nbsp;</span><div class=post-content><p>I&rsquo;ve been thinking about logging in the context of OpenStack and containerized service deployments. I&rsquo;d like to lay out some of my thoughts on this topic and see if people think I am talking crazy or not.</p><p>There are effectively three different mechanisms that an application can use to emit log messages:</p><ul><li>Via some logging-specific API, such as the legacy syslog API</li><li>By writing a byte stream to stdout/stderr</li><li>By writing a byte stream to a file</li></ul><p>A substantial advantage to the first mechanism (using a logging API) is that the application is logging <em>messages</em> rather than <em>bytes</em>. This means that if you log a message containing embedded newlines (e.g., python or java tracebacks), you can collect that as a single message rather than having to impose some sort of structure on the byte stream after the fact in order to reconstruct those message.</p></div><div><a class="read-more button inline" href=/post/2017-06-14-openstack-containers-and-loggi/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2017-01-22-making-sure-your-gerrit-change/>Making sure your Gerrit changes aren&rsquo;t broken</a></h1><div class=post-meta><time class=post-date>2017-01-22</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/gerrit/>gerrit</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/git/>git</a>&nbsp;</span><div class=post-content><p>It&rsquo;s a bit of an embarrassment when you submit a review to Gerrit only
to have it fail CI checks immediately because of something as simple
as a syntax error or pep8 failure that you should have caught yourself
before submitting&mldr;but you forgot to run your validations before
submitting the change.</p><p>In many cases you can alleviate this through the use of the git
<code>pre-commit</code> hook, which will run every time you commit changes
locally. You can have the hook run <code>tox</code> or whatever tool your
project uses for validation on every commit. This works okay for
simple cases, but if the validation takes more than a couple of
seconds the delay can be disruptive to the flow of your work.</p></div><div><a class="read-more button inline" href=/post/2017-01-22-making-sure-your-gerrit-change/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2016-08-11-exploring-yaql-expressions/>Exploring YAQL Expressions</a></h1><div class=post-meta><time class=post-date>2016-08-11</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/heat/>heat</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/hot/>hot</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/yaql/>yaql</a>&nbsp;</span><div class=post-content><p>The Newton release of <a href=https://wiki.openstack.org/wiki/Heat>Heat</a> adds support for a <a href=http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#yaql>yaql</a>
intrinsic function, which allows you to evaluate <a href=https://yaql.readthedocs.io/en/latest/>yaql</a> expressions
in your Heat templates. Unfortunately, the existing yaql
documentation is somewhat limited, and does not offer examples of many
of yaql&rsquo;s more advanced features.</p><p>I am working on a <a href=http://www.fluentd.org/>Fluentd</a> composable service for <a href=https://wiki.openstack.org/wiki/TripleO>TripleO</a>. I
want to allow each service to specify a logging source configuration
fragment, for example:</p><pre><code>parameters:
  NovaAPILoggingSource:
    type: json
    description: Fluentd logging configuration for nova-api.
    default:
      tag: openstack.nova.api
      type: tail
      format: |
        /(?&lt;time&gt;\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d+) (?&lt;pid&gt;\d+) (?&lt;priority&gt;\S+) (?&lt;message&gt;.*)/
      path: /var/log/nova/nova-api.log
      pos_file: /var/run/fluentd/openstack.nova.api.pos
</code></pre><p>This generally works, but several parts of this fragment are going to
be the same across all OpenStack services. I wanted to reduce the
above to just the unique attributes, which would look something like:</p></div><div><a class="read-more button inline" href=/post/2016-08-11-exploring-yaql-expressions/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2016-05-19-connecting-another-vm-to-your-/>Connecting another vm to your tripleo-quickstart deployment</a></h1><div class=post-meta><time class=post-date>2016-05-19</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openvswitch/>openvswitch</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/tripleo/>tripleo</a>&nbsp;</span><div class=post-content><p>Let&rsquo;s say that you have set up an environment using
<a href=https://github.com/openstack/tripleo-quickstart/>tripleo-quickstart</a> and you would like to add another virtual
machine to the mix that has both &ldquo;external&rdquo; connectivity (&ldquo;external&rdquo;
in quotes because I am using it in the same way as the quickstart does
w/r/t the undercloud) and connectivity to the overcloud nodes. How
would you go about setting that up?</p><p>For a concrete example, let&rsquo;s presume you have deployed an environment
using the default tripleo-quickstart configuration, which looks like
this:</p></div><div><a class="read-more button inline" href=/post/2016-05-19-connecting-another-vm-to-your-/>[read more]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2016-02-19-deploy-an-ha-openstack-develop/>Deploying an HA OpenStack development environment with tripleo-quickstart</a></h1><div class=post-meta><time class=post-date>2016-02-19</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/tripleo/>tripleo</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/rdo/>rdo</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ansible/>ansible</a>&nbsp;</span><div class=post-content><p>In this article I would like to introduce <a href=https://github.com/redhat-openstack/tripleo-quickstart>tripleo-quickstart</a>, a
tool that will automatically provision a virtual environment and then
use <a href=http://docs.openstack.org/developer/tripleo-docs/>TripleO</a> to deploy an HA OpenStack on top of it.</p><h2 id=introducing-tripleo-quickstart>Introducing Tripleo-Quickstart</h2><p>The goal of the <a href=https://github.com/redhat-openstack/tripleo-quickstart>Tripleo-Quickstart</a> project is to replace the
<code>instack-virt-setup</code> tool for quickly setting up virtual TripleO
environments, and to ultimately become the tool used by both
developers and upstream CI for this purpose. The project is a set of
<a href=http://ansible.com/>Ansible</a> playbooks that will take care of:</p></div><div><a class="read-more button inline" href=/post/2016-02-19-deploy-an-ha-openstack-develop/>[read more]</a></div></article><div class=pagination><div class=pagination__buttons><a href=/tags/openstack/page/2/ class="button inline next">[<span class=button__text>Older posts</span>] ></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>