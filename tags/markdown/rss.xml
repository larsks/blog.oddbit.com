<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Markdown on blog.oddbit.com</title><link>https://blog.oddbit.com/tags/markdown/</link><description>Recent content in Markdown on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Wed, 15 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tags/markdown/rss.xml" rel="self" type="application/rss+xml"/><item><title>Snarl: A tool for literate blogging</title><link>https://blog.oddbit.com/post/2020-01-15-snarl-a-tool-for-literate-blog/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-01-15-snarl-a-tool-for-literate-blog/</guid><description>Literate programming is a programming paradigm introduced by Donald Knuth in which a program is combined with its documentation to form a single document. Tools are then used to extract the documentation for viewing or typesetting or to extract the program code so it can be compiled and/or run. While I have never been very enthusiastic about literate programming as a development methodology, I was recently inspired to explore these ideas as they relate to the sort of technical writing I do for this blog.</description><content>&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Literate_programming">Literate programming&lt;/a> is a programming paradigm introduced by Donald Knuth in which a program is combined with its documentation to form a single document. Tools are then used to extract the documentation for viewing or typesetting or to extract the program code so it can be compiled and/or run. While I have never been very enthusiastic about literate programming as a development methodology, I was recently inspired to explore these ideas as they relate to the sort of technical writing I do for this blog.&lt;/p>
&lt;p>My previous post was about &lt;a href="https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/">OVN and DHCP&lt;/a>. While I had tested out configuration in question prior to writing the article, I introduced some code changes in the article without testing them, and that resulted in some &lt;a href="https://github.com/larsks/blog.oddbit.com/issues/8#issuecomment-572824924">dumb errors&lt;/a>. It occurred to me that some of the same tooling that had been designed for literate programming may offer a mechanism by which I could extract and test code in my blog posts to ensure that the code I was presenting operates as described.&lt;/p>
&lt;p>Unfortunately, many of the &lt;a href="http://www.literateprogramming.com/tools.html">existing literate programming tools&lt;/a> weren&amp;rsquo;t going to work out. Several of them assume you want to write documentation in LaTeX. Others are designed primarily for a particular programming language, and just about all of them use syntax that doesn&amp;rsquo;t really play well with Markdown documents. The tool that came closest was &lt;a href="https://github.com/driusan/lmt">lmt&lt;/a>, but that tool only addresses the &amp;ldquo;tangling&amp;rdquo; aspect of document processing (extracting code), whereas I explicitly want the ability to exclude some code from the finished documentation, which requires support for &amp;ldquo;weaving&amp;rdquo; (documentation extraction).&lt;/p>
&lt;p>Since I couldn&amp;rsquo;t find a tool that did exactly what I wanted, I ended up writing my own.&lt;/p>
&lt;h2 id="introducing-snarl">Introducing Snarl&lt;/h2>
&lt;p>&lt;a href="https://github.com/larsks/snarl">Snarl&lt;/a> is a tool for writing literate blog posts. It&amp;rsquo;s primary purpose is to permit you to extract code from a Markdown document in order to test it and ensure its accuracy. It has feature similar to many other literate programming tools:&lt;/p>
&lt;ul>
&lt;li>You can present code in an order that differs from that which you output for testing. This allows you to present code in the way that makes the most sense for your readers, rather than that required by the particular programming language you&amp;rsquo;re using.&lt;/li>
&lt;li>Code blocks can refer to other code blocks. These references are expanded when writing the content to files.&lt;/li>
&lt;li>Snarl supports an &amp;ldquo;include&amp;rdquo; feature that permits you to split up a large document across multiple files.&lt;/li>
&lt;/ul>
&lt;h2 id="code-blocks">Code blocks&lt;/h2>
&lt;p>The heart of Snarl is the code block, which uses an extended form of the standard Markdown fenced code block:&lt;/p>
&lt;pre>&lt;code>```[&amp;lt;language&amp;gt;]=&amp;lt;label&amp;gt; [--file] [--hide] [--tag tag [...]] [--replace
&amp;lt;pattern&amp;gt; &amp;lt;substitution&amp;gt;]
...code goes here...
```
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>&amp;lt;language&amp;gt;&lt;/code> information is optional and is ignored by Snarl; this is standard syntax for providing syntax coloring hints for fenced code blocks. The value is passed on to the rendered Markdown when running &lt;code>snarl weave&lt;/code>.&lt;/p>
&lt;p>Everything after the &lt;code>=&lt;/code> is interpreted using a standard command-line option parser (Python&amp;rsquo;s &lt;a href="https://docs.python.org/3/library/argparse.html">argparse&lt;/a> module), which means that &lt;code>&amp;lt;label&amp;gt;&lt;/code> may contain whitespace as long as you quote it.&lt;/p>
&lt;p>The options are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>--file&lt;/code> (&lt;code>-f&lt;/code>) &amp;ndash; mark a code block as a file. Blocks marked as files will be written out by default when running &lt;code>snarl tangle&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>--hide&lt;/code> (&lt;code>-h&lt;/code>) &amp;ndash; Elide this block when running &lt;code>snarl weave&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>--tag &amp;lt;tag&amp;gt;&lt;/code> (&lt;code>-t tag&lt;/code>) &amp;ndash; Apply a tag to the code block. You can elect to write out only certain code blocks using the &lt;code>--tag&lt;/code> option to &lt;code>snarl tangle&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>--replace &amp;lt;pattern&amp;gt; &amp;lt;subsitution&amp;gt;&lt;/code> &amp;ndash; Replace regular expression &lt;code>&amp;lt;pattern&amp;gt;&lt;/code> with &lt;code>&amp;lt;substitution&amp;gt;&lt;/code> when tangling the document.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="a-simple-example">A simple example&lt;/h2>
&lt;p>Let&amp;rsquo;s say we were going to write a post about a &amp;ldquo;Hello world!&amp;rdquo; program in C. Our document might look something like this:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="tangling">Tangling&lt;/h3>
&lt;p>If we were to run &lt;code>snarl tangle&lt;/code> on this file, we would get as output a single file, &lt;code>hello.c&lt;/code>, with the following content:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>This file contains the contents of the &lt;code>include header files&lt;/code> block and the &lt;code>main function&lt;/code> block, along with some literal content from the &lt;code>hello.c&lt;/code> block itself.&lt;/p>
&lt;p>It would be trivial to have a simple shell script compile and execute this code to ensure that it behaves as expected.&lt;/p>
&lt;h3 id="weaving">Weaving&lt;/h3>
&lt;p>Running &lt;code>snarl weave&lt;/code> on the document source would result in:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>You can see that the Snarl-annotated code blocks have been rendered as standard Markdown fenced code blocks without the additional metadata. You can also see the effect of the &lt;code>--hide&lt;/code> option on code blocks: the contents of &lt;code>hello.c&lt;/code> are excluded in the final Markdown output.&lt;/p>
&lt;h2 id="a-longer-example">A longer example&lt;/h2>
&lt;p>The &lt;a href="https://raw.githubusercontent.com/larsks/blog.oddbit.com-snarl/master/ovn-and-dhcp/2019-12-19-ovn-and-dhcp.snarl.md">source&lt;/a> to my earlier blog post on &lt;a href="https://blog.oddbit.com/post/2019-12-19-ovn-and-dhcp/">OVN and DHCP&lt;/a> provides a less contrived example. In addition to the document source itself, you can see the framework I used for running the scripts presented in the post and testing the environment afterwards.&lt;/p>
&lt;h3 id="using-replace">Using replace&lt;/h3>
&lt;p>That post provides an example of using the &lt;code>--replace&lt;/code> flag on a code block. For the purposes of the article, I was using fixed IP addresses for the nodes involved, but when setting up a virtual environment for testing it was easier to just let the nodes pick up addresses dynamically. In order to test the code that uses a static ip address, I replace that address with a variable reference when generating the script files:&lt;/p>
&lt;pre>&lt;code>```=configure_ovs_external_ids --replace 192.168.122.100 ${OVN0_ADDRESS}
ovs-vsctl set open_vswitch . \
external_ids:ovn-remote=tcp:192.168.122.100:6642 \
external_ids:ovn-encap-ip=$(ip addr show eth0 | awk '$1 == &amp;quot;inet&amp;quot; {print $2}' | cut -f1 -d/) \
external_ids:ovn-encap-type=geneve \
external_ids:system-id=$(hostname)
```
&lt;/code>&lt;/pre>
&lt;p>When running &lt;code>snarl tangle&lt;/code> on that document, the above text renders as:&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl set open_vswitch . \
external_ids:ovn-remote=tcp:${OVN0_ADDRESS}:6642 \
external_ids:ovn-encap-ip=$(ip addr show eth0 | awk &amp;#39;$1 == &amp;#34;inet&amp;#34; {print $2}&amp;#39; | cut -f1 -d/) \
external_ids:ovn-encap-type=geneve \
external_ids:system-id=$(hostname)
&lt;/code>&lt;/pre>&lt;h3 id="using-tags">Using tags&lt;/h3>
&lt;p>If you look at the files embedded in that post, you will find that they are tagged using the &lt;code>--tag&lt;/code> (&lt;code>-t&lt;/code>) option:&lt;/p>
&lt;pre>&lt;code>```=configure-common.sh --file --hide -t setup
&amp;lt;&amp;lt;enable_common_services&amp;gt;&amp;gt;
&amp;lt;&amp;lt;add_br_int&amp;gt;&amp;gt;
```
&lt;/code>&lt;/pre>
&lt;p>This permits me to extract a subset of files. For example, to extract just the files tagged &lt;code>setup&lt;/code>, I would run:&lt;/p>
&lt;pre tabindex="0">&lt;code>snarl tangle -t setup 2019-12-19-ovn-and-dhcp.snarl.md
&lt;/code>&lt;/pre>&lt;h2 id="including-files">Including files&lt;/h2>
&lt;p>While the main focus of Snarl is extracting code from documentation, sometimes you want to go in the other direction. Snarl supports an &lt;code>include&lt;/code> directive that will include the content of another file in the current document. The &lt;code>include&lt;/code> directive is written as an HTML comment:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!-- include &amp;lt;path&amp;gt; [--escape-html] [--verbatim] --&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A simple example might look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!-- include anotherfile.md --&amp;gt;
&lt;/code>&lt;/pre>&lt;p>By default, the file contents will be processed as if they were part of the existing document. That means that your included file may itself contain Snarl directives. This isn&amp;rsquo;t always the behavior that you want, so there are a couple of options available that modify the behavior of &lt;code>include&lt;/code>.&lt;/p>
&lt;p>In order to embed Snarl samples in this post, I am using the HTML &lt;code>&amp;lt;pre&amp;gt;&lt;/code> element to wrap the sample text, which I am including in this document via the &lt;code>include&lt;/code> directive. I don&amp;rsquo;t want to interpret Snarl directives in these included files. The &lt;code>--verbatim&lt;/code> (or &lt;code>-v&lt;/code>) option will include the literal content of the named file without looking for Snarl directives.&lt;/p>
&lt;p>An unfortunate side effect of using the &lt;code>&amp;lt;pre&amp;gt;&lt;/code> element is that I have to escape any &lt;code>&amp;lt;&lt;/code> characters that appear in the included content. The &lt;code>--escape-html&lt;/code> (or &lt;code>-e&lt;/code>) option performs the necessary HTML escaping on the included file so that it will display as intended.&lt;/p>
&lt;p>For example, the example Snarl source presented earlier in this document was included using the following syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!-- include hello.snarl.md -ve --&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="to-infinity-and-beyond">To infinity and beyond&lt;/h2>
&lt;p>Being able to extract and verify code in technical articles is incredibly useful. There are other tools out there that will do something similar, but I&amp;rsquo;m happy with how Snarl operates. I will absolutely be using this going forward to avoid unfortunate errors in my blogs posts, and I hope others will find it useful as well.&lt;/p></content></item><item><title>Converting HTML to Markdown</title><link>https://blog.oddbit.com/post/2012-11-06-convert-html-to-markdown/</link><pubDate>Tue, 06 Nov 2012 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2012-11-06-convert-html-to-markdown/</guid><description>In order to import posts from Blogger into Scriptogr.am I needed to convert all the HTML formatting into Markdown. Thankfully there are a number of tools out there that can help with this task.
MarkdownRules. This is an online service build around Markdownify. It&amp;rsquo;s a slick site with a nice API, but the backend wasn&amp;rsquo;t able to correctly render &amp;lt;pre&amp;gt; blocks. Since I&amp;rsquo;m often writing about code, my posts are filled with things like embedded XML and #include &amp;lt;stdio.</description><content>&lt;p>In order to import posts from &lt;a href="http://blogger.com/">Blogger&lt;/a> into &lt;a href="http://scriptogr.am/">Scriptogr.am&lt;/a> I needed to convert all the HTML formatting into Markdown. Thankfully there are a number of tools out there that can help with this task.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://markdownrules.com/">MarkdownRules&lt;/a>. This is an online service build around
&lt;a href="http://milianw.de/projects/markdownify/">Markdownify&lt;/a>. It&amp;rsquo;s a slick site with a nice API, but the backend
wasn&amp;rsquo;t able to correctly render &lt;code>&amp;lt;pre&amp;gt;&lt;/code> blocks. Since I&amp;rsquo;m often
writing about code, my posts are filled with things like embedded
XML and &lt;code>#include &amp;lt;stdio.h&amp;gt;&lt;/code>, so this was a problem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://johnmacfarlane.net/pandoc/">Pandoc&lt;/a>. This is a general purpose tool that can convert between
a variety of markup formats. Unfortunately, it &lt;em>also&lt;/em> had similar
problems with &lt;code>&amp;lt;pre&amp;gt;&lt;/code> blocks.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/aaronsw/html2text">html2text&lt;/a>. This a Python tool that converts HTML to Markdown.
It seems to do a better job at handling the &lt;code>&amp;lt;pre&amp;gt;&lt;/code> blocks, although
it doesn&amp;rsquo;t always get the indent level correct when the &lt;code>&amp;lt;pre&amp;gt;&lt;/code>
blocks are embedded in lists.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>I ultimately ended up using &lt;a href="https://github.com/aaronsw/html2text">html2text&lt;/a>, combined with a &lt;a href="https://gist.github.com/4022537">simple
script&lt;/a> to read the &lt;a href="http://www.dataliberation.org/takeout-products/blogger">export from Blogger&lt;/a> and feed each document to
the converter.&lt;/p></content></item></channel></rss>