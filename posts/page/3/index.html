<!doctype html><html lang=en><head><title>:: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/posts/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content><meta property="og:description" content><meta property="og:url" content="https://blog.oddbit.com/posts/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/posts/rss.xml rel=alternate type=application/rss+xml title=blog.oddbit.com></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2022-02-13-wemos-udev-rules/>Udev rules for CH340 serial devices</a></h1><div class=post-meta><time class=post-date>2022-02-13 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/linux/>linux</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/micropython/>micropython</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/udev/>udev</a>&nbsp;</span>
<img src=/post/2022-02-13-wemos-udev-rules/cover.png class=post-cover alt="Udev rules for CH340 serial devices" title="Cover Image"><div class=post-content>I like to fiddle with Micropython, particularly on the Wemos D1 Mini, because these are such a neat form factor. Unfortunately, they have a cheap CH340 serial adapter on board, which means that from the perspective of Linux these devices are all functionally identical – there’s no way to identify one device from another. This by itself would be a manageable problem, except that the device names assigned to these devices aren’t constant: depending on the order in which they get plugged in (and the order in which they are detected at boot), a device might be /dev/ttyUSB0 one day and /dev/ttyUSB2 another day.</div><div><a class="read-more button" href=/post/2022-02-13-wemos-udev-rules/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-09-05-sx-question-filters/>A pair of userscripts for cleaning up Stack Exchange sites</a></h1><div class=post-meta><time class=post-date>2021-09-05 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/stackexchange/>stackexchange</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/browser/>browser</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/javascript/>javascript</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/userscripts/>userscripts</a>&nbsp;</span>
<img src=/post/2021-09-05-sx-question-filters/cover.png class=post-cover alt="A pair of userscripts for cleaning up Stack Exchange sites" title="Cover Image"><div class=post-content>I’ve been a regular visitor to Stack Overflow and other Stack Exchange sites over the years, and while I’ve mostly enjoyed the experience, I’ve been frustrated by the lack of control I have over what questions I see. I’m not really interested in looking at questions that have already been closed, or that have a negative score, but there’s no native facility for filtering questions like this.
I finally spent the time learning just enough JavaScript to hurt myself to put together a pair of scripts that let me present the questions that way I want:</div><div><a class="read-more button" href=/post/2021-09-05-sx-question-filters/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-09-03-kubernetes-external-secrets/>Kubernetes External Secrets</a></h1><div class=post-meta><time class=post-date>2021-09-03 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/secrets/>secrets</a>&nbsp;</span>
<img src=/post/2021-09-03-kubernetes-external-secrets/cover.jpg class=post-cover alt="Kubernetes External Secrets" title="Cover Image"><div class=post-content>At $JOB we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using ArgoCD and Kustomize. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials.</div><div><a class="read-more button" href=/post/2021-09-03-kubernetes-external-secrets/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-08-23-external-ocs/>Connecting OpenShift to an External Ceph Cluster</a></h1><div class=post-meta><time class=post-date>2021-08-23 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/ceph/>ceph</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/ocs/>ocs</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/odf/>odf</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/storage/>storage</a>&nbsp;</span><div class=post-content>Red Hat’s OpenShift Data Foundation (formerly “OpenShift Container Storage”, or “OCS”) allows you to either (a) automatically set up a Ceph cluster as an application running on your OpenShift cluster, or (b) connect your OpenShift cluster to an externally managed Ceph cluster. While setting up Ceph as an OpenShift application is a relatively polished experienced, connecting to an external cluster still has some rough edges.
NB I am not a Ceph expert.</div><div><a class="read-more button" href=/post/2021-08-23-external-ocs/>read more →</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-04-17-vm-ovs-vxlan/>Creating a VXLAN overlay network with Open vSwitch</a></h1><div class=post-meta><time class=post-date>2021-04-17 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/virtualization/>virtualization</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/openvswitch/>openvswitch</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/vxlan/>vxlan</a>&nbsp;</span><div class=post-content>In this post, we’ll walk through the process of getting virtual machines on two different hosts to communicate over an overlay network created using the support for VXLAN in Open vSwitch (or OVS).
The test environment For this post, I’ll be working with two systems:
node0.ovs.virt at address 192.168.122.107 node1.ovs.virt at address 192.168.122.174 These hosts are running CentOS 8, although once we get past the package installs the instructions will be similar for other distributions.</div><div><a class="read-more button" href=/post/2021-04-17-vm-ovs-vxlan/>read more →</a></div></article><div class=pagination><div class=pagination__buttons><a href=/posts/page/2/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>Newer posts</span></a>
<a href=/posts/page/4/ class="button next"><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script>
<script src=/js/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>