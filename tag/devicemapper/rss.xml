<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>devicemapper on blog.oddbit.com</title><link>https://blog.oddbit.com/tag/devicemapper/</link><description>Recent content in devicemapper on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Thu, 25 Jan 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tag/devicemapper/rss.xml" rel="self" type="application/rss+xml"/><item><title>Fun with devicemapper snapshots</title><link>https://blog.oddbit.com/post/2018-01-25-fun-with-devicemapper-snapshot/</link><pubDate>Thu, 25 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-01-25-fun-with-devicemapper-snapshot/</guid><description>I find myself working with Raspbian disk images fairly often. A typical workflow is:
Download the disk image. Mount the filesystem somewhere to check something. Make some changes or install packages just to check something else. Crap I&amp;rsquo;ve made changes. &amp;hellip;at which point I need to fetch a new copy of the image next time I want to start fresh.
Sure, I could just make a copy of the image and work from there, but what fun is that?</description><content>&lt;p>I find myself working with &lt;a href="https://www.raspberrypi.org/downloads/raspbian/">Raspbian&lt;/a> disk images fairly often. A
typical workflow is:&lt;/p>
&lt;ul>
&lt;li>Download the disk image.&lt;/li>
&lt;li>Mount the filesystem somewhere to check something.&lt;/li>
&lt;li>Make some changes or install packages just to check something else.&lt;/li>
&lt;li>Crap I&amp;rsquo;ve made changes.&lt;/li>
&lt;/ul>
&lt;p>&amp;hellip;at which point I need to fetch a new copy of the image next time I
want to start fresh.&lt;/p>
&lt;p>Sure, I could just make a copy of the image and work from there, but
what fun is that? This seemed like a perfect opportunity to learn more
about the &lt;a href="https://www.kernel.org/doc/Documentation/device-mapper/">device mapper&lt;/a> and in particular how the &lt;a href="https://www.kernel.org/doc/Documentation/device-mapper/snapshot.txt">snapshot&lt;/a>
target works.&lt;/p>
&lt;h2 id="making-sure-we-have-a-block-device">Making sure we have a block device&lt;/h2>
&lt;p>The device mapper only operates on block devices, so the first thing
we need to do is to make the source image available as a block device.
We can do that with the &lt;a href="http://manpages.ubuntu.com/manpages/xenial/man8/losetup.8.html">losetup&lt;/a> command, which maps a file to a
virtual block device (or &lt;em>loop&lt;/em> device).&lt;/p>
&lt;p>I run something like this:&lt;/p>
&lt;pre>&lt;code>losetup --find --show --read-only 2017-11-29-raspbian-stretch-lite.img
&lt;/code>&lt;/pre>
&lt;p>This will find the first available block device, and then use it make
my disk image available in read-only mode. Those of you who are
familiar with &lt;code>losetup&lt;/code> may be thinking, &amp;ldquo;you know, &lt;code>losetup&lt;/code> knows
how to handle partitioned devices&amp;rdquo;, but I am ignoring that for the
purpose of using device mapper to solve things.&lt;/p>
&lt;h2 id="mapping-a-partition">Mapping a partition&lt;/h2>
&lt;p>We&amp;rsquo;ve just mapped the entire disk image to a block device. We can&amp;rsquo;t
use this directly because the image has multiple partitions:&lt;/p>
&lt;pre>&lt;code># sfdisk -l /dev/loop0
Disk /dev/loop0: 1.7 GiB, 1858076672 bytes, 3629056 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x37665771
Device Boot Start End Sectors Size Id Type
/dev/loop0p1 8192 93236 85045 41.5M c W95 FAT32 (LBA)
/dev/loop0p2 94208 3629055 3534848 1.7G 83 Linux
&lt;/code>&lt;/pre>
&lt;p>We want to expose partition 2, which contains the root filesystem. We
can see from the above output that partition 2 starts at sector
&lt;code>94208&lt;/code> and extends for &lt;code>3534848&lt;/code> sectors (where a &lt;em>sector&lt;/em> is for our
purposes 512 bytes). If you need to get at this information
programatically, &lt;code>sfdisk&lt;/code> has &lt;code>--json&lt;/code> option that can be useful; for
example:&lt;/p>
&lt;pre>&lt;code># p_start=$(sfdisk --json /dev/loop0 |
jq &amp;quot;.partitiontable.partitions[1].start&amp;quot;)
# echo $p_start
94208
&lt;/code>&lt;/pre>
&lt;p>We want to expose this partition as a distinct block device. We&amp;rsquo;re
going to do this by creating a device mapper &lt;code>linear&lt;/code> target. To
create device mapper devices, we use the &lt;code>dmsetup&lt;/code> command; the basic
syntax is:&lt;/p>
&lt;pre>&lt;code>dmsetup create &amp;lt;name&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>By default, this expects to read a table describing the device on
&lt;code>stdin&lt;/code>, although it is also possible to specify one on the command
line. A table consists of one or more lines of the format:&lt;/p>
&lt;pre>&lt;code>&amp;lt;base&amp;gt; &amp;lt;length&amp;gt; &amp;lt;target&amp;gt; [&amp;lt;options&amp;gt;]
&lt;/code>&lt;/pre>
&lt;p>Where &lt;code>&amp;lt;base&amp;gt;&lt;/code> is the starting offset in sectors for this particular
segment, &lt;code>&amp;lt;length&amp;gt;&lt;/code> is the length, &lt;code>&amp;lt;target&amp;gt;&lt;/code> is the target type
(linear, snapshot, zero, etc), and the option are specific to the
particular target in use.&lt;/p>
&lt;p>To create a device exposing partition 2 of our image, we run:&lt;/p>
&lt;pre>&lt;code># dmsetup create base &amp;lt;&amp;lt;EOF
0 3534848 linear /dev/loop0 94208
EOF
&lt;/code>&lt;/pre>
&lt;p>This creates a device named &lt;code>/dev/mapper/base&lt;/code>. Sectors &lt;code>0&lt;/code> through
&lt;code>3534848&lt;/code> of this device will be provided by &lt;code>/dev/loop0&lt;/code>, starting at
offset &lt;code>94208&lt;/code>. At this point, we can actually mount the filesystem:&lt;/p>
&lt;pre>&lt;code># mount -o ro /dev/mapper/base /mnt
# ls /mnt
bin dev home lost+found mnt proc run srv tmp var
boot etc lib media opt root sbin sys usr
# umount /mnt
&lt;/code>&lt;/pre>
&lt;p>But wait, there&amp;rsquo;s a problem! These disk images usually have very
little free space. We&amp;rsquo;re going to want to extend the length of our
base device by some amount so that we have room for new packages and
so forth. Fortunately, since our goal is that all writes are going to
a snapshot, we don&amp;rsquo;t need to use &lt;em>real&lt;/em> space. We can add another
segment to our table that uses the &lt;a href="https://www.kernel.org/doc/Documentation/device-mapper/zero.txt">zero&lt;/a> target.&lt;/p>
&lt;p>Let&amp;rsquo;s first get rid of the device we just created:&lt;/p>
&lt;pre>&lt;code># dmsetup remove base
&lt;/code>&lt;/pre>
&lt;p>And create a new one:&lt;/p>
&lt;pre>&lt;code># dmsetup create base &amp;lt;&amp;lt;EOF
0 3534848 linear /dev/loop0 94208
3534848 6950912 zero
EOF
&lt;/code>&lt;/pre>
&lt;p>This extends our &lt;code>base&lt;/code> device out to 5G (or a total of &lt;code>10485760&lt;/code>
sectors), although attempting to read from anything beyond sector
&lt;code>3534848&lt;/code> will return zeros, and writes will be discarded. But that&amp;rsquo;s
okay, because the space available for writes is going to come from a
COW (&amp;ldquo;copy-on-write&amp;rdquo;) device associated with our snapshot: in other
words, the capacity of our snapshot will be linked to size of our COW
device, rather than the size of the underlying base image.&lt;/p>
&lt;h2 id="creating-a-snapshot">Creating a snapshot&lt;/h2>
&lt;p>Now that we&amp;rsquo;ve sorted out our base image it&amp;rsquo;s time to create the
snapshot device. According to &lt;a href="https://www.kernel.org/doc/Documentation/device-mapper/snapshot.txt">the documentation&lt;/a>, the
table entry for a snapshot looks like:&lt;/p>
&lt;pre>&lt;code>snapshot &amp;lt;origin&amp;gt; &amp;lt;COW device&amp;gt; &amp;lt;persistent?&amp;gt; &amp;lt;chunksize&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>We have our &lt;code>&amp;lt;origin&amp;gt;&lt;/code> (that&amp;rsquo;s the base image we created in the
previous step), but what are we going to use as our &lt;code>&amp;lt;COW device&amp;gt;&lt;/code>?
This is a chunk of storage that will receive any writes to the
snapshot device. This could be any block device (another loop device,
an LVM volume, a spare disk partition), but for my purposes it seemed
convenient to use a RAM disk, since I had no need for persistent
changes. We can use the &lt;a href="https://www.kernel.org/doc/Documentation/blockdev/zram.txt">zram&lt;/a> kernel module for that. Let&amp;rsquo;s start
by loading the module:&lt;/p>
&lt;pre>&lt;code># modprobe zram
&lt;/code>&lt;/pre>
&lt;p>Without any additional parameters this will create a single RAM disk,
&lt;code>/dev/zram0&lt;/code>. Initially, it&amp;rsquo;s not very big:&lt;/p>
&lt;pre>&lt;code># blockdev --getsz /dev/zram0
0
&lt;/code>&lt;/pre>
&lt;p>But we can change that using the &lt;code>sysfs&lt;/code> interface provided in
&lt;code>/sys/block/zram0/&lt;/code>. The &lt;code>disksize&lt;/code> option controls the size of the
disk. Let&amp;rsquo;s say we want to handle up to 512M of writes; that means we
need to write the value &lt;code>512M&lt;/code> to &lt;code>/sys/block/zram0/disksize&lt;/code>:&lt;/p>
&lt;pre>&lt;code>echo 512M &amp;gt; /sys/block/zram0/disksize
&lt;/code>&lt;/pre>
&lt;p>And now:&lt;/p>
&lt;pre>&lt;code># blockdev --getsz /dev/zram0
1048576
&lt;/code>&lt;/pre>
&lt;p>We now have all the requirements to create our snapshot device:&lt;/p>
&lt;pre>&lt;code>dmsetup create snap &amp;lt;&amp;lt;EOF
0 10485760 snapshot /dev/mapper/base /dev/zram0 N 16
EOF
&lt;/code>&lt;/pre>
&lt;p>This creates a device named &lt;code>/dev/mapper/snap&lt;/code>. It is a 5G block
device backed by &lt;code>/dev/mapper/base&lt;/code>, with changes written to
&lt;code>/dev/zram0&lt;/code>. We can mount it:&lt;/p>
&lt;pre>&lt;code># mount /dev/mapper/snap /mnt
# df -h /mnt
Filesystem Size Used Avail Use% Mounted on
/dev/mapper/snap 1.7G 943M 623M 61% /mnt
&lt;/code>&lt;/pre>
&lt;p>And we can resize it:&lt;/p>
&lt;pre>&lt;code># resize2fs !$
resize2fs /dev/mapper/snap
resize2fs 1.43.3 (04-Sep-2016)
Filesystem at /dev/mapper/snap is mounted on /mnt; on-line resizing required
old_desc_blocks = 1, new_desc_blocks = 1
The filesystem on /dev/mapper/snap is now 1310720 (4k) blocks long.
# df -h /mnt
Filesystem Size Used Avail Use% Mounted on
/dev/mapper/snap 4.9G 944M 3.8G 20% /mnt
&lt;/code>&lt;/pre>
&lt;p>You&amp;rsquo;ll note here that it looks like we have a 5G device, because
that&amp;rsquo;s the size of our base image. Because we&amp;rsquo;ve only allocated
&lt;code>512M&lt;/code> to our COW device, we can actually only handle up to 512M of
writes before we invalidate the snapshot.&lt;/p>
&lt;p>We can inspect the amount of our COW device that has been consumed by
changes by using &lt;code>dmsetup status&lt;/code>:&lt;/p>
&lt;pre>&lt;code># dmsetup status snap
0 10485760 snapshot 107392/1048576 0
&lt;/code>&lt;/pre>
&lt;p>This tells us that &lt;code>107392&lt;/code> sectors of &lt;code>1048576&lt;/code> total have been
consumed so far (in other words, about 54M out of 512M). We can get
similar information from the perspective of the &lt;code>zram&lt;/code> module using
&lt;code>zramctl&lt;/code>:&lt;/p>
&lt;pre>&lt;code># zramctl
NAME ALGORITHM DISKSIZE DATA COMPR TOTAL STREAMS MOUNTPOINT
/dev/zram0 lzo 512M 52.4M 34K 72K 4
&lt;/code>&lt;/pre>
&lt;p>This information is also available in &lt;code>/sys/block/zram0/mm_stat&lt;/code>, but
without any labels.&lt;/p></content></item></channel></rss>