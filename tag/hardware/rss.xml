<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hardware on blog.oddbit.com</title><link>https://blog.oddbit.com/tag/hardware/</link><description>Recent content in hardware on blog.oddbit.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lars Kellogg-Stedman</copyright><lastBuildDate>Sat, 26 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.oddbit.com/tag/hardware/rss.xml" rel="self" type="application/rss+xml"/><item><title>Vortex Core Keyboard Review</title><link>https://blog.oddbit.com/post/2020-09-26-vortex-core-keyboard-review/</link><pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2020-09-26-vortex-core-keyboard-review/</guid><description>I&amp;rsquo;ve had my eye on the Vortex Core keyboard for a few months now, and this past week I finally broke down and bought one (with Cherry MX Brown switches). The Vortex Core is a 40% keyboard, which means it consists primarily of letter keys, a few lonely bits of punctuation, and several modifier keys to activate different layers on the keyboard.
Physical impressions It&amp;rsquo;s a really cute keyboard. I&amp;rsquo;m a big fan of MX brown switches, and this keyboard is really a joy to type on, at least when you&amp;rsquo;re working primarily with the alpha keys.</description><content>&lt;p>I&amp;rsquo;ve had my eye on the &lt;a href="http://www.vortexgear.tw/vortex2_2.asp?kind=47&amp;amp;kind2=224&amp;amp;kind3=&amp;amp;kind4=1033">Vortex Core&lt;/a> keyboard for a few months now, and this
past week I finally broke down and bought one (with Cherry MX Brown switches).
The Vortex Core is a 40% keyboard, which means it consists primarily of letter
keys, a few lonely bits of punctuation, and several modifier keys to activate
different layers on the keyboard.&lt;/p>
&lt;figure class="left" >
&lt;img src="vortex-core.jpg" />
&lt;/figure>
&lt;h2 id="physical-impressions">Physical impressions&lt;/h2>
&lt;p>It&amp;rsquo;s a really cute keyboard. I&amp;rsquo;m a big fan of MX brown switches, and this
keyboard is really a joy to type on, at least when you&amp;rsquo;re working primarily
with the alpha keys. I&amp;rsquo;m still figuring out where some of the punctuation
is, and with a few exceptions I haven&amp;rsquo;t yet spent time trying to remap
things into more convenient positions.&lt;/p>
&lt;p>The keyboard feels solid. I&amp;rsquo;m a little suspicious of the micro-usb
connector; it feels a little wobbly. I wish that it was USB-C and I wish it
felt a little more stable.&lt;/p>
&lt;p>Here&amp;rsquo;s a picture of my Core next to my Durgod &lt;a href="https://www.amazon.com/DURGOD-Mechanical-Interface-Tenkeyless-Anti-Ghosting/dp/B078H3WPHM">K320&lt;/a>:&lt;/p>
&lt;figure class="left" >
&lt;img src="core-vs-k320.jpg" />
&lt;/figure>
&lt;h2 id="programming">Programming&lt;/h2>
&lt;p>The keyboard first came out in 2017, and if you read reviews that came out
around that time you&amp;rsquo;ll find several complaints around limitations in the
keyboard&amp;rsquo;s programming features, in particular:&lt;/p>
&lt;ul>
&lt;li>you can&amp;rsquo;t map the left and right spacebars differently&lt;/li>
&lt;li>you can&amp;rsquo;t remap layer 0&lt;/li>
&lt;li>you can&amp;rsquo;t remap the Fn1 key&lt;/li>
&lt;/ul>
&lt;p>And so forth. Fortunately, at some point (maybe 2018) Vortexgear released
updated firmware that resolves all of the above issues, and introduces a
completely new way of programming the keyboard.&lt;/p>
&lt;p>Originally, the keyboard was programmed entirely via the keyboard itself: there
was a key combination to activate programming mode in each of the three
programmable layers, and this allowed you to freely remap keys. Unfortunately,
this made it well difficult to share layouts, and made extensive remapping
rather unwieldy.&lt;/p>
&lt;p>The &lt;a href="http://www.vortexgear.tw/db/upload/webdata4/6vortex_201861271445393.exe">updated firmware&lt;/a> (&amp;quot;&lt;code>CORE_MPC&lt;/code>&amp;quot;) does away with the hardware
programming, and instead introduces both a web UI for generating keyboard
layouts and a simple mechanism for pushing those layouts to the keyboard that
is completely operating system independent (which is nice if you&amp;rsquo;re a Linux
user and are tired of having to spin up a Windows VM just to run someone&amp;rsquo;s
firmware programming tool). With the new firmware, you hold down &lt;code>Fn-d&lt;/code> when
booting the keyboard and it will present a FAT-format volume to the operating
system. Drag your layout to the volume, unmount it, and reboot the keyboard and
you&amp;rsquo;re all set (note that you will still need to spin up that Windows VM
one last time in order to install the firmware update).&lt;/p>
&lt;p>The Vortexgear keyboard configurator is available at
&lt;a href="http://www.vortexgear.tw/mpc/index.html">http://www.vortexgear.tw/mpc/index.html&lt;/a>, but you&amp;rsquo;re going to want to use
&lt;a href="https://tsfreddie.github.io/much-programming-core/">https://tsfreddie.github.io/much-programming-core/&lt;/a> instead, which removes
several limitations that are present in the official tool.&lt;/p>
&lt;p>Because the new configurator (a) allows you to remap all layers, including
layer 0, and (b) allows to create mappings for the &lt;code>Pn&lt;/code> key, you have a lot
of flexibility in how you set up your mappings.&lt;/p>
&lt;h3 id="how-ive-configured-things">How I&amp;rsquo;ve configured things&lt;/h3>
&lt;p>I performed some limited remapping of layer 0:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>I&amp;rsquo;ve moved the &lt;code>Fn1&lt;/code> key to the right space bar, and turned the original
&lt;code>Fn1&lt;/code> key into the quote key. I use that enough in general writing that
it&amp;rsquo;s convenient to be able to access it without using a modifier.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>I&amp;rsquo;ve set up a cursor cluster using the &lt;code>Pn&lt;/code> key. This gets me the
standard &lt;code>WASD&lt;/code> keys for arrows, and &lt;code>Q&lt;/code> and &lt;code>E&lt;/code> for page up and page
down.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Holding down the &lt;code>Pn&lt;/code> key also gets me a numeric keypad on the right side
of the keyboard.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="final-thoughts">Final thoughts&lt;/h2>
&lt;p>It&amp;rsquo;s a fun keyboard. I&amp;rsquo;m not sure it&amp;rsquo;s going to become my primary keyboard,
especially for writing code, but I&amp;rsquo;m definitely happy with it.&lt;/p></content></item><item><title>Multiple 1-Wire Buses on the Raspberry Pi</title><link>https://blog.oddbit.com/post/2018-03-27-multiple-1-wire-buses-on-the-/</link><pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2018-03-27-multiple-1-wire-buses-on-the-/</guid><description>The DS18B20 is a popular temperature sensor that uses the 1-Wire protocol for communication. Recent versions of the Linux kernel include a kernel driver for this protocol, making it relatively convenient to connect one or more of these devices to a Raspberry Pi or similar device. 1-Wire devices can be daisy chained, so it is possible to connect several devices to your Pi using only a single GPIO pin, and you&amp;rsquo;ll find many articles out there that describe how to do so.</description><content>&lt;p>The DS18B20 is a popular temperature sensor that uses the &lt;a href="https://en.wikipedia.org/wiki/1-Wire">1-Wire&lt;/a>
protocol for communication. Recent versions of the Linux kernel
include a kernel driver for this protocol, making it relatively
convenient to connect one or more of these devices to a Raspberry Pi
or similar device. 1-Wire devices can be daisy chained, so it is
possible to connect several devices to your Pi using only a single
GPIO pin, and you&amp;rsquo;ll find many articles out there that describe how to
do so.&lt;/p>
&lt;p>Occasionally, it may be necessary to have more than a single chain of
connected devices. For example, you may have reached the limits on
the size of your 1-Wire network, or you may simply need to route your
cables in a way that makes a single chain difficult. You can enable
&lt;em>multiple&lt;/em> 1-Wire buses on your Raspberry Pi to handle these
situations.&lt;/p>
&lt;p>For a single 1-Wire bus, you add the following to &lt;code>/boot/config.txt&lt;/code>:&lt;/p>
&lt;pre>&lt;code>dtoverlay=w1-gpio
&lt;/code>&lt;/pre>
&lt;p>This will enable the 1-Wire bus on GPIO 4. To enable &lt;em>multiple&lt;/em>
1-Wire buses, you will use multiple &lt;code>dtoverlay&lt;/code> statements and the
&lt;code>gpiopin&lt;/code> parameter to the &lt;code>w1-gpio&lt;/code> overlay. For example, to enable
1-Wire buses on GPIO 4 and GPIO 17, you would use:&lt;/p>
&lt;pre>&lt;code>dtoverlay=w1-gpio,gpiopin=4
dtoverlay=w1-gpio,gpiopin=17
&lt;/code>&lt;/pre>
&lt;p>In the picture at the top of this post, there are four DS18B20
sensors. Three are connected to the 1-Wire bus on GPIO 4, and one is
connected to the 1-Wire bus on GPIO 17. Looking in
&lt;code>/sys/bus/w1/devices&lt;/code>, I see two w1_bus_master devices (and the four
temperature sensors):&lt;/p>
&lt;pre>&lt;code>$ ls /sys/bus/w1/devices/
28-041722cbacff 28-0417231547ff w1_bus_master1
28-041722ce24ff 28-04172318c0ff w1_bus_master2
&lt;/code>&lt;/pre>
&lt;p>I can check the temperature on all four devices like this:&lt;/p>
&lt;pre>&lt;code>$ cat /sys/bus/w1/devices/28-*/w1_slave
50 01 4b 46 7f ff 0c 10 e8 : crc=e8 YES
50 01 4b 46 7f ff 0c 10 e8 t=21000
50 01 4b 46 7f ff 0c 10 e8 : crc=e8 YES
50 01 4b 46 7f ff 0c 10 e8 t=21000
57 01 4b 46 7f ff 0c 10 38 : crc=38 YES
57 01 4b 46 7f ff 0c 10 38 t=21437
57 01 4b 46 7f ff 0c 10 38 : crc=38 YES
57 01 4b 46 7f ff 0c 10 38 t=21437
&lt;/code>&lt;/pre>
&lt;p>You may have noted that there is also a DHT22 sensor in the picture.
Much like the 1-Wire overlay, the kernel driver for the DHT22 can be
associated with an arbitrary GPIO pin like this:&lt;/p>
&lt;pre>&lt;code>dtoverlay=dht11,gpiopin=27
&lt;/code>&lt;/pre></content></item><item><title>I2C on the Raspberry Pi</title><link>https://blog.oddbit.com/post/2013-03-12-i2c-on-the-raspberry/</link><pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-12-i2c-on-the-raspberry/</guid><description>I&amp;rsquo;ve set up my Raspberry Pi to communicate with my Arduino via I2C. The Raspberry Pi is a 3.3v device and the Arduino is a 5v device. While in general this means that you need to use a level converter when connecting the two devices, you don&amp;rsquo;t need to use a level converter when connecting the Arduino to the Raspberry Pi via I2C.
The design of the I2C bus is such that the only device driving a voltage on the bus is the master (in this case, the Raspberry Pi), via pull-up resistors.</description><content>&lt;p>I&amp;rsquo;ve set up my &lt;a href="http://www.raspberrypi.org/">Raspberry Pi&lt;/a> to communicate with my &lt;a href="http://www.arduino.cc/">Arduino&lt;/a> via
&lt;a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C&lt;/a>. The Raspberry Pi is a 3.3v device and the Arduino is a 5v
device. While in general this means that you need to use a level
converter when connecting the two devices, &lt;strong>you don&amp;rsquo;t need to use a
level converter when connecting the Arduino to the Raspberry Pi via
I2C.&lt;/strong>&lt;/p>
&lt;p>The design of the I2C bus is such that the only device driving a
voltage on the bus is the master (in this case, the Raspberry Pi), via
pull-up resistors. So when &amp;ldquo;idle&amp;rdquo;, the bus is pulled to 3.3v volts by
the Pi, which is perfectly safe for the Arduino (and compatible with
it&amp;rsquo;s 5v signaling). To transmit data on the bus, a device brings the
bus low by connecting it to ground. In other words, slave devices
&lt;em>never&lt;/em> drive the bus high. This means that the Raspberry Pi will
never see a 5v signal from the Arduino&amp;hellip;unless, of course, you make a
mistake and accidentally &lt;code>digitalWrite&lt;/code> a &lt;code>HIGH&lt;/code> value on one of the
Arduino&amp;rsquo;s &lt;code>I2C&lt;/code> pins. So don&amp;rsquo;t do that.&lt;/p>
&lt;p>Note that the built-in pull-up resistors are &lt;em>only&lt;/em> available on the
Pi&amp;rsquo;s I2C pins (Pins 3 (&lt;code>SDA&lt;/code>) and 5 (&lt;code>SCL&lt;/code>), aka BCM &lt;code>GPIO0&lt;/code> and
&lt;code>GPIO1&lt;/code> on a Rev. 1 board, &lt;code>GPIO2&lt;/code> and &lt;code>GPIOP3&lt;/code> on a Rev. 2 board):&lt;/p>
&lt;p>&lt;img src="raspberry-pi-i2c-pins.jpg" alt="Raspberry Pi Pins">&lt;/p>
&lt;p>On the Arduino Uno, the &lt;code>I2C&lt;/code> pins are pins &lt;code>A4&lt;/code> (&lt;code>SDA&lt;/code>) and &lt;code>A5&lt;/code>
(&lt;code>SCL&lt;/code>):&lt;/p>
&lt;p>&lt;img src="arduino-i2c-pins.jpg" alt="Arduino Uno Pins">&lt;/p>
&lt;p>For information about other boards and about the Arduino I2C API, see
the documentation for the &lt;a href="http://arduino.cc/en/Reference/Wire">Wire library&lt;/a>.&lt;/p></content></item><item><title>Interrupt driven GPIO with Python</title><link>https://blog.oddbit.com/post/2013-03-08-interrupt-driven-gpi/</link><pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-08-interrupt-driven-gpi/</guid><description>There are several Python libraries out there for interacting with the GPIO pins on a Raspberry Pi:
RPi.GPIO The WiringPi bindings for Python, and The Quick2Wire Python API (which depends on Python 3) All of them are reasonably easy to use, but the Quick2Wire API provides a uniquely useful feature: epoll-enabled GPIO interrupts. This makes it trivial to write code that efficiently waits for and responds to things like button presses.</description><content>&lt;p>There are several Python libraries out there for interacting with the
&lt;a href="https://en.wikipedia.org/wiki/General_Purpose_Input/Output">GPIO&lt;/a> pins on a Raspberry Pi:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pypi.python.org/pypi/RPi.GPIO">RPi.GPIO&lt;/a>&lt;/li>
&lt;li>The &lt;a href="https://github.com/WiringPi/WiringPi-Python">WiringPi&lt;/a> bindings for Python, and&lt;/li>
&lt;li>The &lt;a href="https://github.com/quick2wire/quick2wire-python-api">Quick2Wire&lt;/a> Python API (which depends on Python 3)&lt;/li>
&lt;/ul>
&lt;p>All of them are reasonably easy to use, but the Quick2Wire API
provides a uniquely useful feature: &lt;code>epoll&lt;/code>-enabled GPIO interrupts.
This makes it trivial to write code that efficiently waits for and
responds to things like button presses.&lt;/p>
&lt;p>The following simple example waits for a button press attached to
&lt;code>GPIO1&lt;/code> (but refer to the chart in &lt;a href="https://projects.drogon.net/raspberry-pi/wiringpi/pins/">this document&lt;/a> to see
exactly what that means; this is pin 12 on a Raspberry Pi v2 board)
and lights an LED attached to &lt;code>GPIO0&lt;/code> when the button is pressed:&lt;/p>
&lt;pre>&lt;code>#!/usr/bin/env python3
import select
from quick2wire.gpio import pins, In, Out, Rising, Falling, Both
button1 = pins.pin(0, direction=In, interrupt=Both)
led = pins.pin(1, direction=Out)
with button1,led:
epoll = select.epoll()
epoll.register(button1, select.EPOLLIN|select.EPOLLET)
while True:
events = epoll.poll()
for fileno, event in events:
if fileno == button1.fileno():
print('BUTTON 1!', button1.value)
led.value = button1.value
&lt;/code>&lt;/pre>
&lt;p>There is also a &lt;code>Selector&lt;/code> class that makes the &lt;code>epoll&lt;/code> interface a
little easier to use. The following code is equivalent to the above
&lt;code>epoll&lt;/code> example:&lt;/p>
&lt;pre>&lt;code>#!/usr/bin/env python3
from quick2wire.gpio import pins, In, Out, Both
from quick2wire.selector import Selector
button1 = pins.pin(0, direction=In, interrupt=Both)
led = pins.pin(1, direction=Out)
with button1, led, Selector(1) as selector:
selector.add(button1)
while True:
selector.wait()
if selector.ready == button1:
print('BUTTON 1!', button1.value)
led.value = button1.value
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>selector&lt;/code> module includes a &lt;code>Timer&lt;/code> class that lets you add
one-shot or repeating timers to a &lt;code>Selector&lt;/code>. The following example
will light the LED for one second after the button is pressed, unless
the button is pressed again, in which case the LED will go out
immediately:&lt;/p>
&lt;pre>&lt;code>#!/usr/bin/env python3
from quick2wire.gpio import pins, In, Out, Both
from quick2wire.selector import Selector, Timer
button1 = pins.pin(0, direction=In, interrupt=Both)
led = pins.pin(1, direction=Out)
active = False
with button1, led, \
Selector(1) as selector, \
Timer(offset=2) as timer:
selector.add(button1)
selector.add(timer)
while True:
selector.wait()
if selector.ready == button1:
print('BUTTON 1!', button1.value, active)
if button1.value:
if active:
active = False
led.value = 0
timer.stop()
else:
active = True
led.value = 1
timer.start()
if selector.ready == timer:
if active:
active = False
led.value = 0
&lt;/code>&lt;/pre>
&lt;p>All of these examples rely on Python&amp;rsquo;s &lt;a href="http://docs.python.org/3/reference/compound_stmts.html#the-with-statement">with statement&lt;/a>. If you&amp;rsquo;re
unfamiliar with &lt;code>with&lt;/code>, you can find more information &lt;a href="http://docs.python.org/3/reference/compound_stmts.html#the-with-statement">here&lt;/a>.&lt;/p></content></item><item><title>Controlling a servo with your Arduino</title><link>https://blog.oddbit.com/post/2013-03-07-controlling-a-servo/</link><pubDate>Thu, 07 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.oddbit.com/post/2013-03-07-controlling-a-servo/</guid><description>I&amp;rsquo;ve recently started playing with an Arduino kit I purchased a year ago (and only just now got around to unboxing). I purchased the kit from SparkFun, and it includes a motley collection of resistors, LEDs, a motor, a servo, and more.
I was fiddling around with this exercise, which uses the SoftwareServo library to control a servo. Using this library, you just pass it an angle and the library takes care of everything else, e.</description><content>&lt;p>I&amp;rsquo;ve recently started playing with an &lt;a href="http://arduino.cc/">Arduino&lt;/a> kit I purchased a year
ago (and only just now got around to unboxing). I purchased the kit
from &lt;a href="https://www.sparkfun.com/">SparkFun&lt;/a>, and it includes a motley collection of resistors,
LEDs, a motor, a servo, and more.&lt;/p>
&lt;p>I was fiddling around with &lt;a href="http://oomlout.com/a/products/ardx/circ-04/">this exercise&lt;/a>, which uses the
&lt;code>SoftwareServo&lt;/code> library to control a servo. Using this library,
you just pass it an angle and the library takes care of everything
else, e.g. to rotate to 90 degrees you would do this:&lt;/p>
&lt;pre>&lt;code>myservo.write(90);
&lt;/code>&lt;/pre>
&lt;p>The exercise suggests trying to control the servo without using the
library:&lt;/p>
&lt;blockquote>
&lt;p>While it is easy to control a servo using the Arduino’s included
library sometimes it is fun to figure out how to program something
yourself. Try it. We’re controlling the pulse directly so you could
use this method to control servos on any of the Arduino’s 20
available pins (you need to highly optimize this code before doing
that).&lt;/p>
&lt;/blockquote>
&lt;p>It took me a few tries, and it looks as if the upper and lower limits
for the servo pulses given in that documentation may not be 100%
accurate. This is what I finally came with. As an added bonus, it
writes position information to the serial port:&lt;/p>
&lt;pre>&lt;code>int incomingByte = 0;
int servo0 = 600;
int servo180 = 2100;
int inc = 20;
int pos = servo0;
int servoPin = 9;
int pulseInterval=2000;
void setup() {
Serial.begin(9600); // opens serial port, sets data rate to 9600 bps
pinMode(servoPin, OUTPUT);
}
void loop() {
int i;
pos += inc;
if (pos &amp;gt; servo180) {
Serial.println(&amp;quot;REVERSE!&amp;quot;);
pos = servo180;
inc *= -1;
delay(500);
} else if (pos &amp;lt; servo0) {
Serial.println(&amp;quot;FORWARD!&amp;quot;);
pos = servo0;
inc *= -1;
delay(500);
}
Serial.print(&amp;quot;pos = &amp;quot;);
Serial.println(pos, DEC);
digitalWrite(servoPin, HIGH);
delayMicroseconds(pos);
digitalWrite(servoPin, LOW);
delay(20);
}
&lt;/code>&lt;/pre>
&lt;p>Under Linux or OS X, you could view the serial output using &lt;code>screen&lt;/code>
like this:&lt;/p>
&lt;pre>&lt;code>screen /dev/tty.usbmodemfd12441 9600
&lt;/code>&lt;/pre></content></item></channel></rss>