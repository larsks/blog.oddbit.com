<!doctype html><html lang=en><head><title>Docker networking with dedicated network containers :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The current version of Docker has a very limited set of networking options:
bridge &ndash; connect a container to the Docker bridge host &ndash; run the container in the global network namespace container:xxx &ndash; connect a container to the network namespace of another container none &ndash; do not configure any networking If you need something more than that, you can use a tool like pipework to provision additional network interfaces inside the container, but this leads to a synchronization problem: pipework can only be used after your container is running. This means that when starting your container, you must have logic that will wait until the necessary networking is available before starting your service.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Docker networking with dedicated network containers"><meta property="og:description" content="The current version of Docker has a very limited set of networking options:
bridge &ndash; connect a container to the Docker bridge host &ndash; run the container in the global network namespace container:xxx &ndash; connect a container to the network namespace of another container none &ndash; do not configure any networking If you need something more than that, you can use a tool like pipework to provision additional network interfaces inside the container, but this leads to a synchronization problem: pipework can only be used after your container is running. This means that when starting your container, you must have logic that will wait until the necessary networking is available before starting your service.
"><meta property="og:url" content="https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2014-10-06 00:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2014-10-06-docker-networking-with-dedicat/>Docker networking with dedicated network containers</a></h1><div class=post-meta><time class=post-date>2014-10-06&nbsp;[Updated: 2023-02-16]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/networking/>networking</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;</span><div class=post-content><div><p>The current version of Docker has a very limited set of networking
options:</p><ul><li><code>bridge</code> &ndash; connect a container to the Docker bridge</li><li><code>host</code> &ndash; run the container in the global network namespace</li><li><code>container:xxx</code> &ndash; connect a container to the network namespace of
another container</li><li><code>none</code> &ndash; do not configure any networking</li></ul><p>If you need something more than that, you can use a tool like
<a href=https://github.com/jpetazzo/pipework>pipework</a> to provision additional network interfaces inside the
container, but this leads to a synchronization problem: <code>pipework</code> can
only be used after your container is running. This means that when
starting your container, you must have logic that will wait until the
necessary networking is available before starting your service.</p><p>The <a href=https://github.com/GoogleCloudPlatform/kubernetes>kubernetes</a> project uses a clever solution to this problem:</p><p>Begin by starting a no-op container &ndash; that is, a container that does
not run any services &ndash; with <code>--net=none</code>. It needs to run
<em>something</em>; otherwise it will exit. The <code>kubernetes/pause</code> image
implements an extremely minimal &ldquo;do nothing but wait&rdquo; solution.</p><p>Once you have this no-op container running, you can set up the
corresponding network namespace to meet your requirements. For
example, you can create a <code>veth</code> device pair and place one end in the
interface and attach another to a bridge on your system. <a href=https://github.com/jpetazzo/pipework>Pipework</a>
can help with this, but you can also perform all the <a href=https://blog.oddbit.com/post/2014-08-11-four-ways-to-connect-a-docker/>changes by
hand</a></p><p>Once your networking is configured, start your actual service
container with <code>--net=container:&lt;id-of-noop-container></code>. Your service
container will start with your configured network environment.</p><p>You could, I suppose, decide to link <em>every</em> service container with
it&rsquo;s own network container, but that would get messy. Kubernetes
groups containers together into &ldquo;pods&rdquo;, in which all containers in a
pod share the same network namespace, which reduces the number of
&ldquo;networking containers&rdquo; necessary for services that have the same
networking requirements.</p><p>This solution &ndash; linking your service container with a no-op container
used to implement networking &ndash; solves the problems identified at the
beginning of this post: because you can perform all your network
configuration prior to starting your service, your service container
does not need any special logic to deal with interfaces that will be
created after the container starts. The networking will already be
in place when the service starts.</p><p>Docker issue <a href=https://github.com/docker/docker/issues/7455>7455</a> proposes a docker-native solution that would
accomplish largely the same thing without requiring the separate
networking container (by permitting you to pre-configure a network
namespace and then pass that to docker using something like
<code>--net=netns:&lt;name-of-network-namespace></code>).</p></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>