<!doctype html><html lang=en><head><title>Booting cloud images with libvirt :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Most major distributions now provide &ldquo;cloud-enabled&rdquo; images designed for use in cloud environments like OpenStack and AWS. These images are usually differentiated by (a) being relatively small, and (b) running cloud-init at boot to perform initial system configuration tasks using metadata provided by the cloud environment.
Because of their small size and support for automatic configuration (including such useful tasks as provisioning ssh keys), these images are attractive for use outside of a cloud environment. Unfortunately, when people first try to boot them they are met with frustration as first the image takes forever to boot as it tries to contact a non-existent metadata service, and then when it finally does boot they are unable to log in because the images typically only support key-based login.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2015-03-10-booting-cloud-images-with-libv/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Booting cloud images with libvirt"><meta property="og:description" content="Most major distributions now provide &ldquo;cloud-enabled&rdquo; images designed for use in cloud environments like OpenStack and AWS. These images are usually differentiated by (a) being relatively small, and (b) running cloud-init at boot to perform initial system configuration tasks using metadata provided by the cloud environment.
Because of their small size and support for automatic configuration (including such useful tasks as provisioning ssh keys), these images are attractive for use outside of a cloud environment. Unfortunately, when people first try to boot them they are met with frustration as first the image takes forever to boot as it tries to contact a non-existent metadata service, and then when it finally does boot they are unable to log in because the images typically only support key-based login.
"><meta property="og:url" content="https://blog.oddbit.com/post/2015-03-10-booting-cloud-images-with-libv/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2015-03-10 00:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-03-10-booting-cloud-images-with-libv/>Booting cloud images with libvirt</a></h1><div class=post-meta><time class=post-date>2015-03-10&nbsp;[Updated: 2023-02-16]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/fedora/>fedora</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/cloud-init/>cloud-init</a>&nbsp;</span><div class=post-content><div><p>Most major distributions now provide &ldquo;cloud-enabled&rdquo; images designed
for use in cloud environments like OpenStack and AWS. These images
are usually differentiated by (a) being relatively small, and (b) running
<a href=http://cloudinit.readthedocs.org/>cloud-init</a> at boot to perform initial system configuration tasks
using metadata provided by the cloud environment.</p><p>Because of their small size and support for automatic configuration
(including such useful tasks as provisioning ssh keys), these images
are attractive for use <em>outside</em> of a cloud environment.
Unfortunately, when people first try to boot them they are met with
frustration as first the image takes forever to boot as it tries to
contact a non-existent metadata service, and then when it finally does
boot they are unable to log in because the images typically only
support key-based login.</p><p>Fortunately, there are ways to work around these issues. In addition
to working with various network-accessible metadata services,
<a href=http://cloudinit.readthedocs.org/>cloud-init</a> is also able to read configuration information from an
attached [virtual] CD-ROM device. This is known as a &ldquo;configuration
drive&rdquo;, and it is relatively easy to create.</p><p>For this purpose, the simplest solution is use <a href=http://cloudinit.readthedocs.org/>cloud-init</a>&rsquo;s &ldquo;no
cloud&rdquo; data source. For this, we need to create an ISO filesystem
creating two files, <code>meta-data</code> and (optionally) <code>user-data</code>.</p><h2 id=the-meta-data-file>The meta-data file<a href=#the-meta-data-file class=hanchor arialabel=Anchor>#</a></h2><p>The <code>meta-data</code> file is effectively a YAML version of the data
typically available in the EC2 metadata service, and will look
something like this:</p><pre><code>instance-id: my-instance-id
local-hostname: my-host-name
</code></pre><p>The <code>instance-id</code> key is required. You can also include SSH public
keys in this file, like this:</p><pre><code>instance-id: my-instance-id
local-hostname: my-host-name
public-keys:
  - ssh-rsa AAAAB3NzaC1...
</code></pre><p>You will see examples that place ssh keys in the <code>user-data</code> file
instead, but I believe this is the wrong solution, since it forces you
to use a &ldquo;cloud-config&rdquo; format <code>user-data</code> file. Putting ssh keys
into the <code>meta-data</code> provides you more flexibility with your
<code>user-data</code> content.</p><h2 id=the-user-data-file>The user-data file<a href=#the-user-data-file class=hanchor arialabel=Anchor>#</a></h2><p>The <code>user-data</code> can be any of the various formats <a href=http://cloudinit.readthedocs.org/en/latest/topics/format.html>supported by
cloud-init</a>. For example, it could simply be a shell script:</p><pre><code>#!/bin/sh

yum -y install some-critical-package
</code></pre><p>Or it could be a <a href=http://cloudinit.readthedocs.org/en/latest/topics/examples.html#yaml-examples>cloud-config</a> YAML document:</p><pre><code>#cloud-config

write-files:
  - path: /etc/profile.d/gitaliases.sh
    content: |
      alias gc=&quot;git commit&quot;
      alias gcv=&quot;git commit --no-verify&quot;
runcmd:
  - setenforce 1
</code></pre><h2 id=putting-it-all-together>Putting it all together<a href=#putting-it-all-together class=hanchor arialabel=Anchor>#</a></h2><p>Once you have created your <code>meta-data</code> and <code>user-data</code> files, you can
create the configuration drive like this:</p><pre><code>genisoimage -o config.iso -V cidata -r -J meta-data user-data
</code></pre><p>To boot an instance using this configuration drive, you could do
something like this:</p><pre><code>virt-install -n example -r 512 -w network=default \
  --disk vol=default/fedora-21-cloud.qcow2 --import \
  --disk path=config.iso,device=cdrom
</code></pre><p>(This assumes, obviously, that you have an image named
<code>fedora-21-cloud.qcow2</code> available in libvirt&rsquo;s <code>default</code> storage
pool.)</p><h2 id=a-little-automation>A little automation<a href=#a-little-automation class=hanchor arialabel=Anchor>#</a></h2><p>I have written a <a href=https://github.com/larsks/virt-utils/blob/master/create-config-drive>create-config-drive</a> script that will automate
this process. With this script available, the above process is
simply:</p><pre><code>create-config-drive -k ~/.ssh/id_rsa.pub -u user-data config.iso
adding pubkey from /home/lars/.ssh/id_rsa.pub
adding user data from userdata
generating configuration image at config.iso
</code></pre></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>