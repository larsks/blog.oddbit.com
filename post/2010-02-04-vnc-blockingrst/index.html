<!doctype html><html lang=en><head><title>Blocking VNC with iptables :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="VNC clients use the RFB protocol to provide virtual display capabilities. The RFB protocol, as implemented by most clients, provides very poor authentication options. While passwords are not actually sent &amp;ldquo;in the clear&amp;rdquo;, it is possible to brute force them based on information available on the wire. The RFB 3.x protocol limits passwords to a maximum of eight characters, so the potential key space is relatively small.
It&amp;rsquo;s possible to securely connect to a remote VNC server by tunneling your connection using ssh port forwarding (or setting up some sort of SSL proxy)."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2010-02-04-vnc-blockingrst/><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Blocking VNC with iptables"><meta property="og:description" content="VNC clients use the RFB protocol to provide virtual display capabilities. The RFB protocol, as implemented by most clients, provides very poor authentication options. While passwords are not actually sent &amp;ldquo;in the clear&amp;rdquo;, it is possible to brute force them based on information available on the wire. The RFB 3.x protocol limits passwords to a maximum of eight characters, so the potential key space is relatively small.
It&amp;rsquo;s possible to securely connect to a remote VNC server by tunneling your connection using ssh port forwarding (or setting up some sort of SSL proxy)."><meta property="og:url" content="https://blog.oddbit.com/post/2010-02-04-vnc-blockingrst/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2010-02-04 00:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2010-02-04-vnc-blockingrst/>Blocking VNC with iptables</a></h1><div class=post-meta><time class=post-date>2010-02-04 ::
[Updated :: 2010-02-04]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/linux/>linux</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/classification/>classification</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/iptables/>iptables</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/rfb/>rfb</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/netfilter/>netfilter</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/vnc/>vnc</a>&nbsp;</span><div class=post-content><div><p>VNC clients use the <a href=http://www.realvnc.com/docs/rfbproto.pdf>RFB protocol</a> to provide virtual display capabilities. The RFB protocol, as implemented by most clients, provides very poor authentication options. While passwords are not actually sent &ldquo;in the clear&rdquo;, it is possible to brute force them based on information available on the wire. The RFB 3.x protocol limits passwords to a maximum of eight characters, so the potential key space is relatively small.</p><p>It&rsquo;s possible to securely connect to a remote VNC server by tunneling your connection using ssh port forwarding (or setting up some sort of SSL proxy). However, while this ameliorates the password problem, it still leaves a VNC server running that, depending on the local system configuration, may accept connections from all over the world. This leaves open the possibility that someone could brute force the password and gain access to the systsem. The problem is exacerbated if a user is running a passwordless VNC session.</p><p>My colleague and I looked into the options for blocking VNC connections using layer 7 packet classification. This means identifying the protocol in use by inspecting packet payloads, rather than relying exclusively on port numbers (this prevents clever or malicious users from circumventing the restrictions by running a service on a non-standard port). Unfortunately, the actual <a href=http://l7-filter.sourceforge.net/>l7 netfilter module</a> is not available in CentOS (or Fedora). But wait, all is not lost!</p><p>First, a brief digression into the RFB protocol used by VNC. After completing a standard TCP handshake, the client and server engage in a RFB handshake. The server first sents the string &ldquo;RFB " followed by the RFB protocol version supported by the server. The client responds with a similar message.</p><p>The initial handshake packet from the server:</p><pre><code>0000  00 00 0c 07 ac 34 00 21 86 14 e8 aa 08 00 45 00   .....4.!......E.
0010  00 40 e8 b7 40 00 40 06 b6 51 8c f7 34 e0 62 76   .@..@.@..Q..4.bv
0020  77 61 17 0d da ad ae 06 16 3f 22 48 92 cc 80 18   wa.......?&quot;H....
0030  00 5b 9b e1 00 00 01 01 08 0a e8 b1 fe 88 24 f1   .[............$.
0040  e3 56 52 46 42 20 30 30 33 2e 30 30 38 0a         .VRFB 003.008.
</code></pre><p>And the response from the client:</p><pre><code>0000  00 21 86 14 e8 aa 00 1a 30 4d 0c 00 08 00 45 40   .!......0M....E@
0010  00 40 e7 15 40 00 34 06 c3 b3 62 76 77 61 8c f7   .@..@.4...bvwa..
0020  34 e0 da ad 17 0d 22 48 92 cc ae 06 16 4b 80 18   4.....&quot;H.....K..
0030  ff ff 20 56 00 00 01 01 08 0a 24 f1 e3 57 e8 b1   .. V......$..W..
0040  fe 88 52 46 42 20 30 30 33 2e 30 30 38 0a         ..RFB 003.008.
</code></pre><p>Ergo: if we can match the string &ldquo;RFB " at the beginning of the TCP payload on inbound packets, we have a reliable way of blocking VNC packets ergardless of port.</p><p>Looking through the iptables man page, we find:</p><pre><code>u32
    U32  tests  whether quantities of up to 4 bytes extracted from
    a packet have specified values. The specification of what to
    extract is  general enough to find data at given offsets from
    tcp headers or payloads.
</code></pre><p>This looks especially appropriate, since our target match is exactly four bytes. Unfortunately, the syntax of the u32 module is a little baroque:</p><pre><code>Example:

       match IP packets with total length &gt;= 256
       The IP header contains a total length field in bytes 2-3.

       --u32 &quot;0 &amp; 0xFFFF = 0x100:0xFFFF&quot;
</code></pre><p>Fortunately, the internet is our friend:</p><blockquote><p><a href=http://www.stearns.org/doc/iptables-u32.v0.1.7.html>http://www.stearns.org/doc/iptables-u32.v0.1.7.html</a></p></blockquote><p>This document provides a number of recipes designed for use with u32 module, including one that matches content at the beginning of the TCP payload. This gives us, ultimately:</p><pre><code>iptables -A INPUT -p tcp \
  -m connbytes --connbytes 0:1024 \
    --connbytes-dir both --connbytes-mode bytes \
  -m state --state ESTABLISHED \
  -m u32 --u32 &quot;0&gt;&gt;22&amp;0x3C@ 12&gt;&gt;26&amp;0x3C@ 0=0x52464220&quot; \
  -j REJECT --reject-with tcp-reset
</code></pre><p>This means:</p><ul><li>Match tcp packets only (-p tcp)</li><li>Match only during the first 1024 bytes of the connection (-m connbytes &ndash;connbytes 0:1024 &ndash;connbytes-dir both &ndash;connbytes-mode bytes)</li><li>Match only ESTABLISHED connections (-m state &ndash;state ESTABLISHED)</li><li>Match bytes &ldquo;0x52464240&rdquo; (&ldquo;RFB &ldquo;) at the beginning of the TCP payload (-m u32 &ndash;u32 &ldquo;0&#187;22&0x3C@ 12&#187;26&0x3C@ 0=0x52464220&rdquo;)</li><li>Upon a match, force-close the connection with a RST packet. (-j REJECT &ndash;reject-with tcp-reset)</li></ul><p>With this rule in place, all unenrypted VNC connections will be forcefully disconnected by the server.</p><p>Our original plan had been to try redirecting VNC traffic so that we could display a big &ldquo;DON&rsquo;T DO THAT&rdquo; message, but this isn&rsquo;t possible &ndash; by the time we match the client payload, the connection has already been established and is not amendable to redirection.</p><h1 id=update>Update<a href=#update class=hanchor arialabel=Anchor>&#8983;</a></h1><p>We modified this rule to use the iptables string module to make the match more specific to further reduce the chances of false positives. The rule now looks like this:</p><pre><code>iptables -A INPUT -p tcp \
  -m connbytes --connbytes 0:1024 \
    --connbytes-dir both --connbytes-mode bytes \
  -m state --state ESTABLISHED \
  -m u32 --u32 &quot;0&gt;&gt;22&amp;0x3C@ 12&gt;&gt;26&amp;0x3C@ 0=0x52464220&quot; \
  -m string --algo kmp --string &quot;RFB 003.&quot; --to 130 \
  -j REJECT --reject-with tcp-reset
</code></pre><p>We thought about using the string module exclusively, but unlike the u32 module it is not possible to anchor the string match to the beginning of the TCP payload (since the ip and tcp headers may both be variable length).</p></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script>
<script src=/js/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>