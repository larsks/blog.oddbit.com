<!doctype html><html lang=en><head><title>OpenStack, Containers, and Logging :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="I&amp;rsquo;ve been thinking about logging in the context of OpenStack and containerized service deployments. I&amp;rsquo;d like to lay out some of my thoughts on this topic and see if people think I am talking crazy or not.
There are effectively three different mechanisms that an application can use to emit log messages:
Via some logging-specific API, such as the legacy syslog API By writing a byte stream to stdout/stderr By writing a byte stream to a file A substantial advantage to the first mechanism (using a logging API) is that the application is logging messages rather than bytes."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2017-06-14-openstack-containers-and-loggi/><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="OpenStack, Containers, and Logging"><meta property="og:description" content="I&amp;rsquo;ve been thinking about logging in the context of OpenStack and containerized service deployments. I&amp;rsquo;d like to lay out some of my thoughts on this topic and see if people think I am talking crazy or not.
There are effectively three different mechanisms that an application can use to emit log messages:
Via some logging-specific API, such as the legacy syslog API By writing a byte stream to stdout/stderr By writing a byte stream to a file A substantial advantage to the first mechanism (using a logging API) is that the application is logging messages rather than bytes."><meta property="og:url" content="https://blog.oddbit.com/post/2017-06-14-openstack-containers-and-loggi/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2017-06-14 00:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2017-06-14-openstack-containers-and-loggi/>OpenStack, Containers, and Logging</a></h1><div class=post-meta><time class=post-date>2017-06-14 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/logging/>logging</a>&nbsp;</span><div class=post-content><div><p>I&rsquo;ve been thinking about logging in the context of OpenStack and containerized service deployments. I&rsquo;d like to lay out some of my thoughts on this topic and see if people think I am talking crazy or not.</p><p>There are effectively three different mechanisms that an application can use to emit log messages:</p><ul><li>Via some logging-specific API, such as the legacy syslog API</li><li>By writing a byte stream to stdout/stderr</li><li>By writing a byte stream to a file</li></ul><p>A substantial advantage to the first mechanism (using a logging API) is that the application is logging <em>messages</em> rather than <em>bytes</em>. This means that if you log a message containing embedded newlines (e.g., python or java tracebacks), you can collect that as a single message rather than having to impose some sort of structure on the byte stream after the fact in order to reconstruct those message.</p><p>Another advantage to the use of a logging API is that whatever is receiving logs from your application may be able to annotate the message in various interesting ways.</p><h2 id=requirements>Requirements<a href=#requirements class=hanchor arialabel=Anchor>&#8983;</a></h2><p>We&rsquo;re probably going to need to support all three of the above mechanisms. Some applications (such as <code>haproxy</code>) will only log to syslog. Others may only log to files (such as <code>mariadb</code>), and still others may only log to stdout.</p><h2 id=comparing-different-log-mechanisms>Comparing different log mechanisms<a href=#comparing-different-log-mechanisms class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=logging-via-syslog>Logging via syslog<a href=#logging-via-syslog class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In RHEL, the <code>journald</code> process is what listens to <code>/dev/log</code>. If you bind mount journald&rsquo;s <code>/dev/log</code> inside a container and then run the following Python code inside that container&mldr;</p><pre><code>import logging
import logging.handlers

handler = logging.handlers.SysLogHandler(address='/dev/log')
log = logging.getLogger(__name__)
log.setLevel('DEBUG')
log.addHandler(handler)

log.warning('This is a test')
</code></pre><p>&mldr;you will find that your simple log message has been annotated with
a variety of useful metadata (the output below is the result of
running <code>journalctl -o verbose ...</code>):</p><pre><code>Wed 2017-06-14 12:35:57.577061 EDT [s=dc1dd9d61cf045e991f265aa17c5af03;i=6eb6e;b=0d9dc78871c34f43a4a6c27f43cf4167;m=a171206ec6;t=551ee258c6492;x=4e3c71faa52ba9d8]
    _BOOT_ID=0d9dc78871c34f43a4a6c27f43cf4167
    _MACHINE_ID=229916fba5b54252ad4d08efbc581213
    _HOSTNAME=lkellogg-pc0dzzve
    _UID=0
    _GID=0
    _SYSTEMD_SLICE=-.slice
    _TRANSPORT=syslog
    PRIORITY=4
    SYSLOG_FACILITY=1
    _EXE=/usr/bin/python3.5
    _CAP_EFFECTIVE=a80425fb
    _SELINUX_CONTEXT=system_u:system_r:unconfined_service_t:s0
    _COMM=python3
    MESSAGE=This is a test
    _PID=13849
    _CMDLINE=python3 logtest.py
    _SYSTEMD_CGROUP=/docker/7ed1e97d5bb4076caf99393ae3f88b07102a26b0ade2176ed07890bee9a84d24
    _SOURCE_REALTIME_TIMESTAMP=1497458157577061
</code></pre><p>There are several items of interest there:</p><ul><li>A high resolution timestamp</li><li>The kernel cgroup, which corresponds to the docker container id and thus uniquely identifies the container that originated the message</li><li>The executable path inside the container that generated the message</li><li>The machine id, which uniquely identifies the host</li></ul><p>By logging via syslog you have removed the necessity of either (a) handling log rotation in your application or (b) handling log rotation in your container or (c) having to communicate log rotation configuration from the container to the host. Additionally, you can rely on journald to take care of rate limiting and log size management to prevent a broken application from performing a local DOS of the server.</p><h3 id=logging-via-stdoutstderr>Logging via stdout/stderr<a href=#logging-via-stdoutstderr class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Applications that write a byte stream to stdout/stderr will have their output handled by the Docker log driver. If we run Docker with the <code>journald</code> log driver (using the <code>--log-driver=journald</code> option to the Docker server), then Docker will add metadata lines read from stdout/stderr. For example, if we run&mldr;</p><pre><code>docker run fedora echo This is a test.
</code></pre><p>&mldr;then our journal will contain:</p><pre><code>Wed 2017-06-14 12:46:45.511515 EDT [s=dc1dd9d61cf045e991f265aa17c5af03;i=6ee72;b=0d9dc78871c34f43a4a6c27f43cf4167;m=a197bf222b;t=551ee4c2b17f7;x=e7c1a220c93ef3cf]
    _BOOT_ID=0d9dc78871c34f43a4a6c27f43cf4167
    _MACHINE_ID=229916fba5b54252ad4d08efbc581213
    _HOSTNAME=lkellogg-pc0dzzve
    PRIORITY=6
    _TRANSPORT=journal
    _UID=0
    _GID=0
    _CAP_EFFECTIVE=3fffffffff
    _SYSTEMD_SLICE=system.slice
    _SELINUX_CONTEXT=system_u:system_r:unconfined_service_t:s0
    _COMM=dockerd
    _EXE=/usr/bin/dockerd
    _SYSTEMD_CGROUP=/system.slice/docker.service
    _SYSTEMD_UNIT=docker.service
    _PID=14309
    _CMDLINE=/usr/bin/dockerd -G docker --dns 172.23.254.1 --log-driver journald -s overlay2
    MESSAGE=This is a test.
    CONTAINER_NAME=happy_euclid
    CONTAINER_TAG=82b87e8902e8
    CONTAINER_ID=82b87e8902e8
    CONTAINER_ID_FULL=82b87e8902e8ac36f3365012ef10c66444fbb8c00e8cec7d7c2a14c05b054127
</code></pre><p>Like the messages logged via syslog, this also containers information that identifies the source container. It does not identify the particular binary responsible for emitting the message.</p><h3 id=logging-to-a-file>Logging to a file<a href=#logging-to-a-file class=hanchor arialabel=Anchor>&#8983;</a></h3><p>When logging to a file, the system is unable to add any metadata for us automatically. We can derive similar information by logging to a container-specific location (<code>/var/log/CONTAINERNAME/...</code>, for example), or by configuring our application to include specific information in the log messages, but ultimately this is the least information-rich mechanism available to us. Furthermore, it necessitates that we configure some sort of container-aware log rotation strategy to avoid eating up all the available disk space over time.</p><h2 id=log-collection>Log collection<a href=#log-collection class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Our goal is not simply to make log messages available locally. In
general, we also want to aggregate log messages from several machines
into a single location where we can perform various sorts of queries,
analysis, and visualization. There are a number of solutions in place
for getting logs off a local server to a central collector, including both <a href=http://www.fluentd.org/>fluentd</a> and <a href=http://www.rsyslog.com/>rsyslog</a>.</p><p>In the context of the above discussion, it turns out that <code>rsyslog</code> has some very desirable features. In particular, the <a href=http://www.rsyslog.com/doc/v8-stable/configuration/modules/imjournal.html>imjournal</a> input module has support for reading structured messages from journald and exporting those to a remote collector (such as <a href=https://www.elastic.co/>ElasticSearch</a>) with their structure intact. Fluentd does not ship with journald support as a core plugin.</p><p>Rsyslog version 8.x and later have a rich language for filtering, annotating, and otherwise modifying log messages that would allow us to do things such as add host-specific tags to messages, normalize log messages from applications with poorly designed log messages, and perform other transformations before sending them on to a remote collector.</p><p>For example, we would ensure that messages from containerized services logged via syslog <em>or</em> via stdout/stderr have a <code>CONTAINER_ID_FULL</code> field with something like the following:</p><pre><code>if re_match($!_SYSTEMD_CGROUP, &quot;^/docker/&quot;) then {
        set $!CONTAINER_ID_FULL = re_extract($!_SYSTEMD_CGROUP, &quot;^/docker/(.*)&quot;, 0, 1, &quot;unknown&quot;);
}
</code></pre><p>This matches the <code>_SYSTEMD_CGROUP</code> field of the message, extracts the container id, and uses that to set the <code>CONTAINER_ID_FULL</code> property on the message.</p><h2 id=recommendations>Recommendations<a href=#recommendations class=hanchor arialabel=Anchor>&#8983;</a></h2><ol><li>Provide a consistent logging environment to containerized services. Provide every container both with <code>/dev/log</code> and a container-specific host directory mounted on <code>/var/log</code>.</li><li>For applications that support logging to syslog (such as all consumers of <code>oslo.log</code>), configure them to log exclusively via syslog.</li><li>For applications that are unable to log via syslog but are able to log to stdout/stderr, ensure that Docker is using the <code>journald</code> log driver.</li><li>For applications that can only log to files, configure rsyslog on the host to read those files using the <a href=http://www.rsyslog.com/doc/v8-stable/configuration/modules/imfile.html>imfile</a> input plugin.</li><li>Use rsyslog on the host to forward structured messages to a remote collector.</li></ol></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>