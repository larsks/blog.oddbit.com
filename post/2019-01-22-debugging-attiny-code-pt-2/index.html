<!doctype html><html lang=en><head><title>Debugging attiny85 code, part 2: Automating GDB with scripts :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This is the second of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Debugging attiny85 code, part 2: Automating GDB with scripts"><meta property="og:description" content="This is the second of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running."><meta property="og:url" content="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2019-01-22 00:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/>Debugging attiny85 code, part 2: Automating GDB with scripts</a></h1><div class=post-meta><time class=post-date>2019-01-22 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/attiny85/>attiny85</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/avr/>avr</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/gdb/>gdb</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/simavr/>simavr</a>&nbsp;</span><div class=post-content><div><p>This is the second of three posts about using <code>gdb</code> and <code>simavr</code> to debug AVR code. The complete series is:</p><ul><li><p><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/>Part 1: Using GDB</a></p><p>A walkthrough of using GDB to manually inspect the behavior of our code.</p></li><li><p><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/>Part 2: Automating GDB with scripts</a></p><p>Creating GDB scripts to automatically test the behavior of our code.</p></li><li><p><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/>Part 3: Tracing with simavr</a></p><p>Using <code>simavr</code> to collect information about the state of microcontroller pins while our code is running.</p></li></ul><h2 id=prerequisites>Prerequisites<a href=#prerequisites class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In these posts, I will be referencing the code from my <a href=https://github.com/larsks/pipower>pipower</a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:</p><pre><code>git clone https://github.com/larsks/pipower
</code></pre><p>You&rsquo;ll also want to be familiar with the <a href=https://www.microchip.com/wwwproducts/en/ATtiny85>attiny85</a> or a similar AVR microcontroller, since I&rsquo;ll be referring to register names (like <code>PORTB</code>) without additional explanation.</p><h2 id=goals>Goals<a href=#goals class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In <a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/>the first post</a> on this topic, we looked at how one can use <code>gdb</code> and <a href=https://github.com/buserror/simavr>simavr</a> to debug your attiny85 (or other AVR code) without flashing it to a device. In this post, I would like to extend that by looking at how we can automate some aspects of the debugging process.</p><h2 id=sending-commands-to-gdb>Sending commands to gdb<a href=#sending-commands-to-gdb class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In the previous post, we were entering commands into <code>gdb</code> manually. It is also possible to provide <code>gdb</code> with a script of commands to execute. Let&rsquo;s assume we have a file that contains the following commands:</p><pre><code>file pipower.elf
target remote :1234
load
</code></pre><p>There are a few different mechanisms available for passing these commands to <code>gdb</code>. Naively we can simply redirect <code>stdin</code>:</p><pre><code>$ avr-gdb &lt; commands.gdb
GNU gdb (GDB) 8.1
[...]
(gdb) Reading symbols from pipower.elf...done.
(gdb) Remote debugging using :1234
0x00000000 in __vectors ()
(gdb) Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb) quit
A debugging session is active.

        Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n) [answered Y; input not from terminal]
Detaching from program: /home/lars/projects/pipower/sim/pipower.elf, Remote target
</code></pre><p>This will work fine in situations in which you expect <code>gdb</code> to run with no user interaction, but in this particular example, that makes our command file useless: while <code>gdb</code> does connect to <code>simavr</code>, it then exits immediately. This is where the <code>--command</code> (or <code>-x</code>) options comes in handy: that will read commands from a file and then return to the <code>(gdb)</code> prompt:</p><pre><code>$ avr-gdb -x commands.gdb
GNU gdb (GDB) 8.1
[...]
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 1293 KB/sec, 31 bytes/write.
(gdb)
</code></pre><p>This allows us to preload our debugging session with commands and then continue with an interactive session. You can achieve something similar using the <code>source</code> command in <code>gdb</code>:</p><pre><code>$ avr-gdb
GNU gdb (GDB) 8.1
[...]
(gdb) source commands.gdb
0x00000000 in __vectors ()
Loading section .text, size 0xa54 lma 0x0
Loading section .data, size 0x6 lma 0xa54
Start address 0x0, load size 2650
Transfer rate: 431 KB/sec, 31 bytes/write.
(gdb)
</code></pre><h2 id=conditional-and-temporary-breakpoints>Conditional and temporary breakpoints<a href=#conditional-and-temporary-breakpoints class=hanchor arialabel=Anchor>&#8983;</a></h2><p>There are several different ways to set breakpoints in <code>gdb</code>. The simplest is the <code>b</code> command, which sets a breakpoint at the given location. This simple breakpoint will trigger whenever execution reaches the given line of code. We can influence this behavior by setting a breakpoint condition, such as:</p><pre><code>b loop if state == STATE_POWEROFF2
</code></pre><p>This breakpoint will only trigger if the expression (<code>state == STATE_POWEROFF2</code>) evaluates to true.</p><p>Sometimes, we don&rsquo;t want a persistent breakpoint: we want the code to stop once at a given point, and then continue executing afterwards without stopping again at the same place. We can accomplish this by setting a temporary breakpoint using the <code>tb</code> command. If we were to write the previous example like this&mldr;</p><pre><code>tb loop if state == STATE_POWEROFF2
</code></pre><p>&mldr;then the code would stop <em>once</em> at the given breakpoint, but subsequently iterations of the loop would continue merrily on their way.</p><h2 id=defining-new-commands>Defining new commands<a href=#defining-new-commands class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The <code>gdb</code> scripting language permits us to create new commands with the <code>define</code> command. In the previous post, I simulated the passage of time by iterating through the main loop using a command such as <code>c 100</code>. This works, but isn&rsquo;t particularly accurate and may make it difficult if one wants to run for a specific amount of time (for example, to run out a timer). We can define a new <code>wait_for</code> command that will let us wait for a given number of milliseconds:</p><pre><code># wait for &lt;n&gt; milliseconds
define wait_for
    disable 1
    set $start_time = now
    tb loop if now == $start_time + $arg0
    c
    enable 1
end
</code></pre><p>The <code>disable 1</code> at the beginning is disabling breakpoint 1, which we assume is the breakpoint created by running <code>b loop</code> as in the <a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/>previous post</a>. We re-enable the breakpoint at the end of the definition.</p><p>This takes advantage of the fact that the code in <code>pipower.c</code> is explicitly updating a variable call <code>now</code> with the output of the <code>millis()</code> command, which counts milliseconds since the microprocessor started. We can store the current value of that variable in a <code>gdb</code> variable by using the <code>set</code> command:</p><pre><code>set $start_time = now
</code></pre><p>This allows us to create a temporary breakpoint with a break condition that makes use of that value:</p><pre><code>tb loop if now == $start_time + $arg0
</code></pre><p>This breakpoint will activate when the global <code>now</code> variable is equal to the value we saved in <code>$start_time</code> + whatever was passed as an argument to the <code>wait_for</code> command.</p><p>Since commands can call other commands, we can use the new <code>wait_for</code> command to create a new command that simulates a button press. For our purposes, a &ldquo;button press&rdquo; means that <code>PIN_POWER</code> goes low for 100ms and then goes high. We can simulate that like this:</p><pre><code>	define short_press
			set PINB=PINB &amp; ~(1&lt;&lt;PIN_POWER)
			wait_for 100
			set PINB=PINB | 1&lt;&lt;PIN_POWER
			c
	end
</code></pre><p>Recall that <code>c</code> means <code>continue</code>, which will cause the code to continue running until it hits a breakpoint.</p><h2 id=automated-testing-the-script>Automated testing: the script<a href=#automated-testing-the-script class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Using everything discussed above, we can put together something like the <a href=https://github.com/larsks/pipower/tree/master/sim/simulate.gdb>simulate.gdb</a> script included in the <code>sim</code> directory of the Pipower project.</p><p>We start by disabling pagination. This prevent <code>gdb</code> from stopping and asking us to &ldquo;press return to continue&rdquo;.</p><pre><code>set pagination off
</code></pre><p>We load our binary and connect to the simulator:</p><pre><code>file pipower.elf
target remote :1234
load
</code></pre><p>Next, we define a few helper functions to avoid repetitive code in the rest of the script:</p><pre><code>##
## Helper functions
##

# wait for &lt;n&gt; milliseconds
define wait_for
    disable 1
    set $start_time = now
    tb loop if now == $start_time + $arg0
    c
    enable 1
end

# simulate a short press of the power button
define short_press
    set PINB=PINB &amp; ~(1&lt;&lt;PIN_POWER)
    wait_for 100
    set PINB=PINB | 1&lt;&lt;PIN_POWER
    c
end

# log a message
define log
  printf &quot;\n* %s\n&quot;, $arg0
end

# run until we reach the given state
define run_until_state
    disable 1
    tb loop if $arg0 == state
    c
    enable 1
end
</code></pre><p>Prior to running the code, we a breakpoint on the <code>loop()</code> function:</p><pre><code>##
## Execution starts here
##

# set an initial breakpoint at the start of loop() and advance the program
# to that point
b loop
</code></pre><p>And then start things running. This will stop at the top of <code>loop()</code>:</p><pre><code>c
</code></pre><p>In order to see how things are progressing as the script runs, let&rsquo;s arrange to display the current value of the global <code>state</code> variable as well as the <code>PORTB</code> and <code>PINB</code> registers every time we hit a breakpoint:</p><pre><code># set up some information to display at each breakpoint
display state
display /t PORTB
display /t PINB
display
</code></pre><p>Now that our displays are setup, let&rsquo;s run the code for a bit and then set <code>PIN_USB</code> high (this would indicate that external power is available to our device):</p><pre><code># let the code advance for 100ms
wait_for 100

# enable external power
log &quot;setting PIN_USB&quot;
set PINB=PINB | 1&lt;&lt;PIN_USB
</code></pre><p>We&rsquo;ll use the <code>run_until_state</code> command that we defined earlier in the file to execute until we reach the <code>STATE_BOOTWAIT1</code> state:</p><pre><code>run_until_state STATE_BOOTWAIT1
wait_for 100
</code></pre><p>At this point, the code expects an attached Raspberry Pi to assert the <code>BOOT</code> signal by bringing <code>PIN_BOOT</code> low:</p><pre><code># assert BOOT
log &quot;resetting PIN_BOOT&quot;
set PINB=PINB &amp; ~(1&lt;&lt;PIN_BOOT)
run_until_state STATE_BOOT
</code></pre><p>Once the Pi has booted successfully and provided the <code>BOOT</code> signal to our code, we enter the <code>STATE_BOOT</code> state. Let&rsquo;s run in this state for a second&mldr;</p><pre><code>##
## ...the pi has booted...
##
wait_for 1000
</code></pre><p>&mldr;and then simulate a press of the power button:</p><pre><code># request a shutdown by pressing the power button
log &quot;pressing power button&quot;
short_press
</code></pre><p>Our code sets <code>PIN_SHUTDOWN</code> high, which would signal to an attached Pi that it should begin the shutdown process. The code enters the <code>STATE_SHUTDOWN1</code> state in which it waits for the Pi to signal successful shutdown by de-asserting <code>BOOT</code> by bringing <code>PIN_BOOT</code> high:</p><pre><code>run_until_state STATE_SHUTDOWN1

# de-assert BOOT
wait_for 100
log &quot;setting PIN_BOOT&quot;
set PINB=PINB | 1&lt;&lt;PIN_BOOT
</code></pre><p>Once we receive the successful shutdown signal, the code enters the poweroff phase, during which it will wait <code>TIMER_POWEROFF</code> milliseconds before cutting the power. Let&rsquo;s walk through the poweroff state transitions:</p><pre><code># step through state transitions until we reach
# STATE_IDLE2
run_until_state STATE_POWEROFF0
run_until_state STATE_POWEROFF1
run_until_state STATE_POWEROFF2
log &quot;entering idle mode&quot;
run_until_state STATE_IDLE0
run_until_state STATE_IDLE1
run_until_state STATE_IDLE2

wait_for 100
</code></pre><p>And finally force the code to exit:</p><pre><code>log &quot;setting quit flag&quot;
set state=STATE_QUIT
finish

disconnect
quit
</code></pre><h2 id=automated-testing-the-output>Automated testing: the output<a href=#automated-testing-the-output class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Running that script produces the following output, which lets us see the state transitions and pin values as the code is running:</p><pre><code>0x00000000 in __vectors ()
Loading section .text, size 0xa74 lma 0x0
Loading section .data, size 0x6 lma 0xa74
Start address 0x0, load size 2682
Transfer rate: 873 KB/sec, 31 bytes/write.
Breakpoint 1 at 0xb0: file ../pipower.c, line 116.

Breakpoint 1, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_START
2: /t PORTB = 10001
3: /t PINB = 10001
Temporary breakpoint 2 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 2, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10001

* setting PIN_USB
Temporary breakpoint 3 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 3, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 4 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 4, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_BOOTWAIT1
2: /t PORTB = 10101
3: /t PINB = 10111

* resetting PIN_BOOT
Temporary breakpoint 5 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 5, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 6 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 6, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111

* pressing power button
Temporary breakpoint 7 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 7, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 110

Breakpoint 1, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_BOOT
2: /t PORTB = 10101
3: /t PINB = 111
Temporary breakpoint 8 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 8, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_SHUTDOWN1

2: /t PORTB = 11101
3: /t PINB = 1111
Temporary breakpoint 9 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 9, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_SHUTDOWN1
2: /t PORTB = 11101
3: /t PINB = 1111

* setting PIN_BOOT
Temporary breakpoint 10 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 10, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_POWEROFF0
2: /t PORTB = 11101
3: /t PINB = 11111
Temporary breakpoint 11 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 11, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_POWEROFF1
2: /t PORTB = 10101
3: /t PINB = 10111
Temporary breakpoint 12 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 12, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_POWEROFF2
2: /t PORTB = 10101
3: /t PINB = 10111

* entering idle mode
Temporary breakpoint 13 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 13, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_IDLE0
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 14 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 14, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_IDLE1
2: /t PORTB = 10001
3: /t PINB = 10011
Temporary breakpoint 15 at 0xb0: file ../pipower.c, line 116.

Temporary breakpoint 15, loop () at ../pipower.c:116
116	    now = millis();
1: state = STATE_IDLE2
2: /t PORTB = 10001
3: /t PINB = 10011

* setting quit flag
main () at ../pipower.c:280
280	    while (state != STATE_QUIT) {
1: state = STATE_QUIT
2: /t PORTB = 10001
3: /t PINB = 10011
</code></pre></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>