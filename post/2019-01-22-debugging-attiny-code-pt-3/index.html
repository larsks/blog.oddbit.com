<!doctype html><html lang=en><head><title>Debugging attiny85 code, part 3: Tracing with simavr :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" This is the third of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Debugging attiny85 code, part 3: Tracing with simavr"><meta property="og:description" content=" This is the third of three posts about using gdb and simavr to debug AVR code. The complete series is:
Part 1: Using GDB
A walkthrough of using GDB to manually inspect the behavior of our code.
Part 2: Automating GDB with scripts
Creating GDB scripts to automatically test the behavior of our code.
Part 3: Tracing with simavr
Using simavr to collect information about the state of microcontroller pins while our code is running.
"><meta property="og:url" content="https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2019-01-22 00:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/>Debugging attiny85 code, part 3: Tracing with simavr</a></h1><div class=post-meta><time class=post-date>2019-01-22 ::
[Updated :: 2023-02-16]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/attiny85/>attiny85</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/avr/>avr</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/gdb/>gdb</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/simavr/>simavr</a>&nbsp;</span><div class=post-content><div><figure class=left><img src=pipower_trace.png></figure><p>This is the third of three posts about using <code>gdb</code> and <code>simavr</code> to debug AVR code. The complete series is:</p><ul><li><p><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-1/>Part 1: Using GDB</a></p><p>A walkthrough of using GDB to manually inspect the behavior of our code.</p></li><li><p><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/>Part 2: Automating GDB with scripts</a></p><p>Creating GDB scripts to automatically test the behavior of our code.</p></li><li><p><a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-3/>Part 3: Tracing with simavr</a></p><p>Using <code>simavr</code> to collect information about the state of microcontroller pins while our code is running.</p></li></ul><h2 id=prerequisites>Prerequisites<a href=#prerequisites class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In these posts, I will be referencing the code from my <a href=https://github.com/larsks/pipower>pipower</a> project that I discussed in [an earlier post][pipower-post]. If you want to follow along, start by cloning that repository:</p><pre><code>git clone https://github.com/larsks/pipower
</code></pre><p>You&rsquo;ll also want to be familiar with the <a href=https://www.microchip.com/wwwproducts/en/ATtiny85>attiny85</a> or a similar AVR microcontroller, since I&rsquo;ll be referring to register names (like <code>PORTB</code>) without additional explanation.</p><h2 id=goals>Goals<a href=#goals class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In the <a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/>previous post</a> we looked at we can automate <code>gdb</code> using scripts. In this post, we&rsquo;ll combine that with the tracing facilities offered by <code>simavr</code> in order to generate traces for pin values and state transitions while the code is running.</p><h2 id=preparing-your-code>Preparing your code<a href=#preparing-your-code class=hanchor arialabel=Anchor>&#8983;</a></h2><p>We need to embed some metadata in our code that provides <code>simavr</code> with information about what data we want to collect. We do this by adding some special code that will get embedded in the <code>.mmcu</code> section of the resulting ELF binary. You can see an example of this in <a href=https://github.com/larsks/pipower/blob/master/sim/simavr.c>sim/simavr.c</a> in the Pipower project:</p><pre><code>#include &lt;simavr/avr/avr_mcu_section.h&gt;
#include &quot;pins.h&quot;

extern uint8_t state;

/** Trace data to collect.
 *
 * We collect each bit of PORTB (inputs and outputs) separately. We also keep
 * track of the global state variable.
 */
const struct avr_mmcu_vcd_trace_t _mytrace[]  _MMCU_ = {
    { AVR_MCU_VCD_SYMBOL(&quot;PIN_POWER&quot;),    .mask = (1&lt;&lt;PIN_POWER),    .what = (void*)&amp;PINB,  },
    { AVR_MCU_VCD_SYMBOL(&quot;PIN_USB&quot;),      .mask = (1&lt;&lt;PIN_USB),      .what = (void*)&amp;PINB,  },
    { AVR_MCU_VCD_SYMBOL(&quot;PIN_EN&quot;),       .mask = (1&lt;&lt;PIN_EN),       .what = (void*)&amp;PORTB, },
    { AVR_MCU_VCD_SYMBOL(&quot;PIN_SHUTDOWN&quot;), .mask = (1&lt;&lt;PIN_SHUTDOWN), .what = (void*)&amp;PORTB, },
    { AVR_MCU_VCD_SYMBOL(&quot;PIN_BOOT&quot;),     .mask = (1&lt;&lt;PIN_BOOT),     .what = (void*)&amp;PINB,  },
    { AVR_MCU_VCD_SYMBOL(&quot;STATE&quot;),                                   .what = (void*)&amp;state, },
};
</code></pre><p>The <code>_mytrace</code> variable (the name is unimportant) is an array of <code>struct avr_mmcu_vcd_trace_t</code> records (the <code>_MMCU_</code> flag sets an attribute that will embed this data in the appropriate section of the ELF binary). Each record has the following fields:</p><ul><li><code>AVR_MCU_VCD_SYMBOL("...")</code> &ndash; this sets the name of a data series to collect.</li><li><code>.mask</code> (optional) &ndash; use this if you only want to collect certain bits. In this example, I am masking out all but a single bit for each pin. I&rsquo;m not using a mask for <code>state</code> because I want the actual integer value in that case.</li><li><code>.what</code> &ndash; this is the variable to collect. It can be pretty much anything that is in scope. Here, <code>PORTB</code> and <code>PINB</code> are the attiny85 input/output registers, and <code>state</code> is a global variable from <code>pipower.c</code></li></ul><p>You can build a version of the pipower code that includes this metadata by running, in the <code>sim/</code> directory:</p><pre><code>make TRACE=1
</code></pre><p>You can see the new <code>.mmcu</code> section of you inspect the section headers of <code>pipower.elf</code> using, e.g., <code>objdump</code>:</p><pre><code>$ objdump pipower.elf -h

pipower.elf:     file format elf32-little

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a74  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mmcu         000000de  00000a74  00000a74  00000b08  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
[...]
</code></pre><h2 id=gathering-trace-data>Gathering trace data<a href=#gathering-trace-data class=hanchor arialabel=Anchor>&#8983;</a></h2><p>To gather the trace data with <code>simavr</code>, we simply repeat the steps from the <a href=https://blog.oddbit.com/post/2019-01-22-debugging-attiny-code-pt-2/>previous post</a>:</p><ul><li>Start <code>simavr</code></li><li>Run our automated testing script (<code>simulate.gdb</code>)</li><li>Stop <code>simavr</code></li></ul><p>At the end of this process, we will find a new file in our current directory, <code>gtkwave_trace.vcd</code>. This is a <a href=https://en.wikipedia.org/wiki/Value_change_dump>value change dump</a> file, which is a standard format for representing digital signals over time.</p><h2 id=visualizing-the-trace-data>Visualizing the trace data<a href=#visualizing-the-trace-data class=hanchor arialabel=Anchor>&#8983;</a></h2><p>We can view the <code>.vcd</code> file using <a href=http://gtkwave.sourceforge.net/>gtkwave</a>. From the command line, you can run:</p><pre><code>gtkwave gtkwave_trace.vcd
</code></pre><p>This will bring up the main <code>gtkwave</code> window, which look like this:</p><figure class=left><img src=gtkwave-1.png></figure><p>Select <code>logic</code> in the SST (&ldquo;Signal Search Tree&rdquo;) pane. This will display the available signals in the next pane down. Select all the signals (click on the top one, then shift-click on the last one) and select &ldquo;Append&rdquo;. You should end up with a display that looks like this:</p><figure class=left><img src=gtkwave-2.png></figure><p>The graph is displaying our collected signal data, but the initial time scale isn&rsquo;t particularly useful. Select &ldquo;Time -> Zoom -> Zoom Best Fit&rdquo;; you should end up with something that looks like:</p><figure class=left><img src=gtkwave-3.png></figure><p>(Note that any time you resize the window you&rsquo;ll need to manually adjust the zoom level. You can use the menu item, or just press <code>CTRL</code>-<code>ALT</code>-<code>F</code>.)</p><p>You can now see a graph of how the various pins changed over the runtime of the program. This is a useful way to verify that the code is behaving as expected. In this case, I think the section just past the 1 second mark is interesting; you can see the power button press, followed by <code>PIN_SHUTDOWN</code> going high, then <code>PIN_BOOT</code> going high, and finally <code>PIN_EN</code> disabling power output after the 1 second timer expiry.</p><p>You&rsquo;ll note that the <code>state</code> information is displayed numerically, which isn&rsquo;t particularly helpful. We can fix that by setting up a &ldquo;Translate Filter File&rdquo;. Right click on the <code>STATE[7:0]</code> label in the &ldquo;Signals&rdquo; pane, then select &ldquo;Data Format -> Translate Filter File -> Enable and Select&rdquo;. In the &ldquo;Select Signal Filter&rdquo; window that pops up&mldr;</p><figure class=left><img src=gtkwave-4.png></figure><p>&mldr;select &ldquo;Add Filter to List&rdquo;. Browse to the <code>sim</code> directory of the <code>pipower</code> project, and select <code>state_filter.txt</code>. Now select that same file in the &ldquo;Filter Select&rdquo; list, then click OK. You should now see state names displayed in the graph:</p><figure class=left><img src=gtkwave-5.png></figure><hr><p>That&rsquo;s the end of this series of posts on debugging AVR code with <code>gdb</code> and <code>simavr</code>. I hope you found it useful!</p></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>