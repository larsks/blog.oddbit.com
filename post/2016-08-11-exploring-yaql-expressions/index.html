<!doctype html><html lang=en><head><title>Exploring YAQL Expressions :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The Newton release of Heat adds support for a yaql intrinsic function, which allows you to evaluate yaql expressions in your Heat templates. Unfortunately, the existing yaql documentation is somewhat limited, and does not offer examples of many of yaql&rsquo;s more advanced features.
I am working on a Fluentd composable service for TripleO. I want to allow each service to specify a logging source configuration fragment, for example:
parameters: NovaAPILoggingSource: type: json description: Fluentd logging configuration for nova-api. default: tag: openstack.nova.api type: tail format: | /(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d+) (?<pid>\d+) (?<priority>\S+) (?<message>.*)/ path: /var/log/nova/nova-api.log pos_file: /var/run/fluentd/openstack.nova.api.pos This generally works, but several parts of this fragment are going to be the same across all OpenStack services. I wanted to reduce the above to just the unique attributes, which would look something like:
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2016-08-11-exploring-yaql-expressions/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Exploring YAQL Expressions"><meta property="og:description" content="The Newton release of Heat adds support for a yaql intrinsic function, which allows you to evaluate yaql expressions in your Heat templates. Unfortunately, the existing yaql documentation is somewhat limited, and does not offer examples of many of yaql&rsquo;s more advanced features.
I am working on a Fluentd composable service for TripleO. I want to allow each service to specify a logging source configuration fragment, for example:
parameters: NovaAPILoggingSource: type: json description: Fluentd logging configuration for nova-api. default: tag: openstack.nova.api type: tail format: | /(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d+) (?<pid>\d+) (?<priority>\S+) (?<message>.*)/ path: /var/log/nova/nova-api.log pos_file: /var/run/fluentd/openstack.nova.api.pos This generally works, but several parts of this fragment are going to be the same across all OpenStack services. I wanted to reduce the above to just the unique attributes, which would look something like:
"><meta property="og:url" content="https://blog.oddbit.com/post/2016-08-11-exploring-yaql-expressions/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2016-08-11 00:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2016-08-11-exploring-yaql-expressions/>Exploring YAQL Expressions</a></h1><div class=post-meta><time class=post-date>2016-08-11&nbsp;[Updated: 2023-02-16]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openstack/>openstack</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/heat/>heat</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/hot/>hot</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/yaql/>yaql</a>&nbsp;</span><div class=post-content><div><p>The Newton release of <a href=https://wiki.openstack.org/wiki/Heat>Heat</a> adds support for a <a href=http://docs.openstack.org/developer/heat/template_guide/hot_spec.html#yaql>yaql</a>
intrinsic function, which allows you to evaluate <a href=https://yaql.readthedocs.io/en/latest/>yaql</a> expressions
in your Heat templates. Unfortunately, the existing yaql
documentation is somewhat limited, and does not offer examples of many
of yaql&rsquo;s more advanced features.</p><p>I am working on a <a href=http://www.fluentd.org/>Fluentd</a> composable service for <a href=https://wiki.openstack.org/wiki/TripleO>TripleO</a>. I
want to allow each service to specify a logging source configuration
fragment, for example:</p><pre><code>parameters:
  NovaAPILoggingSource:
    type: json
    description: Fluentd logging configuration for nova-api.
    default:
      tag: openstack.nova.api
      type: tail
      format: |
        /(?&lt;time&gt;\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}.\d+) (?&lt;pid&gt;\d+) (?&lt;priority&gt;\S+) (?&lt;message&gt;.*)/
      path: /var/log/nova/nova-api.log
      pos_file: /var/run/fluentd/openstack.nova.api.pos
</code></pre><p>This generally works, but several parts of this fragment are going to
be the same across all OpenStack services. I wanted to reduce the
above to just the unique attributes, which would look something like:</p><pre><code>parameters:
  NovaAPILoggingSource:
    type: json
    description: Fluentd logging configuration for nova-api.
    default:
      tag: openstack.nova.api
      path: /var/log/nova/nova-api.log
</code></pre><p>This would ultimately give me a list of dictionaries of the form:</p><pre><code>[
  {
    &quot;tag&quot;: &quot;openstack.nova.api&quot;,
    &quot;path&quot;: &quot;/var/log/nova/nova-api.log&quot;
  },
  {
    &quot;tag&quot;: &quot;openstack.nova.scheduler&quot;,
    &quot;path&quot;: &quot;/var/log/nova/nova-scheduler.log&quot;
  }
]
</code></pre><p>I want to iterate over this list, adding default values for attributes
that are not explicitly provided.</p><p>The yaql language has a <code>select</code> function, somewhat analagous to the
SQL <code>select</code> statement, that can be used to construct a new data
structure from an existing one. For example, given the above data in
a parameter called <code>sources</code>, I could write:</p><pre><code>outputs:
  sources:
    yaql:
      data:
        sources: {get_param: sources}
      expression: &gt;
        $.data.sources.select({
          'path' =&gt; $.path,
          'tag' =&gt; $.tag,
          'type' =&gt; $.get('type', 'tail')})
</code></pre><p>This makes use of the <code>.get</code> method to insert a default value of
<code>tail</code> for the <code>type</code> attribute for items that don&rsquo;t specify it
explicitly. This would produce a list that looks like:</p><pre><code>[
    {
        &quot;path&quot;: &quot;/var/log/nova/nova-api.log&quot;,
        &quot;tag&quot;: &quot;openstack.nova.api&quot;,
        &quot;type&quot;: &quot;tail&quot;
    },
    {
        &quot;path&quot;: &quot;/var/log/nova/nova-scheduler.log&quot;,
        &quot;tag&quot;: &quot;openstack.nova.scheduler&quot;,
        &quot;type&quot;: &quot;tail&quot;
    }
]
</code></pre><p>That works fine, but what if I want to parameterize the default value
such that it can be provided as part of the template? I wanted to be
able to pass the yaql expression something like this&mldr;</p><pre><code>outputs:
  sources:
    yaql:
      data:
        sources: {get_param: sources}
        default_type: tail
</code></pre><p>&mldr;and then within the yaql expression, insert the value of
<code>default_type</code> into items that don&rsquo;t provide an explicit value for the
<code>type</code> attribute.</p><p>This is trickier than it might sound at first because within the
context of the <code>select</code> method, <code>$</code> is bound to the <em>local</em> context,
which will be an individual item from the list. So while I can ask
for <code>$.path</code>, there&rsquo;s no way to refer to items from the top-level
context. Or is there?</p><p>The <a href=https://yaql.readthedocs.io/en/latest/getting_started.html#operators>operators</a> documentation for yaql mentions the &ldquo;context pass&rdquo;
operator, <code>-></code>, but doesn&rsquo;t provide any examples of how it can be
used. It turns out that this operator will be the key to our solution.
But before we look at that in more detail, we need to introduce the
<code>let</code> statement, which can be used to define variables. The <code>let</code>
statement isn&rsquo;t mentioned in the documentation at all, but it looks
like this:</p><pre><code>let(var =&gt; value, ...)
</code></pre><p>By itself, this isn&rsquo;t particularly useful. In fact, if you were to
type a bare <code>let</code> statement in a yaql evaluator, you would get an
error:</p><pre><code>yaql&gt; let(foo =&gt; 10, bar =&gt; 20)
Execution exception: &lt;yaql.language.contexts.Context object at 0x7fbaf9772e50&gt; is not JSON serializable
</code></pre><p>This is where the <code>-></code> operator comes into play. We use that to pass
the context created by the <code>let</code> statement into a yaql expression. For
example:</p><pre><code>yaql&gt; let(foo =&gt; 10, bar =&gt; 20) -&gt; $foo
10
yaql&gt; let(foo =&gt; 10, bar =&gt; 20) -&gt; $bar
20
</code></pre><p>With that in mind, we can return to our earlier task, and rewrite the
yaql expression like this:</p><pre><code>outputs:
  sources:
    yaql:
      data:
        sources: {get_param: sources}
        default_type: tail
      expression: &gt;
        let(default_type =&gt; $.data.default_type) -&gt;
        $.data.sources.select({
          'path' =&gt; $.path,
          'tag' =&gt; $.tag,
          'type' =&gt; $.get('type', $default_type)})
</code></pre><p>Which will give us exactly what we want. This can of course be
extended to support additional default values:</p><pre><code>outputs:
  sources:
    yaql:
      data:
        sources: {get_param: sources}
        default_type: tail
        default_format: &gt;
          /some regular expression/
      expression: &gt;
        let(
          default_type =&gt; $.data.default_type,
          default_format =&gt; $.data.default_format
        ) -&gt;
        $.data.sources.select({
          'path' =&gt; $.path,
          'tag' =&gt; $.tag,
          'type' =&gt; $.get('type', $default_type),
          'format' =&gt; $.get('format', $default_format)
        })
</code></pre><p>Going out on a bit of a tangent, there is another statement not
mentioned in the documentation: the <code>def</code> statement lets you defined a
yaql function. The general format is:</p><pre><code>def(func_name, func_body)
</code></pre><p>Where <code>func_body</code> is a yaql expresion. For example:</p><pre><code>def(upperpath, $.path.toUpper()) -&gt;
$.data.sources.select(upperpath($))
</code></pre><p>Which would generate:</p><pre><code>[
    &quot;/VAR/LOG/NOVA/NOVA-API.LOG&quot;, 
    &quot;/VAR/LOG/NOVA/NOVA-SCHEDULER.LOG&quot;
]
</code></pre><p>This obviously becomes more useful as you use user-defined functions
to encapsulate more complex yaql expressions for re-use.</p><p>Thanks to <a href=https://github.com/sergmelikyan>sergmelikyan</a> for his help figuring this out.</p></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>