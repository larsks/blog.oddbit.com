<!doctype html><html lang=en><head><title>Creating minimal Docker images from dynamically linked ELF binaries :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In this post, we&rsquo;ll look at a method for building minimal Docker images for dynamically linked ELF binaries, and then at a tool for automating this process.
It is tempting, when creating a simple Docker image, to start with one of the images provided by the major distributions. For example, if you need an image that provides tcpdump for use on your Atomic host, you might do something like:
FROM fedora RUN yum -y install tcpdump And while this will work, you end up consuming 250MB for tcpdump. In theory, the layering mechanism that Docker uses to build images will reduce the practical impact of this (because other images based on the fedora image will share the common layers), but in practice the size is noticeable, especially if you often find yourself pulling this image into a fresh environment with no established cache.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2015-02-05-creating-minimal-docker-images/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG")}</script><link rel=stylesheet href=https://blog.oddbit.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://blog.oddbit.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://blog.oddbit.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://blog.oddbit.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://blog.oddbit.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://blog.oddbit.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://blog.oddbit.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://blog.oddbit.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://blog.oddbit.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://blog.oddbit.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://blog.oddbit.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://blog.oddbit.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/favicon.png><link rel=apple-touch-icon href=https://blog.oddbit.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Creating minimal Docker images from dynamically linked ELF binaries"><meta property="og:description" content="In this post, we&rsquo;ll look at a method for building minimal Docker images for dynamically linked ELF binaries, and then at a tool for automating this process.
It is tempting, when creating a simple Docker image, to start with one of the images provided by the major distributions. For example, if you need an image that provides tcpdump for use on your Atomic host, you might do something like:
FROM fedora RUN yum -y install tcpdump And while this will work, you end up consuming 250MB for tcpdump. In theory, the layering mechanism that Docker uses to build images will reduce the practical impact of this (because other images based on the fedora image will share the common layers), but in practice the size is noticeable, especially if you often find yourself pulling this image into a fresh environment with no established cache.
"><meta property="og:url" content="https://blog.oddbit.com/post/2015-02-05-creating-minimal-docker-images/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2015-02-05 00:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2015-02-05-creating-minimal-docker-images/>Creating minimal Docker images from dynamically linked ELF binaries</a></h1><div class=post-meta><time class=post-date>2015-02-05&nbsp;[Updated: 2023-02-16]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/docker/>docker</a>&nbsp;</span><div class=post-content><div><p>In this post, we&rsquo;ll look at a method for building minimal Docker
images for dynamically linked ELF binaries, and then at <a href=https://github.com/larsks/dockerize>a
tool</a> for automating this process.</p><p>It is tempting, when creating a simple Docker image, to start with one
of the images provided by the major distributions. For example, if
you need an image that provides <code>tcpdump</code> for use on your <a href=http://www.projectatomic.io/>Atomic</a>
host, you might do something like:</p><pre><code>FROM fedora
RUN yum -y install tcpdump
</code></pre><p>And while this will work, you end up consuming 250MB for <code>tcpdump</code>.
In theory, the layering mechanism that Docker uses to build images
will reduce the practical impact of this (because other images based on
the <code>fedora</code> image will share the common layers), but in practice the
size is noticeable, especially if you often find yourself pulling this
image into a fresh environment with no established cache.</p><p>You can substantially reduce the space requirements for a Docker image
by including only those things that are absolutely necessary. For
statically linked files, that may only be the binary itself, but the
situation is a little more complex for dynamically linked executables.
You might naively start with this (assuming that you had the <code>tcpdump</code>
binary in your local directory):</p><pre><code>FROM scratch
COPY tcpdump /usr/sbin/tcpdump
</code></pre><p>If you were to build an image with this and tag it <code>tcpdump</code>&mldr;</p><pre><code>docker build -t tcpdump .
</code></pre><p>&mldr;and then try running it:</p><pre><code>docker run tcpdump
</code></pre><p>You would immediately see:</p><pre><code>no such file or directory
FATA[0003] Error response from daemon: Cannot start container ...:
no such file or directory 
</code></pre><p>And this is because the image is missing two things:</p><ul><li>The Linux dynamic runtime loader, and</li><li>The shared libraries required by the <code>tcpdump</code> binary</li></ul><p>The path to the appropriate loader is stored in the ELF binary in the
<code>.interp</code> section, which we can inspect using the <code>objdump</code> tool:</p><pre><code>$ objdump -s -j .interp tcpdump 

tcpdump:     file format elf64-x86-64

Contents of section .interp:
 400238 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-
 400248 7838362d 36342e73 6f2e3200           x86-64.so.2.    
</code></pre><p>Which tells us we need <code>/lib64/ld-linux-x86-64.so.2</code>.</p><p>We can use the <code>ldd</code> tool to get a list of shared libraries required
by the binary:</p><pre><code>$ ldd tcpdump
linux-vdso.so.1 =&gt;  (0x00007fffed1fe000)
libcrypto.so.10 =&gt; /lib64/libcrypto.so.10 (0x00007fb2c05a3000)
libpcap.so.1 =&gt; /lib64/libpcap.so.1 (0x00007fb2c0361000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fb2bffa3000)
libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fb2bfd9f000)
libz.so.1 =&gt; /lib64/libz.so.1 (0x00007fb2bfb89000)
/lib64/ld-linux-x86-64.so.2 (0x00007fb2c09b7000)
</code></pre><p>If we copy all of the dependencies into a local directory, along with
the <code>tcpdump</code> binary itself, and use the following layout:</p><pre><code>Dockerfile
usr/sbin/tcpdump
lib64/libcrypto.so.10
lib64/libpcap.so.1
lib64/libc.so.6
lib64/libdl.so.2
lib64/libz.so.1
lib64/ld-linux-x86-64.so.2
</code></pre><p>And the following Dockerfile content:</p><pre><code>FROM scratch
COPY . /
ENTRYPOINT [&quot;/usr/sbin/tcpdump&quot;]
</code></pre><p>And then we turn this into a Docker image and run it, we get:</p><pre><code>$ docker build -t tcpdump .
[...]
$ docker run tcpdump tcpdump -i eth0 -n
tcpdump: Couldn't find user 'tcpdump'
</code></pre><p>Well, so let&rsquo;s create an <code>/etc/passwd</code> file with the <code>tcpdump</code> user
and add that to our collection:</p><pre><code>$ mkdir etc
$ grep tcpdump /etc/passwd &gt; etc/passwd
$ grep tcpdump /etc/group &gt; etc/group
$ docker build -t tcpdump .
$ docker run tcpdump tcpdump -i eth0 -n
tcpdump: Couldn't find user 'tcpdump'
</code></pre><p>And <em>this</em> is because most programs don&rsquo;t reference files like
<code>/etc/passwd</code> directly, but instead delegate this task to the C
library, which relies on the <a href=http://www.gnu.org/software/libc/manual/html_node/Name-Service-Switch.html>name service switch</a> (nss)
mechanism to support multiple sources of information. Let&rsquo;s add the
nss libraries necessary for supporting legacy files (<code>/etc/passwd</code>,
etc) and DNS for hostname lookups:</p><ul><li><p><code>lib64/libnss_files.so.2</code> &ndash; this includes support the traditional
files in <code>/etc</code>, such as <code>/etc/passwd</code>, <code>/etc/group</code>, and
<code>/etc/hosts</code>.</p></li><li><p><code>lib64/libnss_dns.so.2</code> &ndash; this supports hostname resolution via
dns.</p></li></ul><p>And we&rsquo;ll also need <code>/etc/nsswitch.conf</code> to go along with that:</p><pre><code>passwd:     files
shadow:     files
group:      files
hosts:      files dns
</code></pre><p>After all this, we have:</p><pre><code>Dockerfile
usr/sbin/tcpdump
lib64/libcrypto.so.10
lib64/libpcap.so.1
lib64/libc.so.6
lib64/libdl.so.2
lib64/libz.so.1
lib64/ld-linux-x86-64.so.2
lib64/libnss_files.so.2
lib64/libnss_dns.so.2
etc/passwd
etc/group
etc/nsswitch.conf
</code></pre><p>Let&rsquo;s rebuild the image and run it one more time:</p><pre><code>$ docker build -t tcpdump .
$ docker run tcpdump -i eth0 -n
</code></pre><p>And now, finally it runs. Wouldn&rsquo;t it be nice if that process were
easier?</p><h2 id=introducing-dockerize>Introducing Dockerize<a href=#introducing-dockerize class=hanchor arialabel=Anchor>#</a></h2><p><a href=https://github.com/larsks/dockerize>Dockerize</a> is a tool that largely automates the above process. To
build a minimal <code>tcpdump</code> image, for example, you would run:</p><pre><code>$ dockerize -u tcpdump -t tcpdump /usr/sbin/tcpdump
</code></pre><p>This would include the <code>tcpdump</code> user (<code>-u tcpdump</code>) from your local
system, as well as <code>/usr/sbin/tcpdump</code>, all it&rsquo;s dependencies, and
file-based nss support, and build an image tagged <code>tcpdump</code> (<code>-t tcpdump</code>). When you build an image from a single command, like this,
Dockerize will up that command as the Docker <code>ENTRYPOINT</code>, so you can
run it like this:</p><pre><code>$ docker run tcpdump -i eth0 -n
</code></pre><p>You can also build images containing multiple binaries. For example:</p><pre><code>$ dockerize -t dockerizeme/xmltools \
    /usr/bin/xmllint \
    /usr/bin/xml2  \
    /usr/bin/2xml \
    /usr/bin/tidyp
</code></pre><p>In this case, you need to provide the command name when running the
image:</p><pre><code>$ docker run dockerizeme/xmltools tidyp -h
</code></pre><h2 id=examples>Examples<a href=#examples class=hanchor arialabel=Anchor>#</a></h2><p>You can find some scripts that generate marginally useful example
images in the <a href=https://github.com/larsks/dockerize/tree/master/examples>examples</a> folder of the repository.</p><p>These are pushed into the <a href=https://hub.docker.com/u/dockerizeme/>dockerizeme</a> namespace on the Docker hub,
so you can, for example, get yourself a minimal webserver by running:</p><pre><code>$ docker run -v $PWD:/content -p 8888:80 dockerizeme/thttpd -d /content
</code></pre><p>And then browse to <a href=http://localhost:8888>http://localhost:8888</a> and see your current
directory.</p></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>