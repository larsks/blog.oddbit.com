<!doctype html><html lang=en><head><title>Kubernetes External Secrets :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="At $JOB we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using ArgoCD and Kustomize. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2021-09-03-kubernetes-external-secrets/><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Kubernetes External Secrets"><meta property="og:description" content="At $JOB we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using ArgoCD and Kustomize. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials."><meta property="og:url" content="https://blog.oddbit.com/post/2021-09-03-kubernetes-external-secrets/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2021-09-03 00:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2021-09-03-kubernetes-external-secrets/>Kubernetes External Secrets</a></h1><div class=post-meta><time class=post-date>2021-09-03 ::
[Updated :: 2023-02-16]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/openshift/>openshift</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/secrets/>secrets</a>&nbsp;</span>
<img src=/post/2021-09-03-kubernetes-external-secrets/cover.jpg class=post-cover alt="Kubernetes External Secrets" title="Cover Image"><div class=post-content><div><p>At <em>$JOB</em> we maintain the configuration for our OpenShift clusters in a public git repository. Changes in the git repository are applied automatically using <a href=https://argo-cd.readthedocs.io/en/stable/>ArgoCD</a> and <a href=https://kustomize.io/>Kustomize</a>. This works great, but the public nature of the repository means we need to find a secure solution for managing secrets (such as passwords and other credentials necessary for authenticating to external services). In particular, we need a solution that permits our public repository to be the source of truth for our cluster configuration, without compromising our credentials.</p><h2 id=rejected-options>Rejected options<a href=#rejected-options class=hanchor arialabel=Anchor>&#8983;</a></h2><p>We initially looked at including secrets directly in the repository through the use of the <a href=https://github.com/viaduct-ai/kustomize-sops>KSOPS</a> plugin for Kustomize, which uses <a href=https://github.com/mozilla/sops>sops</a> to encrypt secrets with GPG keys. There are some advantages to this arrangement:</p><ul><li>It doesn&rsquo;t require any backend service</li><li>It&rsquo;s easy to control read access to secrets in the repository by encrypting them to different recipients.</li></ul><p>There were some minor disadvantages:</p><ul><li>We can&rsquo;t install ArgoCD via the operator because we need a customized image that includes KSOPS, so we have to maintain our own ArgoCD image.</li></ul><p>And there was one major problem:</p><ul><li>Using GPG-encrypted secrets in a git repository makes it effectively impossible to recover from a key compromise.</li></ul><p>One a private key is compromised, anyone with access to that key and the git repository will be able to decrypt data in historical commits, even if we re-encrypt all the data with a new key.</p><p>Because of these security implications we decided we would need a different solution (it&rsquo;s worth noting here that Bitnami <a href=https://github.com/bitnami-labs/sealed-secrets>Sealed Secrets</a> suffers from effectively the same problem).</p><h2 id=our-current-solution>Our current solution<a href=#our-current-solution class=hanchor arialabel=Anchor>&#8983;</a></h2><p>We&rsquo;ve selected a solution that uses the <a href=https://github.com/external-secrets/kubernetes-external-secrets>External Secrets</a> project in concert with the AWS <a href=https://aws.amazon.com/secrets-manager/>SecretsManager</a> service.</p><h3 id=kubernetes-external-secrets>Kubernetes external secrets<a href=#kubernetes-external-secrets class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The <a href=https://github.com/external-secrets/kubernetes-external-secrets>External Secrets</a> project allows one to store secrets in an external secrets store, such as AWS <a href=https://aws.amazon.com/secrets-manager/>SecretsManager</a>, Hashicorp <a href=https://www.vaultproject.io/>Vault</a>, and others <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. The manifests that get pushed into your OpenShift cluster contain only pointers (called <code>ExternalSecrets</code>) to those secrets; the external secrets controller running on the cluster uses the information contained in the <code>ExternalSecret</code> in combination with stored credentials to fetch the secret from your chosen backend and realize the actual <code>Secret</code> resource. An external secret manifest referring to a secret named <code>mysceret</code> stored in AWS SecretsManager would look something like:</p><pre tabindex=0><code>apiVersion: &#34;kubernetes-client.io/v1&#34;
kind: ExternalSecret
metadata:
  name: example-secret
spec:
  backendType: secretsManager
  data:
    - key: mysecret
      name: mysecretvalue
</code></pre><p>This model means that no encrypted data is ever stored in the git repository, which resolves the main problem we had with the solutions mentioned earlier.</p><p>External Secrets can be installed into your Kubernetes environment using Helm, or you can use <code>helm template</code> to generate manifests locally and apply them using Kustomize or some other tool (this is the route we took).</p><h3 id=aws-secretsmanager-service>AWS SecretsManager Service<a href=#aws-secretsmanager-service class=hanchor arialabel=Anchor>&#8983;</a></h3><p>AWS <a href=https://aws.amazon.com/secrets-manager/>SecretsManager</a> is a service for storing and managing secrets and making them accessible via an API. Using SecretsManager we have very granular control over who can view or modify secrets; this allows us, for example, to create cluster-specific secret readers that can only read secrets intended for a specific cluster (e.g. preventing our development environment from accidentally using production secrets).</p><p>SecretsManager provides automatic versioning of secrets to prevent loss of data if you inadvertently change a secret while still requiring the old value.</p><p>We can create secrets through the AWS SecretsManager console, or we can use the <a href=https://aws.amazon.com/cli/>AWS CLI</a>, which looks something like:</p><pre tabindex=0><code>aws secretsmanager create-secret \
  --name mysecretname \
  --secret-string mysecretvalue
</code></pre><h3 id=two-great-tastes-that-taste-great-together>Two great tastes that taste great together<a href=#two-great-tastes-that-taste-great-together class=hanchor arialabel=Anchor>&#8983;</a></h3><p>This combination solves a number of our problems:</p><ul><li><p>Because we&rsquo;re not storing actual secrets in the repository, we don&rsquo;t need to worry about encrypting anything.</p></li><li><p>Because we&rsquo;re not managing encrypted data, replacing secrets is much easier.</p></li><li><p>There&rsquo;s a robust mechanism for controlling access to secrets.</p></li><li><p>This solution offers a separation of concern that simply wasn&rsquo;t possible with the KSOPS model: someone can maintain secrets without having to know anything about Kubernetes manifests, and someone can work on the repository without needing to know any secrets.</p></li></ul><h2 id=creating-external-secrets>Creating external secrets<a href=#creating-external-secrets class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In its simplest form, an <code>ExternalSecret</code> resource maps values from specific named secrets in the backend to keys in a <code>Secret</code> resource. For example, if we wanted to create a <code>Secret</code> in OpenShift with the username and password for an external service, we could create to separate secrets in SecretsManager. One for the username:</p><pre tabindex=0><code>aws secretsmanager create-secret \
  --name cluster/cluster1/example-secret-username \
  --secret-string foo
</code></pre><p>And one for the password:</p><pre tabindex=0><code>aws secretsmanager create-secret \
  --name cluster/cluster1/example-secret-password \
  --secret-string bar \
  --tags Key=cluster,Value=cluster1
</code></pre><p>And then create an <code>ExternalSecret</code> manifest like this:</p><pre tabindex=0><code>apiVersion: &#34;kubernetes-client.io/v1&#34;
kind: ExternalSecret
metadata:
  name: example-secret
spec:
  backendType: secretsManager
  data:
    - key: cluster/cluster1/example-secret-username
      name: username
    - key: cluster/cluster1/example-secret-password
      name: password
</code></pre><p>This instructs the External Secrets controller to create an <code>Opaque</code> secret named <code>example-secret</code> from data in AWS SecretsManager. The value of the <code>username</code> key will come from the secret named <code>cluster/cluster1/example-secret-username</code>, and similarly for <code>password</code>. The resulting <code>Secret</code> resource will look something like this:</p><pre tabindex=0><code>apiVersion: v1
kind: Secret
metadata:
  name: example-secret
type: Opaque
data:
  password: YmFy
  username: Zm9v
</code></pre><h3 id=templates-for-structured-data>Templates for structured data<a href=#templates-for-structured-data class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In the previous example, we created two separate secrets in SecretsManager for storing a username and password. It might be more convenient if we could store both credentials in a single secret. Thanks to the <a href=https://github.com/external-secrets/kubernetes-external-secrets#templating>templating</a> support in External Secrets, we can do that!</p><p>Let&rsquo;s redo the previous example, but instead of using two separate secrets, we&rsquo;ll create a single secret named <code>cluster/cluster1/example-secret</code> in which the secret value is a JSON document containing both the username and password:</p><pre tabindex=0><code>aws secretsmanager create-secret \
  --name cluster/cluster1/example-secret \
  --secret-string &#39;{&#34;username&#34;: &#34;foo&#34;, &#34;password&#34;: &#34;bar&#34;}&#39;
</code></pre><p>NB: The <a href=https://github.com/jpmens/jo>jo</a> utility is a neat little utility for generating JSON from the command line; using that we could write the above like this&mldr;</p><pre tabindex=0><code>aws secretsmanager create-secret \
  --name cluster/cluster1/example-secret \
  --secret-string $(jo username=foo password=bar)
</code></pre><p>&mldr;which makes it easier to write JSON without missing a quote, closing bracket, etc.</p><p>We can extract these values into the appropriate keys by adding a <code>template</code> section to our <code>ExternalSecret</code>, and using the <code>JSON.parse</code> template function, like this:</p><pre tabindex=0><code>apiVersion: &#34;kubernetes-client.io/v1&#34;
kind: ExternalSecret
metadata:
  name: example-secret
  namespace: sandbox
spec:
  backendType: secretsManager
  data:
    - key: cluster/cluster1/example-secret
      name: creds
  template:
    stringData:
      username: &#34;&lt;%= JSON.parse(data.creds).username %&gt;&#34;
      password: &#34;&lt;%= JSON.parse(data.creds).password %&gt;&#34;
</code></pre><p>The result secret will look like:</p><pre tabindex=0><code>apiVersion: v1
kind: Secret
metadata:
  name: example-secret
type: Opaque
data:
  creds: eyJ1c2VybmFtZSI6ICJmb28iLCAicGFzc3dvcmQiOiAiYmFyIn0=
  password: YmFy
  username: Zm9v
</code></pre><p>Notice that in addition to the values created in the <code>template</code> section, the <code>Secret</code> also contains any keys defined in the <code>data</code> section of the <code>ExternalSecret</code>.</p><p>Templating can also be used to override the secret type if you want something other than <code>Opaque</code>, add metadata, and otherwise influence the generated <code>Secret</code>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>E.g. Azure Key Vault, Google Secret Manager, Alibaba Cloud KMS Secret Manager, Akeyless&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script>
<script src=/js/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>