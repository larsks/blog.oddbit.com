<!doctype html><html lang=en><head><title>Unpacking a Python regular expression :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="I recently answered a question from Harsha Nalore on StackOverflow that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an Ansible filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/><script async src="https://www.googletagmanager.com/gtag/js?id=G-G1FYT93ENG"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G1FYT93ENG",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Unpacking a Python regular expression"><meta property="og:description" content="I recently answered a question from Harsha Nalore on StackOverflow that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an Ansible filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are."><meta property="og:url" content="https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2019-05-07 10:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/>Unpacking a Python regular expression</a></h1><div class=post-meta><time class=post-date>2019-05-07 ::
[Updated :: 2023-02-16]</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/python/>python</a>&nbsp;
#<a href=https://blog.oddbit.com/tags/stackexchange/>stackexchange</a>&nbsp;</span><div class=post-content><div><p>I recently answered <a href=https://stackoverflow.com/q/55965819/147356>a question</a> from <a href=https://stackoverflow.com/users/7738974/harsha-nalore>Harsha Nalore</a> on <a href=https://stackoverflow.com/>StackOverflow</a> that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &ndash; which I claim to be functional, but probably not optimal &ndash; involved writing an <a href=https://ansible.com/>Ansible</a> filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&rsquo;t really seem the write place for that: so, here we are.</p><p>The output in question looks like this:</p><pre tabindex=0><code>gtm wideip a wideip {
    description wideip
    pool-lb-mode topology
    pools {
        test1-pool {
            order 1
        }
        test2-pool {
            order 0
        }
    }
}
</code></pre><p>The goal is to return a list of pool names. You can see the complete solution in <a href=https://stackoverflow.com/a/55970019/147356>my answer</a>; for the purposes of this post we&rsquo;re interesting in the following two regular expressions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>re_pools <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(?P&lt;parameters&gt;(\S+ \s+ \S+ \s+)*)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>pools \s+ { \s+ (?P&lt;pools&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(?:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>\S+ \s+ {  \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>[^}]* \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>} \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>)+ \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;&#39;</span>, flags<span style=color:#f92672>=</span>re<span style=color:#f92672>.</span>VERBOSE)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>re_pool <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(\S+) \s+ { \s+ [^}]* \s+ } \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;&#39;</span>, flags<span style=color:#f92672>=</span>re<span style=color:#f92672>.</span>VERBOSE)
</span></span></code></pre></div><h1 id=verbose-mode>VERBOSE mode<a href=#verbose-mode class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The first thing to note is that I&rsquo;m using <code>VERBOSE</code> syntax for both of these expressions. That means that whitespace must be included explicitly in the expression. That&rsquo;s what all of those <code>\s+</code> markers are &ndash; that means &ldquo;any white space character, one or more times&rdquo;. For example, consider the following simple expression:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>&#39;this is a test&#39;</span>, <span style=color:#e6db74>&#39;this is a test&#39;</span>)
</span></span></code></pre></div><p>The pattern matches the string just fine. But if we were to enable the <code>VERBOSE</code> flag, the pattern would no longer match:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>&#39;this is a test&#39;</span>, <span style=color:#e6db74>&#39;this is a test&#39;</span>, flags<span style=color:#f92672>=</span>re<span style=color:#f92672>.</span>VERBOSE)
</span></span></code></pre></div><p>We would instead need to write it like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>&#39;this \s is \s a \s test&#39;</span>, <span style=color:#e6db74>&#39;this is a test&#39;</span>, flags<span style=color:#f92672>=</span>re<span style=color:#f92672>.</span>VERBOSE)
</span></span></code></pre></div><p>The advantage to <code>VERBOSE</code> mode is that you can split your regular expression across multiple lines for legibility:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>... this \s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>... is \s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>... a \s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>... test&#39;&#39;&#39;</span>, <span style=color:#e6db74>&#39;this is a test&#39;</span>, flags<span style=color:#f92672>=</span>re<span style=color:#f92672>.</span>VERBOSE)
</span></span></code></pre></div><h2 id=capture-groups>Capture groups<a href=#capture-groups class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In order to make it easier to extract information from the results of a match, I&rsquo;m using named capture groups. A &ldquo;capture group&rdquo; is a part of the expression inside parentheses that can be extracted from the resulting match object. Unnamed groups can be extracted using their index. If we wanted to match the phrase <code>this is a &lt;noun></code>, rather than <code>this is a test</code>, and we wanted to extract the noun, we might write something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re_example <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;this is a (\S+)&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>=</span> re_example<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>&#39;this is a frog&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span><span style=color:#f92672>.</span>groups()
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#39;frog&#39;</span>,)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span><span style=color:#f92672>.</span>group(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;frog&#39;</span>
</span></span></code></pre></div><p>The expression <code>(\S+)</code> is a capture group that will match any string of non-whitespace characters. This works fine for a simple expression, but keeping the index straight in a complex expression can be difficult. This is where named capture groups become useful. We could rewrite the above like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re_example <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;this is a (?P&lt;noun&gt;\S+)&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>=</span> re_example<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>&#39;this is a frog&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span><span style=color:#f92672>.</span>groupdict()
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#39;noun&#39;</span>: <span style=color:#e6db74>&#39;frog&#39;</span>}
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span><span style=color:#f92672>.</span>group(<span style=color:#e6db74>&#39;noun&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;frog&#39;</span>
</span></span></code></pre></div><h2 id=non-capture-groups>Non-capture groups<a href=#non-capture-groups class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Sometimes, you want to group part of a regular expression in a way that does not result in another capture group. This is what the <code>(?: ...)</code> expression is for. For example, we we were to write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re_example <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;this (?:is|was) a (?P&lt;noun&gt;\S+)&#39;</span>)
</span></span></code></pre></div><p>Then we could match the phrase <code>this is a test</code> or <code>this was a test</code>, but we would still only have a single capture group:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>=</span> re_example<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>&#39;this is a test&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>match</span><span style=color:#f92672>.</span>groupdict()
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#39;noun&#39;</span>: <span style=color:#e6db74>&#39;test&#39;</span>}
</span></span></code></pre></div><h2 id=putting-it-all-together>Putting it all together<a href=#putting-it-all-together class=hanchor arialabel=Anchor>&#8983;</a></h2><p>With all that in mind, let&rsquo;s take a look at the regular expression in my answer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>re_pools <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(?P&lt;parameters&gt;(\S+ \s+ \S+ \s+)*)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>pools \s+ { \s+ (?P&lt;pools&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(?:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>\S+ \s+ {  \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>[^}]* \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>} \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>)+ \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;&#39;</span>, flags<span style=color:#f92672>=</span>re<span style=color:#f92672>.</span>VERBOSE)
</span></span></code></pre></div><p>The first line matches <code>gtm wideip a &lt;something> {</code>:</p><pre><code>gtm \s+ wideip \s+ a \s+ (\S+) \s+ { \s+
</code></pre><p>Next, we match the <code>&lt;key> &lt;value></code> part of the output, which looks like this:</p><pre><code>description wideip
pool-lb-mode topology
</code></pre><p>With this expression:</p><pre><code> (?P&lt;parameters&gt;(\S+ \s+ \S+ \s+)*)
</code></pre><p>That is a named capture group (&ldquo;parameters&rdquo;) that matches the expression <code>(\S+ \s+ \S+ \s+)</code> zero or more times (<code>*</code>). Since <code>\S+</code> means &ldquo;a string of non-whitespace characters&rdquo; and <code>\s+</code> means &ldquo;a string of whitespace characters&rdquo;, this correctly matches that part of the output.</p><p>Next, we match the entire <code>pools {...}</code> part of the output with this expression:</p><pre><code>pools \s+ { \s+ (?P&lt;pools&gt;
(?:
\S+ \s+ {  \s+
[^}]* \s+
} \s+
)+ \s+
)
</code></pre><p>That creates a named capture group (&ldquo;pools&rdquo;) that looks for one or more occurrences of the pattern:</p><pre><code>\S+ \s+ {  \s+
[^}]* \s+
} \s+
</code></pre><p>The first line will match a string like <code>test1-pool1 {</code>. The next line matches any sequence of characters that are not <code>}</code>, so that gathers up everthing between <code>test1-pool {</code> and the closing <code>}</code>. Because we have the entire thing wrapped in <code>(?: ...)+</code>, we are looking for one or more matches of that sub-expression, which gathers up all of the pool definitions.</p><p>Finally we match the closing brace:</p><pre><code>}
</code></pre><p>When that expression matches, we end up with a match object that has a <code>pools</code> match group that will look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(<span style=color:#66d9ef>match</span><span style=color:#f92672>.</span>group(<span style=color:#e6db74>&#39;pools&#39;</span>))
</span></span><span style=display:flex><span>test1<span style=color:#f92672>-</span>pool {
</span></span><span style=display:flex><span>            order <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        test2<span style=color:#f92672>-</span>pool {
</span></span><span style=display:flex><span>            order <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>We now use a much simpler regular expression to extract the pool names from that content:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>re_pool <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(\S+) \s+ { \s+ [^}]* \s+ } \s+
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;&#39;</span>, flags<span style=color:#f92672>=</span>re<span style=color:#f92672>.</span>VERBOSE)
</span></span></code></pre></div><p>That has a single capture group (<code>(\S+)</code>) that will match the pool name; the remainder of the expression takes care of matching the <code>{ &lt;anythingthing not '}'> }</code> part. We use <code>re.findall</code> to get <em>all</em> of the matches in one go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re_pool<span style=color:#f92672>.</span>findall(<span style=color:#66d9ef>match</span><span style=color:#f92672>.</span>group(<span style=color:#e6db74>&#39;pools&#39;</span>))
</span></span><span style=display:flex><span>[<span style=color:#e6db74>&#39;test1-pool&#39;</span>, <span style=color:#e6db74>&#39;test2-pool&#39;</span>]
</span></span></code></pre></div><p>And that&rsquo;s it!</p><h2 id=for-more-information>For more information<a href=#for-more-information class=hanchor arialabel=Anchor>&#8983;</a></h2><p>For more information on Python regular expressions:</p><ul><li>The documentation for the <a href=https://docs.python.org/3/library/re.html>re</a> module.</li><li>The <a href=https://docs.python.org/3/howto/regex.html>Regular expression HOWTO</a></li></ul></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script>
<script src=/js/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></div></body></html>