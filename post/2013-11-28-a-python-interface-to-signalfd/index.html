<!doctype html><html lang=en><head><title>A Python interface to signalfd() using FFI :: blog.oddbit.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="I just recently learned about the signalfd(2) system call, which was introduced to the Linux kernel back in 2007:
signalfd() creates a file descriptor that can be used to accept signals targeted at the caller. This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7).
The traditional asynchronous delivery mechanism can be tricky to get right, whereas this provides a convenient fd interface that integrates nicely with your existing event-based code."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.oddbit.com/post/2013-11-28-a-python-interface-to-signalfd/><link rel=stylesheet href=https://blog.oddbit.com/styles.css><link rel=stylesheet href=https://blog.oddbit.com/style.css><link rel="shortcut icon" href=https://blog.oddbit.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://blog.oddbit.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="A Python interface to signalfd() using FFI"><meta property="og:description" content="I just recently learned about the signalfd(2) system call, which was introduced to the Linux kernel back in 2007:
signalfd() creates a file descriptor that can be used to accept signals targeted at the caller. This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7).
The traditional asynchronous delivery mechanism can be tricky to get right, whereas this provides a convenient fd interface that integrates nicely with your existing event-based code."><meta property="og:url" content="https://blog.oddbit.com/post/2013-11-28-a-python-interface-to-signalfd/"><meta property="og:site_name" content="blog.oddbit.com"><meta property="og:image" content="https://blog.oddbit.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="tech"><meta property="article:published_time" content="2013-11-28 00:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>the odd bit blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>/</a></li><li><a href=https://oddbit.com>/about</a></li><li><a href=/posts>/posts</a></li><li><a href=/tags>/tags</a></li><li><a href=/archive>/archive</a></li><li><ul class=menu><li class=menu__trigger>&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/rss.xml>/feed</a></li><li><a href=https://github.com/larsks>→Github</a></li><li><a href=https://hachyderm.io/@larsks>→Mastodon</a></li><li><a href=https://twitter.com/larsks>→Twitter</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://blog.oddbit.com/post/2013-11-28-a-python-interface-to-signalfd/>A Python interface to signalfd() using FFI</a></h1><div class=post-meta><time class=post-date>2013-11-28 ::</time></div><span class=post-tags>#<a href=https://blog.oddbit.com/tags/python/>python</a>&nbsp;</span><div class=post-content><div><p>I just recently learned about the <code>signalfd(2)</code> system call, which was
introduced to the Linux kernel <a href=http://lwn.net/Articles/225714/>back in 2007</a>:</p><blockquote><p>signalfd() creates a file descriptor that can be used to accept
signals targeted at the caller. This provides an alternative to
the use of a signal handler or sigwaitinfo(2), and has the
advantage that the file descriptor may be monitored by select(2),
poll(2), and epoll(7).</p></blockquote><p>The traditional asynchronous delivery mechanism can be tricky to get
right, whereas this provides a convenient fd interface that integrates
nicely with your existing event-based code.</p><p>I was interested in using <code>signalfd()</code> in some Python code, but Python
does not expose this system call through any of the standard
libraries. There are a variety of ways one could add support,
including:</p><ul><li>Writing a Python module in C</li><li>Using the <code>ctypes</code> module (which I played with <a href=https://blog.oddbit.com/post/2010-08-10-python-ctypes-module/>a few years ago</a>)</li></ul><p>However, I decided to use this as an excuse to learn about the
<a href=https://pypi.python.org/pypi/cffi>cffi</a> module. You can find the complete code in my
<a href=https://github.com/larsks/python-signalfd>python-signalfd</a> repository and an explanation of the process
below.</p><p>The <a href=http://cffi.readthedocs.org/>cffi documentation</a> lists a number of principles the project
tries to follow; the first two read as follows:</p><blockquote><ul><li>The goal is to call C code from Python. You should be able to do so without learning a 3rd language: every alternative requires you to learn their own language (Cython, SWIG) or API (ctypes)&mldr;</li><li>Keep all the Python-related logic in Python so that you don&rsquo;t need to write much C code (unlike CPython native C extensions).</li></ul></blockquote><p>In practice, what this means is that if the C API documentation for a
function looks like this:</p><pre><code>unsigned int sleep(unsigned int seconds);
</code></pre><p>Then you can make this function available in Python like this:</p><pre><code>from cffi import FFI
ffi = FFI()
crt = ffi.dlopen(None)
ffi.cdef('unsigned int sleep(unsigned int seconds);')
</code></pre><p>And to use it:</p><pre><code>crt.sleep(10)
</code></pre><p>While this works great for a simple function like <code>sleep</code>, it gets
slightly more complicated when you function prototype looks like this:</p><pre><code>   #include &lt;sys/signalfd.h&gt;
   int signalfd(int fd, const sigset_t *mask, int flags);
</code></pre><p>If you try what seems obvious given the above example:</p><pre><code>ffi.cdef('''
       #include &lt;sys/signalfd.h&gt;
       int signalfd(int fd, const sigset_t *mask, int flags);
''')
</code></pre><p>You&rsquo;ll run into an error:</p><pre><code>cffi.api.CDefError: cannot parse &quot;#include &lt;sys/signalfd.h&gt;&quot;
:3: Directives not supported yet
</code></pre><p>You can try that without the <code>#include</code> statement, but you&rsquo;ll just get
a new error:</p><pre><code>cffi.api.CDefError: cannot parse &quot;int signalfd(int fd, const sigset_t *mask, int flags);&quot;
:3:37: before: *
</code></pre><p>What all this means is that you need to translate <code>sigset_t</code> into
standard C types. You could go digging through include files in
<code>/usr/include</code>, but an easier method is to create a small C source
file like this:</p><pre><code>#include &lt;sys/signalfd.h&gt;
</code></pre><p>And then run it through the preprocessor:</p><pre><code>$ gcc -E sourcefile.c
</code></pre><p>Inspecting the output of this command reveals that <code>sigset_t</code> is a
typedef for <code>__sigset_t</code>, and that <code>__sigset_t</code> looks like this:</p><pre><code>typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
typedef __sigset_t sigset_t;
</code></pre><p>If you plug this into your <code>cdef</code>:</p><pre><code>ffi.cdef('''
typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
typedef __sigset_t sigset_t;

int signalfd(int fd, const sigset_t *mask, int flags);
''')
</code></pre><p>You end up with the following:</p><pre><code>cffi.api.FFIError: unsupported non-constant or not immediately constant expression
</code></pre><p>This happens because of the <code>sizeof()</code> expression in the <code>struct</code>. We
need to replace that with an actual size. We can use the
<code>ffi.sizeof()</code> method to accomplish the same thing, like this:</p><pre><code>ffi.cdef('''
typedef struct
{
  unsigned long int __val[%d];
} __sigset_t;
typedef __sigset_t sigset_t;

int signalfd (int fd, const sigset_t * mask, int flags);
''' % ( 1024 / (8 * ffi.sizeof('''unsigned long int''') )))
</code></pre><p>This will load without error. You can create a variable suitable for
passing as the <code>mask</code> parameter to <code>signalfd</code> like this:</p><pre><code>&gt;&gt;&gt; mask = ffi.new('sigset_t *')
&gt;&gt;&gt; mask
&lt;cdata 'struct $__sigset_t *' owning 128 bytes&gt;
</code></pre><p>The trick, of course, is populating that variable correctly. I ended
up just implementing all of the <code>sigsetops</code> functions, which, having
already set up the <code>sigset_t</code> structure, meant just adding this:</p><pre><code>ffi.cdef('''
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigismember(const sigset_t *set, int signum);
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
''')
</code></pre><p>Now we&rsquo;re all set to call these functions through the <code>crt</code> variable
we created ealier (by calling <code>ffi.dlopen(None)</code>):</p><pre><code>&gt;&gt;&gt; import signal
&gt;&gt;&gt; mask = ffi.new('sigset_t *')
&gt;&gt;&gt; crt.sigemptyset(mask)
0
&gt;&gt;&gt; crt.sigismember(mask, signal.SIGINT)
0
&gt;&gt;&gt; crt.sigaddset(mask, signal.SIGINT)
0
&gt;&gt;&gt; crt.sigismember(mask, signal.SIGINT)
1
</code></pre><p>And finally, we can all <code>signalfd()</code>:</p><pre><code>&gt;&gt;&gt; crt.sigprocmask(0, mask, ffi.NULL)
0
&gt;&gt;&gt; fd = crt.signalfd(-1, mask, 0)
&gt;&gt;&gt; from select import poll
&gt;&gt;&gt; p = poll()
&gt;&gt;&gt; p.register(fd)
&gt;&gt;&gt; p.poll()
^C[(3, 1)]
&gt;&gt;&gt; 
</code></pre><p>In case it&rsquo;s not obvious from the above example, when I typed
<code>CONTROL-C</code> on my keyboard, sending a <code>SIGINT</code> to the Python shell, it
caused the <code>p.poll()</code> method to exit, reporting activity on fd 3
(which is the fd we were given by <code>signalfd()</code>). We call
<code>sigprocmask(2)</code> to prevent the normal asynchronous delivery of
signals, which would otherwise result in Python handling the <code>SIGINT</code>
and generating a <code>KeyboardInterrupt</code> exception.</p><p>You can find this all packaged up nicely with a slightly more pythonic
interface in my <a href=https://github.com/larsks/python-signalfd>python-signalfd</a> repository on GitHub.</p><hr><p><a href=http://gabrbedd.wordpress.com/>Gabe&rsquo;s Geek Log</a> has an <a href=http://gabrbedd.wordpress.com/2013/07/29/handling-signals-with-signalfd/>article about signalfd</a> that is also
worth reading.</p></div></div><script src=https://utteranc.es/client.js repo=larsks/blog.oddbit.com issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Lars Kellogg-Stedman</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>